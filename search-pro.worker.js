const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":333,\"nextId\":333,\"documentIds\":{\"0\":\"1\",\"1\":\"1#面向对象\",\"2\":\"1#封装\",\"3\":\"1#继承\",\"4\":\"1#多态\",\"5\":\"1#重写和重载\",\"6\":\"1#重写\",\"7\":\"1#重载\",\"8\":\"1#泛型机制\",\"9\":\"1#为什么引入泛型\",\"10\":\"1#泛型的基本使用\",\"11\":\"1#泛型类\",\"12\":\"1#泛型接口\",\"13\":\"1#泛型方法\",\"14\":\"1#泛型的上下限\",\"15\":\"1#泛型数组\",\"16\":\"1#深入理解泛型\",\"17\":\"1#泛型的擦除原则\",\"18\":\"1#如何进行擦除\",\"19\":\"1#如何理解泛型的多态-泛型的桥接方法\",\"20\":\"1#如何理解基本类型不能作为泛型类型\",\"21\":\"1#如何理解泛型类型不能实例化\",\"22\":\"1#如何获取泛型的参数类型\",\"23\":\"1#注解机制\",\"24\":\"1#注解基础\",\"25\":\"1#java自带的标准注解\",\"26\":\"1#元注解\",\"27\":\"1#自定义注解\",\"28\":\"1#深入理解注解\",\"29\":\"1#java8提供了哪些新的注解\",\"30\":\"1#注解支持继承吗\",\"31\":\"1#注解实现的原理\",\"32\":\"1#自定义注解和aop-通过切面实现解耦\",\"33\":\"1#异常机制\",\"34\":\"1#异常的层次结构\",\"35\":\"1#异常基础\",\"36\":\"1#异常实践\",\"37\":\"1#深入理解异常\",\"38\":\"1#反射机制\",\"39\":\"1#反射基础\",\"40\":\"1#反射使用\",\"41\":\"1#反射机制执行的流程\",\"42\":\"1#spi-机制\",\"43\":\"1#spi-机制介绍\",\"44\":\"1#spi-机制的使用\",\"45\":\"1#spi-机制的实现原理\",\"46\":\"2\",\"47\":\"2#collection\",\"48\":\"2#实现类比较\",\"49\":\"2#arraylist\",\"50\":\"2#构造方法\",\"51\":\"2#判断\",\"52\":\"2#新增\",\"53\":\"2#删除\",\"54\":\"2#扩展方法\",\"55\":\"2#linkedlist\",\"56\":\"2#构造方法-1\",\"57\":\"2#判断-1\",\"58\":\"2#新增-1\",\"59\":\"2#删除-1\",\"60\":\"2#扩展方法-1\",\"61\":\"2#vector\",\"62\":\"2#构造方法-2\",\"63\":\"2#判断-2\",\"64\":\"2#新增-2\",\"65\":\"2#删除-2\",\"66\":\"2#扩展方法-2\",\"67\":\"2#stack\",\"68\":\"2#hashset\",\"69\":\"2#treeset\",\"70\":\"2#copyonwritearraylist\",\"71\":\"2#copyonwritearrayset\",\"72\":\"2#concurrentskiplistset\",\"73\":\"2#map\",\"74\":\"2#hashmap\",\"75\":\"2#hashmap的扩缩容\",\"76\":\"2#treemap\",\"77\":\"2#weakhashmap\",\"78\":\"2#hashtable\",\"79\":\"2#concurrenthashmap\",\"80\":\"2#concurrentskiplistmap\",\"81\":\"2#queue\",\"82\":\"2#arrayblockingqueue\",\"83\":\"2#linkedblockingqueue\",\"84\":\"2#linkedblockingdeque\",\"85\":\"2#concurrentlinkedqueue\",\"86\":\"2#concurrentlinkeddeque\",\"87\":\"3\",\"88\":\"3#为什么需要多线程\",\"89\":\"3#为什么会出现并发问题\",\"90\":\"3#可见性-cpu缓存引起\",\"91\":\"3#原子性-分时复用引起\",\"92\":\"3#有序性-重排序引起\",\"93\":\"3#java是怎么解决并发问题的\",\"94\":\"3#volatile\",\"95\":\"3#synchronized\",\"96\":\"3#final\",\"97\":\"3#happens-before\",\"98\":\"3#原子性\",\"99\":\"3#可见性\",\"100\":\"3#有序性\",\"101\":\"3#线程安全分类\",\"102\":\"3#不可变\",\"103\":\"3#绝对线程安全\",\"104\":\"3#相对线程安全\",\"105\":\"3#线程兼容\",\"106\":\"3#线程对立\",\"107\":\"3#线程安全的实现\",\"108\":\"3#互斥同步\",\"109\":\"3#非阻塞同步\",\"110\":\"3#cas\",\"111\":\"3#atomicinteger\",\"112\":\"3#aba\",\"113\":\"3#无同步方案\",\"114\":\"3#栈封闭\",\"115\":\"3#线程本地存储-thread-local-storage\",\"116\":\"3#可重入代码-reentrant-code\",\"117\":\"3#线程状态\",\"118\":\"3#新建-new\",\"119\":\"3#可运行-runnable\",\"120\":\"3#阻塞-blocking\",\"121\":\"3#无限期等待-waiting\",\"122\":\"3#限期等待-timed-waiting\",\"123\":\"3#死亡-terminated\",\"124\":\"3#线程使用方式\",\"125\":\"3#实现接口-vs-继承-thread\",\"126\":\"3#基础线程机制\",\"127\":\"3#executor\",\"128\":\"3#daemon\",\"129\":\"3#sleep\",\"130\":\"3#yield\",\"131\":\"3#线程中断\",\"132\":\"3#interruptedexception\",\"133\":\"3#interrupted\",\"134\":\"3#executor-的中断操作\",\"135\":\"3#线程互斥同步\",\"136\":\"3#线程间的协作\",\"137\":\"3#join\",\"138\":\"3#wait-notify-notifyall\",\"139\":\"3#wait-和-sleep-的区别\",\"140\":\"3#await-signal-signalall\",\"141\":\"3#java-锁\",\"142\":\"3#乐观锁-vs-悲观锁\",\"143\":\"3#自旋锁-vs-适应性自旋锁\",\"144\":\"3#无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁\",\"145\":\"3#公平锁-vs-非公平锁\",\"146\":\"3#可重入锁-vs-非可重入锁\",\"147\":\"3#独享锁-排他锁-vs-共享锁\",\"148\":\"3#final-详解\",\"149\":\"3#final基础使用\",\"150\":\"3#修饰类\",\"151\":\"3#修饰方法\",\"152\":\"3#修饰参数\",\"153\":\"3#修饰变量\",\"154\":\"3#final域重排序规则\",\"155\":\"3#final域为基本类型\",\"156\":\"3#写final域重排序规则\",\"157\":\"3#读final域重排序规则\",\"158\":\"3#final域为引用类型\",\"159\":\"3#对final修饰的对象的成员域写操作\",\"160\":\"3#对final修饰的对象的成员域读操作\",\"161\":\"3#关于final重排序的总结\",\"162\":\"3#final的实现原理\",\"163\":\"3#volatile-详解\",\"164\":\"3#volatile的作用详解\",\"165\":\"3#防重排序\",\"166\":\"3#实现可见性\",\"167\":\"3#保证原子性-单次读-写\",\"168\":\"3#问题1-i-为什么不能保证原子性\",\"169\":\"3#问题2-共享的long和double变量的为什么要用volatile\",\"170\":\"3#volatile-的实现原理\",\"171\":\"3#volatile-可见性实现\",\"172\":\"3#volatile-有序性实现\",\"173\":\"3#happens-before-规则中有一条是-volatile-变量规则-对一个-volatile-域的写-happens-before-于任意后续对这个-volatile-域的读。\",\"174\":\"3#volatile-禁止重排序\",\"175\":\"3#synchronized-详解\",\"176\":\"3#juc\",\"177\":\"3#juc-原子类\",\"178\":\"3#juc-锁\",\"179\":\"3#juc-集合\",\"180\":\"3#juc-线程池\",\"181\":\"3#juc-工具类\",\"182\":\"3#threadlocal\",\"183\":\"3#transmittable-thread-local\",\"184\":\"4\",\"185\":\"6\",\"186\":\"6#jvm-的编译\",\"187\":\"6#类加载子系统\",\"188\":\"6#加载\",\"189\":\"6#类加载器有哪些\",\"190\":\"6#tomcat-为什么要自定义类加载器\",\"191\":\"6#webappclassloader-加载流程\",\"192\":\"6#链接-linking\",\"193\":\"6#验证-verify\",\"194\":\"6#准备-prepare\",\"195\":\"6#解析-resolve\",\"196\":\"6#初始化-initialization\",\"197\":\"6#运行时数据区\",\"198\":\"6#虚拟机栈\",\"199\":\"6#本地方法栈\",\"200\":\"6#程序计数器\",\"201\":\"6#方法区\",\"202\":\"6#堆\",\"203\":\"6#执行引擎\",\"204\":\"6#解释器\",\"205\":\"6#jit\",\"206\":\"6#垃圾回收器\",\"207\":\"6#如何判断一个对象是否还存活\",\"208\":\"6#垃圾收集算法\",\"209\":\"6#垃圾收集器\",\"210\":\"6#优化\",\"211\":\"6#获取-jvm-数据\",\"212\":\"6#jvm-数据分析\",\"213\":\"6#调优\",\"214\":\"6#优化工具\",\"215\":\"7\",\"216\":\"7#什么是代理\",\"217\":\"7#jdk-动态代理\",\"218\":\"7#实例\",\"219\":\"7#jdk动态代理步骤\",\"220\":\"7#cglib-代理\",\"221\":\"7#实例-1\",\"222\":\"7#对比\",\"223\":\"7#实现原理\",\"224\":\"7#面向\",\"225\":\"7#使用注意\",\"226\":\"7#各自局限\",\"227\":\"7#性能对比\",\"228\":\"8\",\"229\":\"8#_1-属性\",\"230\":\"8#_2-构造方法\",\"231\":\"8#public-string\",\"232\":\"8#public-string-string-original\",\"233\":\"8#public-string-char-value\",\"234\":\"8#public-string-byte-bytes\",\"235\":\"8#public-string-stringbuffer-buffer\",\"236\":\"8#public-string-stringbuilder-builder\",\"237\":\"8#_3-常用方法\",\"238\":\"8#字符串的长度-length\",\"239\":\"8#是否为空-isempty\",\"240\":\"8#获得字符串的第几个字符-charat-int-index\",\"241\":\"8#比较内容是否相等-equals-object-object\",\"242\":\"8#忽略大小写比较是否相等-equalsignorecase-string-anotherstring\",\"243\":\"8#比较字符串的大小-compareto-string-anotherstring\",\"244\":\"8#判断字符串是否从某个字符串开始的-startswith-string-prefix-int-toffset\",\"245\":\"8#_4-常见问题\",\"246\":\"9\",\"247\":\"9#_1-java-语言有哪些特点\",\"248\":\"9#_2-面向对象和面向过程的区别\",\"249\":\"9#_3-八种基本数据类型的大小、以及他们的封装类\",\"250\":\"9#_4-instanceof\",\"251\":\"9#_5-自动装箱和拆箱\",\"252\":\"9#_6-重载和重写\",\"253\":\"9#_7-和-equals\",\"254\":\"9#_8-hashcode-作用\",\"255\":\"9#_9-string、stringbuffer、stringbuilder-区别\",\"256\":\"9#_10-arraylist-和-linkedlist-的区别\",\"257\":\"9#_11-hashmap-和-hashtable-的区别\",\"258\":\"9#_12-collection-包和-collections-包的区别\",\"259\":\"9#_13-java-的四种引用\",\"260\":\"9#_14-泛型常用特点\",\"261\":\"9#_15-java-创建对象的方式\",\"262\":\"9#_16-有没有可能两个对象不等-但是-hashcode-相等\",\"263\":\"9#_17-深拷贝和浅拷贝\",\"264\":\"9#_18-final-有哪些用法\",\"265\":\"9#_19-static-的用法\",\"266\":\"9#_20-3-0-1-0-3-返回值是什么\",\"267\":\"9#_21-a-a-b-和-a-b-有什么区别\",\"268\":\"9#_22-try-catch-finally-try-里面有-return-finally-还会执行吗\",\"269\":\"9#_23-exception-和-error-包结构\",\"270\":\"9#_24-oom-你遇到过哪些情况-sof-你遇到过那些情况\",\"271\":\"9#_25-简述线程、程序、进程的基本概念。以及他们之间的关系\",\"272\":\"9#_26-某些字段不行序列化怎么办\",\"273\":\"9#_27-java-中的-io-流\",\"274\":\"9#_28-io-和-nio-的区别\",\"275\":\"9#_29-java-反射的作用与原理\",\"276\":\"9#_30-list、set、map-什么区别\",\"277\":\"9#_31-object-有哪些方法\",\"278\":\"9#_32-arraylist-和-linkedlist\",\"279\":\"9#_33-存在数组了为什么还要-arraylist\",\"280\":\"9#_34-什么是-fail-fast\",\"281\":\"9#_35-hashtable-和-hashmap\",\"282\":\"9#_36-hashmap-中的-key-可以使用任何类作为-key-吗\",\"283\":\"9#_37-hashmap-的长度为什么是-2-的-n-次方\",\"284\":\"9#_38-hashmap-和-concurrenthashmap-的异同\",\"285\":\"9#_39-红黑树\",\"286\":\"9#_40-怎么处理异常\",\"287\":\"10\",\"288\":\"15\",\"289\":\"15#环境准备\",\"290\":\"15#_1-关闭防火墙\",\"291\":\"15#_2-更新-yum\",\"292\":\"15#_3-安装工具\",\"293\":\"15#安装-docker\",\"294\":\"15#_1-设置开机启动\",\"295\":\"15#_2-使用阿里加速\",\"296\":\"15#安装-rancher\",\"297\":\"15#安装-kubernetes\",\"298\":\"15#_1-创建集群\",\"299\":\"15#_2-安装-master\",\"300\":\"15#_3-安装-node\",\"301\":\"15#_4-笔记本合盖\",\"302\":\"15#_5-主机名\",\"303\":\"15#rancher-cli-工具使用\",\"304\":\"15#通过-ui-添加-token\",\"305\":\"15#使用\",\"306\":\"15#安装-kubectl\",\"307\":\"15#安装-harbor\",\"308\":\"15#配置-harbor\",\"309\":\"15#启动-harbor\",\"310\":\"15#注意\",\"311\":\"15#安装-jenkins\",\"312\":\"15#提升权限\",\"313\":\"15#设置环境\",\"314\":\"15#配置-jenkins-插件工具\",\"315\":\"15#设置流水线\",\"316\":\"15#kubernetes-部署-nginx-测试\",\"317\":\"15#jenkins-打包-springboot-镜像测试\",\"318\":\"15#设置-jenkins-流水线\",\"319\":\"15#查看打包过程\",\"320\":\"15#查看-kubernetes-集群中是否部署成功\",\"321\":\"15#后记\",\"322\":\"15#_1-安装-cookiecutter\",\"323\":\"15#_2-编写配置文件\",\"324\":\"15#_3-创建模版文件\",\"325\":\"23\",\"326\":\"37\",\"327\":\"38\",\"328\":\"39\",\"329\":\"40\",\"330\":\"41\",\"331\":\"42\",\"332\":\"43\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1],\"2\":[1,23],\"3\":[1,26],\"4\":[1,8],\"5\":[1],\"6\":[1,47],\"7\":[1,19],\"8\":[1,12],\"9\":[1,29],\"10\":[1],\"11\":[1,67],\"12\":[1,41],\"13\":[1,3],\"14\":[1,83],\"15\":[1,21],\"16\":[1,19],\"17\":[1,13],\"18\":[1,4],\"19\":[2],\"20\":[1,5],\"21\":[2,31],\"22\":[1,3],\"23\":[1],\"24\":[1,44],\"25\":[1,13],\"26\":[1,28],\"27\":[1],\"28\":[1],\"29\":[1],\"30\":[2],\"31\":[1,3],\"32\":[2],\"33\":[1],\"34\":[1],\"35\":[1],\"36\":[1],\"37\":[1],\"38\":[1],\"39\":[1],\"40\":[1],\"41\":[1],\"42\":[2],\"43\":[2,39],\"44\":[2],\"45\":[2,6],\"46\":[1,8],\"47\":[1,62],\"48\":[1,24],\"49\":[1,12],\"50\":[1,25],\"51\":[1,4],\"52\":[1,62],\"53\":[1,11],\"54\":[1],\"55\":[1,6],\"56\":[1,5],\"57\":[1,3],\"58\":[1,14],\"59\":[1,4],\"60\":[1],\"61\":[1,8],\"62\":[1,6],\"63\":[1,4],\"64\":[1,3],\"65\":[1],\"66\":[1],\"67\":[1],\"68\":[1],\"69\":[1],\"70\":[1],\"71\":[1],\"72\":[1],\"73\":[1,82],\"74\":[1,74],\"75\":[1,37],\"76\":[1],\"77\":[1],\"78\":[1],\"79\":[1],\"80\":[1],\"81\":[1],\"82\":[1],\"83\":[1],\"84\":[1],\"85\":[1],\"86\":[1],\"87\":[2],\"88\":[1,26],\"89\":[1],\"90\":[2,21],\"91\":[2,24],\"92\":[2,50],\"93\":[1,14],\"94\":[1],\"95\":[1],\"96\":[1],\"97\":[2,43],\"98\":[1,7],\"99\":[1,16],\"100\":[1,13],\"101\":[1],\"102\":[1,7],\"103\":[1,3],\"104\":[1,5],\"105\":[1,16],\"106\":[1,9],\"107\":[1],\"108\":[1,12],\"109\":[1],\"110\":[1,34],\"111\":[1,15],\"112\":[1,24],\"113\":[1,5],\"114\":[1,5],\"115\":[5,29],\"116\":[1,13],\"117\":[1,2],\"118\":[3,2],\"119\":[3,9],\"120\":[3,3],\"121\":[3,20],\"122\":[4,37],\"123\":[3,3],\"124\":[1,15],\"125\":[4,12],\"126\":[1],\"127\":[1,15],\"128\":[1,11],\"129\":[2,13],\"130\":[2,8],\"131\":[1,3],\"132\":[1,15],\"133\":[2,21],\"134\":[2,11],\"135\":[1,10],\"136\":[1,4],\"137\":[2,7],\"138\":[4,27],\"139\":[4,11],\"140\":[4,21],\"141\":[2],\"142\":[3,22],\"143\":[3,34],\"144\":[5,8],\"145\":[3,19],\"146\":[3,8],\"147\":[4,13],\"148\":[2],\"149\":[1],\"150\":[1,9],\"151\":[1,16],\"152\":[1],\"153\":[1],\"154\":[1],\"155\":[1],\"156\":[1,8],\"157\":[1,13],\"158\":[1],\"159\":[1,9],\"160\":[1,12],\"161\":[1,13],\"162\":[1,17],\"163\":[2],\"164\":[1],\"165\":[1,13],\"166\":[1,6],\"167\":[3,3],\"168\":[3,14],\"169\":[3,8],\"170\":[2],\"171\":[2,22],\"172\":[2],\"173\":[10],\"174\":[2,44],\"175\":[2],\"176\":[1],\"177\":[2],\"178\":[2],\"179\":[2],\"180\":[2],\"181\":[2],\"182\":[1],\"183\":[3],\"184\":[2],\"185\":[1,31],\"186\":[2,10],\"187\":[1,16],\"188\":[1,2],\"189\":[1],\"190\":[2,44],\"191\":[2,200],\"192\":[2,4],\"193\":[3,26],\"194\":[3,5],\"195\":[3,4],\"196\":[2,8],\"197\":[1,54],\"198\":[1,10],\"199\":[1,15],\"200\":[1,16],\"201\":[1,23],\"202\":[1,38],\"203\":[1,2],\"204\":[1],\"205\":[1,6],\"206\":[1,1],\"207\":[1,23],\"208\":[1,63],\"209\":[1,104],\"210\":[1],\"211\":[3,8],\"212\":[2,11],\"213\":[1,2],\"214\":[1,24],\"215\":[4],\"216\":[1,9],\"217\":[2,20],\"218\":[1,52],\"219\":[1,18],\"220\":[2,9],\"221\":[1,56],\"222\":[1],\"223\":[1,7],\"224\":[1,5],\"225\":[2,6],\"226\":[2,8],\"227\":[1,14],\"228\":[1],\"229\":[2,37],\"230\":[2],\"231\":[3,35],\"232\":[4,47],\"233\":[5,44],\"234\":[5,65],\"235\":[5,49],\"236\":[5,65],\"237\":[2],\"238\":[3,32],\"239\":[3,25],\"240\":[5,65],\"241\":[5,68],\"242\":[5,89],\"243\":[5,135],\"244\":[7,79],\"245\":[2],\"246\":[2],\"247\":[3,13],\"248\":[2,21],\"249\":[3,45],\"250\":[2,17],\"251\":[2,11],\"252\":[2,10],\"253\":[4,5],\"254\":[3,7],\"255\":[5,14],\"256\":[5,12],\"257\":[5,21],\"258\":[5,4],\"259\":[3,21],\"260\":[2,1],\"261\":[3,7],\"262\":[6,27],\"263\":[2,6],\"264\":[3,74],\"265\":[3,6],\"266\":[7,2],\"267\":[5,13],\"268\":[8,8],\"269\":[5,7],\"270\":[5,2],\"271\":[5,29],\"272\":[3,8],\"273\":[5,9],\"274\":[5,11],\"275\":[3,59],\"276\":[5,10],\"277\":[3,21],\"278\":[4],\"279\":[3,1],\"280\":[4,10],\"281\":[4],\"282\":[7,11],\"283\":[7],\"284\":[6],\"285\":[2],\"286\":[2],\"287\":[1],\"288\":[1,17],\"289\":[1],\"290\":[2,8],\"291\":[3,3],\"292\":[2,10],\"293\":[2,23],\"294\":[2,4],\"295\":[2,25],\"296\":[2,20],\"297\":[2],\"298\":[2,5],\"299\":[3,6],\"300\":[3,3],\"301\":[2,2],\"302\":[2,8],\"303\":[3,19],\"304\":[4],\"305\":[1,17],\"306\":[2,34],\"307\":[2,20],\"308\":[2,115],\"309\":[2,5],\"310\":[1,62],\"311\":[2,28],\"312\":[1,16],\"313\":[1,44],\"314\":[3,6],\"315\":[1,25],\"316\":[4,58],\"317\":[4],\"318\":[3,146],\"319\":[1,6],\"320\":[3,1],\"321\":[1,5],\"322\":[3,4],\"323\":[2,28],\"324\":[2,55],\"325\":[2],\"326\":[1,3],\"327\":[1],\"328\":[1],\"329\":[1],\"330\":[1],\"331\":[1],\"332\":[1]},\"averageFieldLength\":[1.9909909909909906,21.875488392710835],\"storedFields\":{\"0\":{\"h\":\"\"},\"1\":{\"h\":\"面向对象\"},\"2\":{\"h\":\"封装\",\"t\":[\"利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。 优点：\",\"减少耦合 : 可以独立地开发、测试、优化、使用、理解和修改\",\"减轻维护的负担 : 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块\",\"有效地调节性能 : 可以通过剖析确定哪些模块影响了系统的性能\",\"提高软件的可重用性\",\"降低了构建大型系统的风险 : 即使整个系统不可用，但是这些独立的模块却有可能是可用的\"]},\"3\":{\"h\":\"继承\",\"t\":[\"继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。继承应该遵循里氏替换原则[1]。，子类对象必须能够替换掉所有父类对象。 Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。\"]},\"4\":{\"h\":\"\",\"t\":[\"多态分为编译时多态和运行时多态:\",\"编译时多态主要指方法的重载\",\"运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定\",\"运行时多态有三个条件:\",\"继承\",\"覆盖(重写)\",\"向上转型\"]},\"5\":{\"h\":\"重写和重载\"},\"6\":{\"h\":\"重写\",\"t\":[\"重写（Override）是指子类定义了一个与其父类中具有相同名称、参数列表和返回类型的方法，并且子类方法的实现覆盖了父类方法的实现。 即外壳不变，核心重写！ 重写规则：\",\"参数列表与被重写方法的参数列表必须完全相同。\",\"返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。\",\"访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。\",\"父类的成员方法只能被它的子类重写。\",\"声明为 final 的方法不能被重写。\",\"声明为 static 的方法不能被重写，但是能够被再次声明。\",\"子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。\",\"子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。\",\"重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。\",\"构造方法不能被重写。\",\"如果不能继承一个类，则不能重写该类的方法。\"]},\"7\":{\"h\":\"重载\",\"t\":[\"重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 重载规则：\",\"被重载的方法必须改变参数列表(参数个数或类型不一样)；\",\"被重载的方法可以改变返回类型；\",\"被重载的方法可以改变访问修饰符；\",\"被重载的方法可以声明新的或更广的检查异常；\",\"方法能够在同一个类中或者在一个子类中被重载。\",\"无法以返回值类型作为重载函数的区分标准。\"]},\"8\":{\"h\":\"泛型机制\",\"t\":[\"什么是泛型\",\"泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\"]},\"9\":{\"h\":\"为什么引入泛型\",\"t\":[\"泛型的引入主要是为了提高代码的复用性和可读性，通过泛型可以将类型参数化，使得代码更加灵活、更加易于理解和维护。\",\"private static int add(int a, int b) { System.out.println(a + \\\"+\\\" + b + \\\"=\\\" + (a + b)); return a + b; } private static float add(float a, float b) { System.out.println(a + \\\"+\\\" + b + \\\"=\\\" + (a + b)); return a + b; } private static double add(double a, double b) { System.out.println(a + \\\"+\\\" + b + \\\"=\\\" + (a + b)); return a + b; } \",\"如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：\",\"private static <T extends Number> double add(T a, T b) { System.out.println(a + \\\"+\\\" + b + \\\"=\\\" + (a.doubleValue() + b.doubleValue())); return a.doubleValue() + b.doubleValue(); } \"]},\"10\":{\"h\":\"泛型的基本使用\"},\"11\":{\"h\":\"泛型类\",\"t\":[\"单元泛型\",\"class Point<T>{ // 此处可以随便写标识符号，T是type的简称 private T var ; // var的类型由T指定，即：由外部指定 public T getVar(){ // 返回值的类型由外部决定 return var ; } public void setVar(T var){ // 设置的类型也由外部决定 this.var = var ; } } public class GenericsDemo06{ public static void main(String args[]){ Point<String> p = new Point<String>() ; // 里面的var类型为String类型 p.setVar(\\\"it\\\") ; // 设置字符串 System.out.println(p.getVar().length()) ; // 取得字符串的长度 } } \",\"多参数泛型\",\"class Notepad<K,V>{ // 此处指定了两个泛型类型 private K key ; // 此变量的类型由外部决定 private V value ; // 此变量的类型由外部决定 public K getKey(){ return this.key ; } public V getValue(){ return this.value ; } public void setKey(K key){ this.key = key ; } public void setValue(V value){ this.value = value ; } } public class GenericsDemo09{ public static void main(String args[]){ Notepad<String,Integer> t = null ; // 定义两个泛型类型的对象 t = new Notepad<String,Integer>() ; // 里面的key为String，value为Integer t.setKey(\\\"汤姆\\\") ; // 设置第一个内容 t.setValue(20) ; // 设置第二个内容 System.out.print(\\\"姓名；\\\" + t.getKey()) ; // 取得信息 System.out.print(\\\"，年龄；\\\" + t.getValue()) ; // 取得信息 } } \"]},\"12\":{\"h\":\"泛型接口\",\"t\":[\"interface Info<T>{ // 在接口上定义泛型 public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型 } class InfoImpl<T> implements Info<T>{ // 定义泛型接口的子类 private T var ; // 定义属性 public InfoImpl(T var){ // 通过构造方法设置属性内容 this.setVar(var) ; } public void setVar(T var){ this.var = var ; } public T getVar(){ return this.var ; } } public class GenericsDemo24{ public static void main(String arsg[]){ Info<String> i = null; // 声明接口对象 i = new InfoImpl<String>(\\\"汤姆\\\") ; // 通过子类实例化对象 System.out.println(\\\"内容：\\\" + i.getVar()) ; } } \"]},\"13\":{\"h\":\"泛型方法\",\"t\":[\"泛型方法定义\",\"泛型方法定义\",\"方法调用\",\"泛型方法调用\"]},\"14\":{\"h\":\"泛型的上下限\",\"t\":[\"上限：\",\"class Info<T extends Number>{ // 此处泛型只能是数字类型 private T var ; // 定义泛型变量 public void setVar(T var){ this.var = var ; } public T getVar(){ return this.var ; } public String toString(){ // 直接打印 return this.var.toString() ; } } public class demo1{ public static void main(String args[]){ Info<Integer> i1 = new Info<Integer>() ; // 声明Integer的泛型对象 } } \",\"下限:\",\"class Info<T>{ private T var ; // 定义泛型变量 public void setVar(T var){ this.var = var ; } public T getVar(){ return this.var ; } public String toString(){ // 直接打印 return this.var.toString() ; } } public class GenericsDemo21{ public static void main(String args[]){ Info<String> i1 = new Info<String>() ; // 声明String的泛型对象 Info<Object> i2 = new Info<Object>() ; // 声明Object的泛型对象 i1.setVar(\\\"hello\\\") ; i2.setVar(new Object()) ; fun(i1) ; fun(i2) ; } public static void fun(Info<? super String> temp){ // 只能接收String或Object类型的泛型，String类的父类只有Object类 System.out.print(temp + \\\", \\\") ; } } \",\"<?> 无限制通配符 <? extends E> extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类 <? super E> super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类 // 使用原则《Effictive Java》 // 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限 1. 如果参数化类型表示一个 T 的生产者，使用 < ? extends T>; 2. 如果它表示一个 T 的消费者，就使用 < ? super T>； 3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。 \"]},\"15\":{\"h\":\"泛型数组\",\"t\":[\"List<String>[] list11 = new ArrayList<String>[10]; //编译错误，非法创建 List<String>[] list12 = new ArrayList<?>[10]; //编译错误，需要强转类型 List<String>[] list13 = (List<String>[]) new ArrayList<?>[10]; //OK，但是会有警告 List<?>[] list14 = new ArrayList<String>[10]; //编译错误，非法创建 List<?>[] list15 = new ArrayList<?>[10]; //OK List<String>[] list6 = new ArrayList[10]; //OK，但是会有警告 \"]},\"16\":{\"h\":\"深入理解泛型\",\"t\":[\"什么是泛型擦除\",\"Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。\"]},\"17\":{\"h\":\"泛型的擦除原则\",\"t\":[\"消除类型参数声明，即删除<>及其包围的部分。\",\"根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。\",\"为了保证类型安全，必要时插入强制类型转换代码。\",\"自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。\"]},\"18\":{\"h\":\"如何进行擦除\",\"t\":[\"擦除类定义中的类型参数 - 无限制类型擦除\",\"无限制类型擦除\",\"擦除类定义中的类型参数 - 有限制类型擦除\",\"有限制类型擦除\",\"擦除方法定义中的类型参数\",\"擦除方法定义中的类型参数\"]},\"19\":{\"h\":\"如何理解泛型的多态--泛型的桥接方法\"},\"20\":{\"h\":\"如何理解基本类型不能作为泛型类型\",\"t\":[\"因为当类型擦除后，原始类型变为Object，但是Object类型不能存储int值，只能引用Integer的值。\"]},\"21\":{\"h\":\"如何理解泛型类型不能实例化？\",\"t\":[\"因为在 Java 编译期没法确定泛型参数化类型，也就找不到对应的类字节码文件，所以自然就不行了，此外由于T 被擦除为 Object，如果可以 new T() 则就变成了 new Object()，失去了本意。 如果我们确实需要实例化一个泛型，应该如何做呢？可以通过反射实现：\",\"static <T> T newTclass (Class < T > clazz) throws InstantiationException, IllegalAccessException { T obj = clazz.newInstance(); return obj; } \"]},\"22\":{\"h\":\"如何获取泛型的参数类型\",\"t\":[\"可以通过反射进行获取参数的实际类型，编译阶段无法判定类型。\"]},\"23\":{\"h\":\"注解机制\"},\"24\":{\"h\":\"注解基础\",\"t\":[\"注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。 它主要的作用有以下四方面：\",\"生成文档，通过代码里标识的元数据生成javadoc文档。\",\"编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。\",\"编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。\",\"运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。\",\"注解的常见分类：\",\"Java自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。\",\"元注解，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。\",\"自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。\"]},\"25\":{\"h\":\"Java自带的标准注解\",\"t\":[\"Java 1.5开始自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings：\",\"@Override：表示当前的方法定义将覆盖父类中的方法\",\"@Deprecated：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告\",\"@SuppressWarnings：表示关闭编译器警告信息\"]},\"26\":{\"h\":\"元注解\",\"t\":[\"在JDK 1.5中提供了4个标准的元注解：\",\"@Target：描述注解的使用范围（即：被修饰的注解可以用在什么地方）。\",\"@Retention：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时）。\",\"@Documented：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。\",\"@Inherited：描述注解是否可以被子类继承。\",\"在JDK 1.8中提供了两个元注解：\",\"@@Repeatable：加上@Repeatable, 指向存储注解Authorities，在使用时候，直接可以重复使用Authority注解。\",\"@Native：使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。\"]},\"27\":{\"h\":\"自定义注解\"},\"28\":{\"h\":\"深入理解注解\"},\"29\":{\"h\":\"Java8提供了哪些新的注解\"},\"30\":{\"h\":\"注解支持继承吗？\"},\"31\":{\"h\":\"注解实现的原理\",\"t\":[\"java注解的本质以及注解的底层实现原理\",\"annotation-processing\"]},\"32\":{\"h\":\"自定义注解和AOP - 通过切面实现解耦\"},\"33\":{\"h\":\"异常机制\"},\"34\":{\"h\":\"异常的层次结构\"},\"35\":{\"h\":\"异常基础\"},\"36\":{\"h\":\"异常实践\"},\"37\":{\"h\":\"深入理解异常\"},\"38\":{\"h\":\"反射机制\"},\"39\":{\"h\":\"反射基础\"},\"40\":{\"h\":\"反射使用\"},\"41\":{\"h\":\"反射机制执行的流程\"},\"42\":{\"h\":\"SPI 机制\"},\"43\":{\"h\":\"SPI 机制介绍\",\"t\":[\"什么是SPI\",\"SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql. Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是解耦。\",\"SPI整体机制图如下：\",\"SPI整体机制图\",\"当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util. ServiceLoader。\"]},\"44\":{\"h\":\"SPI 机制的使用\"},\"45\":{\"h\":\"SPI 机制的实现原理\",\"t\":[\"子类型（subtype）必须能够替换掉他们的基类型（base type）。 ↩︎\"]},\"46\":{\"h\":\"Java集合框架\",\"t\":[\"Java 集合框架是每一个入门开发者必会的内容，而且在较长的时间内容，不管是使用还是面试频度否非常的高，所以本人认为完全的、深入的学习是十分有必要的。本人结合源码和网络上的相关文章进行了总结。\"]},\"47\":{\"h\":\"Collection\",\"t\":[\"Collection 是 List 和 Set的父类，它抽象了单列数据集合的基本方法。它包含了以下的方法：\",\"int size():获取单列数据集合中存储数据的数量\",\"isEmpty():当前单列数据集合是否为空\",\"contains(Object o): 当前单列数据合计是否存在该数据对象，当前对象需要实现 equals 和 hashCode 方法，防止不同的对象校验的 hashCode 一致\",\"toArray(): 单列数据集合转数组\",\"toArray(T[]) :单列数据结合转数组，数组类型为参数类型\",\"add(E e): 单列数据集合添加数据\",\"remove(E e): 删除单列数据集合中的该数据\",\"containsAll(Collection<?> c): 校验当前数据集合是否在该单列数据中，若都存在则返回 true\",\"addAll(Collection<?> c): 向当前单列数据集合中添加该数据结合\",\"removeAll(Collection<?> c): 当前单列数据集合中移出指定的数据集合\",\"removeIf(Predicate<? super E> filter): 移出通过 filter 筛选的数据集合\",\"retainAll(Collection<?> c): 从该集合中删除未包含在指定集合中的所有元素\",\"clear(): 从此集合中移除所有元素(可选操作)。该方法返回后，集合将为空。\",\"equals(Object o):\",\"hashCode():\",\"spliterator():\",\"stream():\",\"parallelStream():\"]},\"48\":{\"h\":\"实现类比较\",\"t\":[\"实现类名称\",\"实现原理\",\"优点\",\"缺点\",\"ArrayList\",\"数组\",\"索引查询快\",\"变更效率低\",\"LinkedList\",\"链表\",\"变更效率高\",\"索引查询慢\",\"Vector\",\"ArrayList 一致\",\"加锁，防止并发问题\",\"由于加锁问题，导致操作效率较低\",\"Stack\",\"继承了 Vector\",\"相比于 Vector 功能更加强大，封装了部分方法\",\"和 Vector 一致\"]},\"49\":{\"h\":\"ArrayList\",\"t\":[\"ArrayList 是 Collection 实现子类，它实现了 Collection 的所有功能且添加了部分自己独有的一些功能，让其使用更加方便和简单。内部的实现原理是通过数组进行缓存元素数据，通过 size 属性缓存数据的长度。\"]},\"50\":{\"h\":\"构造方法\",\"t\":[\"ArrayList 有三个构造方法，无参、初始容量、初始元素。\",\"无参：会给属性 this.elementData赋值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA 。\",\"初始容量：若设置容量大于 0，会给属性 this.elementData赋值为new Object[initialCapacity]；若设置容量等于 0 ，会给属性 this.elementData赋值为EMPTY_ELEMENTDATA；若设置容量小于 0，则抛出异常。\",\"初始元素：若初始元素数量等于 0， 则会给属性 this.elementData赋值为EMPTY_ELEMENTDATA；若初始元素数量大于 0，则会把元素赋值给this.elementData。\"]},\"51\":{\"h\":\"判断\",\"t\":[\"判断集合中是否存在该元素是通过遍历集合的属性elementData的数据，通过equals判断数据是否相等，所以需要该数据对象实现对应的方法。\"]},\"52\":{\"h\":\"新增\",\"t\":[\"添加元素时先让modCount 加一（后续移出时会使用）。如果当前插入的位置等于元素数量即当前集合数据已满，则需要进行扩容，扩容代码如下:\",\" private int newCapacity(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); if (newCapacity - minCapacity <= 0) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity < 0) // overflow throw new OutOfMemoryError(); return minCapacity; } return (newCapacity - MAX_ARRAY_SIZE <= 0) ? newCapacity : hugeCapacity(minCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity < 0) // overflow throw new OutOfMemoryError(); return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } \",\"minCapacity: 是当前容量+1\",\"newCapacity: 是 oldCapacity + （0.5*oldCapacity）\",\"第一次扩容时，若是无参的构造方法，则会进行默认为容量是 10；含有参数的构造方法，第一次则按照 1.5 倍扩容（初始化容量为 0 时，则第一次扩容容量会变更为 1）\",\"后续扩容，则需要判断扩容 1.5 倍之后是否超出 int 的最大值，若是会超过则取 Integer.MAX_VALUE\"]},\"53\":{\"h\":\"删除\",\"t\":[\"单个删除时:查询元素在集合的下标索引，然后通过System.arraycopy进行数组的 copy 和创建以此实现数据的删除\",\"批量删除时: 会缓存modCount 在删除的过程中会校验缓存的modCount是否和当前的一致，若是不一致则会抛出ConcurrentModificationException异常，提示在并发修改\"]},\"54\":{\"h\":\"扩展方法\"},\"55\":{\"h\":\"LinkedList\",\"t\":[\"LinkedList 也是实现Collection 的子类，它内部的数据接口是采用链表的方式进行存储，数据长度也是通过属性进行获取的。\"]},\"56\":{\"h\":\"构造方法\",\"t\":[\"该类的构造方法并未进行特殊的处理，无参的构造方法什么都为进行初始化，通过集合进行初始化的，则直接调用的addAll。\"]},\"57\":{\"h\":\"判断\",\"t\":[\"这里判断对象是否存在也是进行数据遍历，进行比较数据对象是否存在。\"]},\"58\":{\"h\":\"新增\",\"t\":[\"刚创建时，属性first 和 last 都是空的，第一次添加是会给 first 和 last 赋值，后续创建则直接在先缓存 last 然后 last等于新元素，缓存的last关联新元素，从而先新元素的添加。\"]},\"59\":{\"h\":\"删除\",\"t\":[\"删除则是查询到对应的节点后，直接让前一个节点关联后一节点，从而实现该节点的删除。\"]},\"60\":{\"h\":\"扩展方法\"},\"61\":{\"h\":\"Vector\",\"t\":[\"Vector 类似于 ArrayList 都是基于数组的存储结构，只不过加入了自己特性的一些东西，例如扩容规则、线程安全。\"]},\"62\":{\"h\":\"构造方法\",\"t\":[\"构造方法可以传入初始容量和扩容自增的数量。默认的初始容量是 10，自增的属性值设置为 0。\"]},\"63\":{\"h\":\"判断\",\"t\":[\"基本和ArrayList 一致，只不过在判断时加锁进而防止并发问题。\"]},\"64\":{\"h\":\"新增\",\"t\":[\"新增操作和ArrayList一致，只不过在操作的时候添加了锁，进行防止并发操作\"]},\"65\":{\"h\":\"删除\"},\"66\":{\"h\":\"扩展方法\"},\"67\":{\"h\":\"Stack\"},\"68\":{\"h\":\"HashSet\"},\"69\":{\"h\":\"TreeSet\"},\"70\":{\"h\":\"CopyOnWriteArrayList\"},\"71\":{\"h\":\"CopyOnWriteArraySet\"},\"72\":{\"h\":\"ConcurrentSkipListSet\"},\"73\":{\"h\":\"Map\",\"t\":[\"Map 抽象了键值对数据集合的通用方法，它包含以下方法：\",\"int size()：查看元素数目\",\"isEmpty()：元素个数是否是0\",\"containsKey(Object key)：是否存在这个 key\",\"containsValue(Object value)： 是否存在个 value\",\"get(Object key)： 通过 key 获取对象的 value\",\"put(K key, V value)： 添加 key-value 元素\",\"remove(Object key)： 移出 key 对应的 value\",\"putAll(Map<? extends K, ? extends V> m)：添加集合中的所有元素\",\"clear()： 清空元素\",\"keySet()： 获取元素的 key 的不重复集合\",\"values()：获得元素中的所有 value\",\"entrySet()：获取所有的 key-value 对象\",\"getOrDefault(Object key, V defaultValue)：获取 key 对应的 value，若不存在在返回 defaultValue\",\"putIfAbsent(K key, V value): 若是不存在 key 对应的 value 则进行添加\",\"remove(Object key, Object value)：删除 key 对应的值且等于 value 的\",\"replace(K key, V oldValue, V newValue)： 若存在 key 的值为 oldValue 的元素，则重新赋值 key 的值为 newValue\",\"replace(K key, V value)：若存在 key 就添加 key 对应的值为 value\",\"computeIfAbsent(K key,Function<? super K, ? extends V> mappingFunction)：若不存在 key 对应的值，则通过 mappingFunction 获取，且添加到集合中\",\"computeIfPresent(K key,BiFunction<? super K, ? super V, ? extends V> remappingFunction)：若是存在key 对应的 value 则传入 key，value 到 mappingFUnction 获取新的 newValue，若 newValue 为空则会清除 key，若不为空，则修改集合中key 对应的值，且返回newValue\"]},\"74\":{\"h\":\"HashMap\",\"t\":[\"HashMap 通过设置一些属性，进行控制某些行为，例如：初始容量、扩容时下次数量、多少元素转化为树，以下是 HashMap 的属性：\",\"DEFAULT_INITIAL_CAPACITY = 1 << 4; 初始容量为 16\",\"MAXIMUM_CAPACITY = 1 << 30; int 的最大值为 2 的 31-1，但是只能移动1 所以最大值为 2 的 30 次方\",\"DEFAULT_LOAD_FACTOR = 0.75f; 默认的负载因子 0.75\",\"TREEIFY_THRESHOLD = 8; 链表树化的最小元素数量，即链表元素个数大于 8 时，链表进行树化\",\"UNTREEIFY_THRESHOLD = 6; 树退化成链表的最大元素数量，当树的元素数量小于 6 的时候，树退化为链表\",\"MIN_TREEIFY_CAPACITY = 64; 集合树化的最小元素个数，当集合元素数目大于 64 的时候才可能树化,优先级大于 TREEIFY_THRESHOLD ，可以存在链表长度大于 8 ，只有当容量大于 64 才会树化\",\"Node<K,V>[] table; 集合元素数据\",\"Set<Map.Entry<K,V>> entrySet; 缓存的数据\",\"int size; 元素数目\",\"int modCount; 防止迭代器遍历的时候修改\",\"int threshold; 下一次扩容的容量\",\"float loadFactor; 负载因子\"]},\"75\":{\"h\":\"HashMap的扩缩容\",\"t\":[\"当进行新增时，会先去取 key 的哈希值，(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)，进行 put 时，会先进行判断 table 是否存在数据，如果没有则调用 resize() 进行初始化或扩容，若 该元素在 table 中不存在哈希冲突则放置到对应的下标上，若存在哈希冲突则需要判断 table 该下标的数据是否是树，若是树则进行添加子节点，若不是树，则链接在链表后，判断若当前链表的数量大于默认树化的数目，则执行 treeifyBin(tab, hash),进行树化处理\",\"为什么要这么计算哈希值\"]},\"76\":{\"h\":\"TreeMap\"},\"77\":{\"h\":\"WeakHashMap\"},\"78\":{\"h\":\"Hashtable\"},\"79\":{\"h\":\"ConcurrentHashMap\"},\"80\":{\"h\":\"ConcurrentSkipListMap\"},\"81\":{\"h\":\"Queue\"},\"82\":{\"h\":\"ArrayBlockingQueue\"},\"83\":{\"h\":\"LinkedBlockingQueue\"},\"84\":{\"h\":\"LinkedBlockingDeque\"},\"85\":{\"h\":\"ConcurrentLinkedQueue\"},\"86\":{\"h\":\"ConcurrentLinkedDeque\"},\"87\":{\"h\":\"Java 多线程和并发\"},\"88\":{\"h\":\"为什么需要多线程\",\"t\":[\"CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:\",\"CPU 增加了缓存，以均衡与内存的速度差异；// 导致 可见性问题\",\"操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 原子性问题\",\"编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 有序性问题\"]},\"89\":{\"h\":\"为什么会出现并发问题\"},\"90\":{\"h\":\"可见性: CPU缓存引起\",\"t\":[\"假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。\",\"此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.\",\"这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。\"]},\"91\":{\"h\":\"原子性: 分时复用引起\",\"t\":[\"i += 1需要三条 CPU 指令\",\"将变量 i 从内存读取到 CPU寄存器；\",\"在CPU寄存器中执行 i + 1 操作；\",\"将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。\",\"由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3。\"]},\"92\":{\"h\":\"有序性: 重排序引起\",\"t\":[\"在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：\",\"编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\",\"指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\",\"内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\",\"从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：\",\"image.png\",\"上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。\"]},\"93\":{\"h\":\"JAVA是怎么解决并发问题的\",\"t\":[\"Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：\",\"volatile、synchronized 和 final 三个关键字\",\"Happens-Before 规则\"]},\"94\":{\"h\":\"volatile\"},\"95\":{\"h\":\"synchronized\"},\"96\":{\"h\":\"final\"},\"97\":{\"h\":\"Happens-Before\",\"t\":[\"单一线程原则: 在一个线程内，在程序前面的操作先行发生于后面的操作\",\"管程锁定规则: 一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。\",\"volatile 变量规则: 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。\",\"线程启动规则: Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。\",\"线程加入规则: Thread 对象的结束先行发生于 join() 方法返回。\",\"线程中断规则: 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。\",\"对象终结规则: 一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。\",\"传递性: 如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。\"]},\"98\":{\"h\":\"原子性\",\"t\":[\"Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。\"]},\"99\":{\"h\":\"可见性\",\"t\":[\"Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\"]},\"100\":{\"h\":\"有序性\",\"t\":[\"在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。\"]},\"101\":{\"h\":\"线程安全分类\"},\"102\":{\"h\":\"不可变\",\"t\":[\"不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。\"]},\"103\":{\"h\":\"绝对线程安全\",\"t\":[\"不管运行时环境如何，调用者都不需要任何额外的同步措施。\"]},\"104\":{\"h\":\"相对线程安全\",\"t\":[\"相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。\"]},\"105\":{\"h\":\"线程兼容\",\"t\":[\"线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。\"]},\"106\":{\"h\":\"线程对立\",\"t\":[\"线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。\"]},\"107\":{\"h\":\"线程安全的实现\"},\"108\":{\"h\":\"互斥同步\",\"t\":[\"互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。\"]},\"109\":{\"h\":\"非阻塞同步\"},\"110\":{\"h\":\"\",\"t\":[\"随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。 乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。\"]},\"111\":{\"h\":\"\",\"t\":[\"J. U. C 包里面的整数原子类 AtomicInteger，其中的 compareAndSet() 和 getAndIncrement() 等方法都使用了 Unsafe 类的 CAS 操作。\"]},\"112\":{\"h\":\"\",\"t\":[\"如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。 J. U. C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。\"]},\"113\":{\"h\":\"无同步方案\",\"t\":[\"要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。\"]},\"114\":{\"h\":\"\",\"t\":[\"多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。\"]},\"115\":{\"h\":\"线程本地存储(Thread Local Storage)\",\"t\":[\"如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。 符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。 可以使用 java.lang. ThreadLocal 类来实现线程本地存储功能。\"]},\"116\":{\"h\":\"\",\"t\":[\"这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。\"]},\"117\":{\"h\":\"线程状态\",\"t\":[\"image.png\"]},\"118\":{\"h\":\"新建(New)\",\"t\":[\"创建后尚未启动。\"]},\"119\":{\"h\":\"可运行(Runnable)\",\"t\":[\"可能正在运行，也可能正在等待 CPU 时间片。 包含了操作系统线程状态中的 Running 和 Ready。\"]},\"120\":{\"h\":\"阻塞(Blocking)\",\"t\":[\"等待获取一个排它锁，如果其线程释放了锁就会结束此状态。\"]},\"121\":{\"h\":\"无限期等待(Waiting)\",\"t\":[\"等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。\",\"进入方法\",\"退出方法\",\"没有设置 Timeout 参数的 Object.wait() 方法\",\"Object.notify() / Object.notifyAll()\",\"没有设置 Timeout 参数的 Thread.join() 方法\",\"被调用的线程执行完毕\",\"LockSupport.park() 方法\",\"-\"]},\"122\":{\"h\":\"限期等待(Timed Waiting)\",\"t\":[\"无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。 调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。 调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。 睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。 阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。\",\"进入方法\",\"退出方法\",\"Thread.sleep() 方法\",\"时间结束\",\"设置了 Timeout 参数的 Object.wait() 方法\",\"时间结束 / Object.notify() / Object.notifyAll()\",\"设置了 Timeout 参数的 Thread.join() 方法\",\"时间结束 / 被调用的线程执行完毕\",\"LockSupport.parkNanos() 方法\",\"-\",\"LockSupport.parkUntil() 方法\",\"-\"]},\"123\":{\"h\":\"死亡(Terminated)\",\"t\":[\"可以是线程结束任务之后自己结束，或者产生了异常而结束。\"]},\"124\":{\"h\":\"线程使用方式\",\"t\":[\"有三种使用线程的方法:\",\"实现 Runnable 接口；\",\"实现 Callable 接口；\",\"继承 Thread 类。\",\"实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。\"]},\"125\":{\"h\":\"实现接口 VS 继承 Thread\",\"t\":[\"实现接口会更好一些，因为:\",\"Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；\",\"类可能只要求可执行就行，继承整个 Thread 类开销过大。\"]},\"126\":{\"h\":\"基础线程机制\"},\"127\":{\"h\":\"Executor\",\"t\":[\"Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。 主要有三种 Executor:\",\"CachedThreadPool: 一个任务创建一个线程；\",\"FixedThreadPool: 所有任务只能使用固定大小的线程；\",\"SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。\"]},\"128\":{\"h\":\"Daemon\",\"t\":[\"守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。 当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。 main() 属于非守护线程。 使用 setDaemon() 方法将一个线程设置为守护线程。\"]},\"129\":{\"h\":\"sleep()\",\"t\":[\"Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。 sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。\"]},\"130\":{\"h\":\"yield()\",\"t\":[\"对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。\"]},\"131\":{\"h\":\"线程中断\",\"t\":[\"一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。\"]},\"132\":{\"h\":\"InterruptedException\",\"t\":[\"通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。\"]},\"133\":{\"h\":\"interrupted()\",\"t\":[\"如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。 但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。\"]},\"134\":{\"h\":\"Executor 的中断操作\",\"t\":[\"调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。\"]},\"135\":{\"h\":\"线程互斥同步\",\"t\":[\"Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。\"]},\"136\":{\"h\":\"线程间的协作\",\"t\":[\"当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。\"]},\"137\":{\"h\":\"join()\",\"t\":[\"在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。\"]},\"138\":{\"h\":\"wait() notify() notifyAll()\",\"t\":[\"调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。 它们都属于 Object 的一部分，而不属于 Thread。 只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。 使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。\"]},\"139\":{\"h\":\"wait() 和 sleep() 的区别\",\"t\":[\"wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；\",\"wait() 会释放锁，sleep() 不会。\"]},\"140\":{\"h\":\"await() signal() signalAll()\",\"t\":[\"java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。\"]},\"141\":{\"h\":\"Java 锁\"},\"142\":{\"h\":\"乐观锁 VS 悲观锁\",\"t\":[\"悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。\",\"乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。\",\"根据从上面的概念描述我们可以发现：\",\"悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。\",\"乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。\"]},\"143\":{\"h\":\"自旋锁 VS 适应性自旋锁\",\"t\":[\"自旋锁：在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。\",\"自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX: PreBlockSpin来更改）没有成功获得锁，就应当挂起线程\"]},\"144\":{\"h\":\"无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁\",\"t\":[\"偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。\",\"image.png\"]},\"145\":{\"h\":\"公平锁 VS 非公平锁\",\"t\":[\"公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。\",\"非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。\"]},\"146\":{\"h\":\"可重入锁 VS 非可重入锁\",\"t\":[\"可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。\"]},\"147\":{\"h\":\"独享锁(排他锁) VS 共享锁\",\"t\":[\"独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。\",\"共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。\"]},\"148\":{\"h\":\"final 详解\"},\"149\":{\"h\":\"final基础使用\"},\"150\":{\"h\":\"修饰类\",\"t\":[\"当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。 注意：final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的。\"]},\"151\":{\"h\":\"修饰方法\",\"t\":[\"private 方法是隐式的final：Base和Son都有方法test(), 但是这并不是一种覆盖，因为private所修饰的方法是隐式的final，也就是无法被继承，所以更不用说是覆盖了，在Son中的test()方法不过是属于Son的新成员罢了，Son进行向上转型得到father，但是father.test()是不可执行的，因为Base中的test方法是private的，无法被访问到。\",\"final方法是可以被重载的\"]},\"152\":{\"h\":\"修饰参数\"},\"153\":{\"h\":\"修饰变量\"},\"154\":{\"h\":\"final域重排序规则\"},\"155\":{\"h\":\"final域为基本类型\"},\"156\":{\"h\":\"写final域重排序规则\",\"t\":[\"写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：\",\"JMM禁止编译器把final域的写重排序到构造函数之外；\",\"编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。\"]},\"157\":{\"h\":\"读final域重排序规则\",\"t\":[\"在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读final域操作的前面插入一个LoadLoad屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。\"]},\"158\":{\"h\":\"final域为引用类型\"},\"159\":{\"h\":\"对final修饰的对象的成员域写操作\",\"t\":[\"针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。\"]},\"160\":{\"h\":\"对final修饰的对象的成员域读操作\",\"t\":[\"MM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下arrays[0] = 1，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。\"]},\"161\":{\"h\":\"关于final重排序的总结\",\"t\":[\"按照final修饰的数据类型分类：\",\"基本数据类型: \",\"final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。\",\"final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。\",\"引用数据类型： \",\"额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序\"]},\"162\":{\"h\":\"final的实现原理\",\"t\":[\"上面我们提到过，写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。 很有意思的是，如果以X86处理为例，X86不会对写-写重排序，所以StoreStore屏障可以省略。由于不会对有间接依赖性的操作重排序，所以在X86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说，以X86为例的话，对final域的读/写的内存屏障都会被省略！具体是否插入还是得看是什么处理器\"]},\"163\":{\"h\":\"volatile 详解\"},\"164\":{\"h\":\"volatile的作用详解\"},\"165\":{\"h\":\"防重排序\",\"t\":[\"实例化一个对象其实可以分为三个步骤：\",\"分配内存空间。\",\"初始化对象。\",\"将内存空间的地址赋值给对应的引用。\",\"但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：\",\"分配内存空间。\",\"将内存空间的地址赋值给对应的引用。\",\"初始化对象\",\"如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。\"]},\"166\":{\"h\":\"实现可见性\",\"t\":[\"可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题。\"]},\"167\":{\"h\":\"保证原子性: 单次读/写\",\"t\":[\"volatile不能保证完全的原子性，只能保证单次的读/写操作具有原子性\"]},\"168\":{\"h\":\"问题1： i++为什么不能保证原子性?\",\"t\":[\"i++其实是一个复合操作，包括三步骤：\",\"读取i的值。\",\"对i加1。\",\"将i的值写回内存。 volatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。 注：上面几段代码中多处执行了Thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。\"]},\"169\":{\"h\":\"问题2： 共享的long和double变量的为什么要用volatile?\",\"t\":[\"因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。\"]},\"170\":{\"h\":\"volatile 的实现原理\"},\"171\":{\"h\":\"volatile 可见性实现\",\"t\":[\"volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现:\",\"内存屏障，又称内存栅栏，是一个 CPU 指令。\",\"在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。\"]},\"172\":{\"h\":\"volatile 有序性实现\"},\"173\":{\"h\":\"happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。\"},\"174\":{\"h\":\"volatile 禁止重排序\",\"t\":[\"为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。 Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。 JMM 会针对编译器制定 volatile 重排序规则表。 \\\" NO \\\" 表示禁止重排序。 为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。 对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。\",\"在每个 volatile 写操作的前面插入一个 StoreStore 屏障。\",\"在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。\",\"在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。\",\"在每个 volatile 读操作的后面插入一个 LoadStore 屏障。\",\"volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。\",\"内存屏障\",\"说明\",\"StoreStore 屏障\",\"禁止上面的普通写和下面的 volatile 写重排序。\",\"StoreLoad 屏障\",\"防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。\",\"LoadLoad 屏障\",\"禁止下面所有的普通读操作和上面的 volatile 读重排序。\",\"LoadStore 屏障\",\"禁止下面所有的普通写操作和上面的 volatile 读重排序。\",\"image.png\",\"image.png\"]},\"175\":{\"h\":\"synchronized 详解\"},\"176\":{\"h\":\"JUC\"},\"177\":{\"h\":\"JUC 原子类\"},\"178\":{\"h\":\"JUC 锁\"},\"179\":{\"h\":\"JUC 集合\"},\"180\":{\"h\":\"JUC 线程池\"},\"181\":{\"h\":\"JUC 工具类\"},\"182\":{\"h\":\"ThreadLocal\"},\"183\":{\"h\":\"Transmittable-Thread-Local\"},\"184\":{\"h\":\"Java IO\"},\"185\":{\"h\":\"JVM\",\"t\":[\"JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，JVM 是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java 虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM 屏蔽了与具体操作系统平台相关的信息，使 Java 程序只需生成在 Java 虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM 在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。\",\"Java 中的所有类，必须被装载到 jvm 中才能运行，这个装载工作是由 jvm 中的类装载器完成的，类装载器所做的工作实质是把类文件从硬盘读取到内存中。所以 JVM 的主要内容如下图\"]},\"186\":{\"h\":\"JVM 的编译\",\"t\":[\"class文件结构\",\".java 文件由 javac 进行代码编译，编译为.class 文件，.class 文件记录者整个源码的相关信息。\"]},\"187\":{\"h\":\"类加载子系统\",\"t\":[\"类加载子系统详解\",\"类加载器子系统负责从文件系统或者网络中加载 Class 文件，class 文件在文件开头有特定的文件标识。ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 Execution Engine（执行引擎）决定。\",\"类加载过程如下图\"]},\"188\":{\"h\":\"加载\",\"t\":[\"通过一个类的全限定名获取定义此类的`二进制例）\"]},\"189\":{\"h\":\"类加载器有哪些\"},\"190\":{\"h\":\"tomcat 为什么要自定义类加载器\",\"t\":[\"Tomcat 是如何打破\\\"双亲委派\\\"机制的?\",\"真正实现 web 应用程序之间的类加载器相互隔离 oader 类加载器。它为什么可以隔离每个 web 应用程序呢？原因就是它打破了\\\"双亲委派\\\"的机制，如果收到类加载的请求，它会先尝试自己去加载，如果找不到在交给父加载器去加载，这么做的目的就是为了优先加载 Web 应用程序自己定义的类来实现 web 应用程序相互隔离独立的。\",\"CommonClassLoader(通用类加载器)：主要 se}/lib 定义的目录和 jar 以及${catalina.home}/lib 定义的目录和 jar，可以被 Tomcat 和所有的 Web 应用程序共同使用。\",\"WebAppClassLoader(web 应用的类加载器):心类加载器，每个 Web 应用程序都有一个 WebAppClassLoader，类库仅仅可以被此 Web 应用程序使用，对 Tomcat 和其他 Web 程序都不可见。\"]},\"191\":{\"h\":\"WebAppClassLoader 加载流程\",\"t\":[\"@Override public Class<?> findClass(String name) throws ClassNotFoundException { if (log.isDebugEnabled()) log.debug(\\\" findClass(\\\" + name + \\\")\\\"); checkStateForClassLoading(name); // (1) Permission to define this class when using a SecurityManager if (securityManager != null) { int i = name.lastIndexOf('.'); if (i >= 0) { try { if (log.isTraceEnabled()) log.trace(\\\" securityManager.checkPackageDefinition\\\"); securityManager.checkPackageDefinition(name.substring(0,i)); } catch (Exception se) { if (log.isTraceEnabled()) log.trace(\\\" -->Exception-->ClassNotFoundException\\\", se); throw new ClassNotFoundException(name, se); } } } // Ask our superclass to locate this class, if possible // (throws ClassNotFoundException if it is not found) Class<?> clazz = null; try { if (log.isTraceEnabled()) log.trace(\\\" findClassInternal(\\\" + name + \\\")\\\"); try { if (securityManager != null) { PrivilegedAction<Class<?>> dp = new PrivilegedFindClassByName(name); clazz = AccessController.doPrivileged(dp); } else { // 1、先在应用本地目录下查找类 clazz = findClassInternal(name); } } catch(AccessControlException ace) { log.warn(\\\"WebappClassLoader.findClassInternal(\\\" + name + \\\") security exception: \\\" + ace.getMessage(), ace); throw new ClassNotFoundException(name, ace); } catch (RuntimeException e) { if (log.isTraceEnabled()) log.trace(\\\" -->RuntimeException Rethrown\\\", e); throw e; } if ((clazz == null) && hasExternalRepositories) { try { // 2、如果在本地目录没有找到，委派父加载器去查找 clazz = super.findClass(name); } catch(AccessControlException ace) { log.warn(\\\"WebappClassLoader.findClassInternal(\\\" + name + \\\") security exception: \\\" + ace.getMessage(), ace); throw new ClassNotFoundException(name, ace); } catch (RuntimeException e) { if (log.isTraceEnabled()) log.trace(\\\" -->RuntimeException Rethrown\\\", e); throw e; } } // 3、如果父加载器也没找到，抛出异常 if (clazz == null) { if (log.isDebugEnabled()) log.debug(\\\" --> Returning ClassNotFoundException\\\"); throw new ClassNotFoundException(name); } } catch (ClassNotFoundException e) { if (log.isTraceEnabled()) log.trace(\\\" --> Passing on ClassNotFoundException\\\"); throw e; } // Return the class we have located if (log.isTraceEnabled()) log.debug(\\\" Returning class \\\" + clazz); if (log.isTraceEnabled()) { ClassLoader cl; if (Globals.IS_SECURITY_ENABLED){ cl = AccessController.doPrivileged( new PrivilegedGetClassLoader(clazz)); } else { cl = clazz.getClassLoader(); } log.debug(\\\" Loaded by \\\" + cl.toString()); } return (clazz); } \",\"@Override public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { Class<?> clazz = null; // 1、从本地缓存中查找是否加载过此类 clazz = findLoadedClass0(name); if (clazz != null) { if (log.isDebugEnabled()) log.debug(\\\" Returning class from cache\\\"); if (resolve) resolveClass(clazz); return clazz; } // 2、从AppClassLoader中查找是否加载过此类 clazz = findLoadedClass(name); if (clazz != null) { if (log.isDebugEnabled()) log.debug(\\\" Returning class from cache\\\"); if (resolve) resolveClass(clazz); return clazz; } String resourceName = binaryNameToPath(name, false); // 3、尝试用ExtClassLoader 类加载器加载类,防止应用覆盖JRE的核心类 ClassLoader javaseLoader = getJavaseClassLoader(); boolean tryLoadingFromJavaseLoader; try { URL url; if (securityManager != null) { PrivilegedAction<URL> dp = new PrivilegedJavaseGetResource(resourceName); url = AccessController.doPrivileged(dp); } else { url = javaseLoader.getResource(resourceName); } tryLoadingFromJavaseLoader = (url != null); } catch (Throwable t) { tryLoadingFromJavaseLoader = true; } boolean delegateLoad = delegate || filter(name, true); // 4、判断是否设置了delegate属性,如果设置为true那么就按照双亲委派机制加载类 if (delegateLoad) { if (log.isDebugEnabled()) log.debug(\\\" Delegating to parent classloader1 \\\" + parent); try { clazz = Class.forName(name, false, parent); if (clazz != null) { if (log.isDebugEnabled()) log.debug(\\\" Loading class from parent\\\"); if (resolve) resolveClass(clazz); return clazz; } } catch (ClassNotFoundException e) { // Ignore } } // 5、默认是设置delegate是false的,那么就会先用WebAppClassLoader进行加载 if (log.isDebugEnabled()) log.debug(\\\" Searching local repositories\\\"); try { clazz = findClass(name); if (clazz != null) { if (log.isDebugEnabled()) log.debug(\\\" Loading class from local repository\\\"); if (resolve) resolveClass(clazz); return clazz; } } catch (ClassNotFoundException e) { // Ignore } // 6、如果在WebAppClassLoader没找到类，那么就委托给AppClassLoader去加载 if (!delegateLoad) { if (log.isDebugEnabled()) log.debug(\\\" Delegating to parent classloader at end: \\\" + parent); try { clazz = Class.forName(name, false, parent); if (clazz != null) { if (log.isDebugEnabled()) log.debug(\\\" Loading class from parent\\\"); if (resolve) resolveClass(clazz); return clazz; } } catch (ClassNotFoundException e) { // Ignore } } } throw new ClassNotFoundException(name); } \",\"先在本地缓存中查找该类是否已经加载过，如果加载过就返回缓存中的。\",\"如果没有加载过，委托给 AppClassLoader 是否加载过，如果加载过就返回。\",\"如果 AppClassLoader 也没加载过，委托给 ExtClassLoader 去加载，这么做的目的就是：\",\"防止应用自己的类库覆盖了核心类库，因为 WebAppClassLoader 需要打破双亲委托机制，假如应用里自定义了一个叫 java.lang.String 的类，如果先加载这个类，就会覆盖核心类库的 java.lang.String，所以说它会优先尝试用 ExtClassLoader 去加载，因为 ExtClassLoader 加载不到同样也会委托给 BootstrapClassLoader 去加载，也就避免了覆盖了核心类库的问题。\",\"如果 ExtClassLoader 也没有查找到，说明核心类库中没有这个类，那么就在本地应用目录下查找此类并加载。\",\"如果本地应用目录下还有没有这个类，那么肯定不是应用自己定义的类，那么就由 AppClassLoader 去加载。\",\"这里是通过 Class.forName()调用 AppClassLoader 类加载器的，因为 Class.forName()的默认加载器就是 AppClassLoader。\",\"如果上述都没有找到，那么只能抛出 ClassNotFoundException 了。\"]},\"192\":{\"h\":\"链接-Linking\",\"t\":[\"JVM 连接阶段\",\"连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。\"]},\"193\":{\"h\":\"验证(Verify)：\",\"t\":[\"1.类文件的结构检查: 确保类文件遵从 Java 类文件的固定格式。\",\"2.语义检查:确保类本身符合 Java 语言的语法规定。注意，语义检查的错误在编译器编译阶段就会通不过，但是如果有程序员通过非编译的手段生成了类文件，其中有可能会含有语义错误，此时的语义检查主要是防止这种没有编译而生成的 class 文件引入的错误\",\"3.字节码验证：确保字节码流可以被 Java 虚拟机安全地执行。字节码验证步骤会检查每个操作码是否合法，即是否有着合法的操作数。\",\"4.二级制兼容性的验证：确保相互引用的类之间的协调一致。\"]},\"194\":{\"h\":\"准备(Prepare)：\",\"t\":[\"在准备阶段，Java 虚拟机为类的静态变量分配内存，并设置默认的初始值。\"]},\"195\":{\"h\":\"解析(Resolve)\",\"t\":[\"在解析阶段，Java 虚拟机会把类的二级制数据中的符号引用替换为直接引用。\"]},\"196\":{\"h\":\"初始化-Initialization\",\"t\":[\"加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常最池信息，可能还包括字符串字而量和数字常量(这部分常量信息是 Class 文件中常量池部分的内存映射)\"]},\"197\":{\"h\":\"运行时数据区\",\"t\":[\"JVM 运行时数据区\",\"名称\",\"是否线程共享\",\"描述\",\"本地方法栈\",\"否\",\"与虚拟机的作用是相似的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的，与虚拟机栈相同的是栈的深度是固定的，当线程申请的大于虚拟机栈的深度就会抛出 StackOverFlowError 异常，当然虚拟机栈也可以动态的扩展，如果扩展到无法申请到足够的内存就会抛出 outofMemoryError 异常。\",\"虚拟机栈\",\"否\",\"描述的是 Java 方法执行的内存模型，每个方法在执行的同时都会创建一个线帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，都对应这一个线帧在虚拟机栈中入栈到出栈的过程。\",\"程序计数器\",\"否\",\"程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。\",\"方法区\",\"是\",\"用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。\",\"堆\",\"是\",\"是 Java 虚拟机中内存最大的一块，是被所有线程共享的，在虚拟机启动时候创建，Java 堆唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，随着 JIT 编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化的技术将会导致一些微妙的变化，所有对象都分配在堆上渐渐变得不那么“绝对”了。\"]},\"198\":{\"h\":\"虚拟机栈\",\"t\":[\"描述的是 Java 方法执行的内存模型，每个方法在执行的同时都会创建一个线帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，都对应这一个线帧在虚拟机栈中入栈到出栈的过程。\"]},\"199\":{\"h\":\"本地方法栈\",\"t\":[\"与虚拟机的作用是相似的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的，与虚拟机栈相同的是栈的深度是固定的，当线程申请的大于虚拟机栈的深度就会抛出 StackOverFlowError 异常，当然虚拟机栈也可以动态的扩展，如果扩展到无法申请到足够的内存就会抛出 outofMemoryError 异常。\"]},\"200\":{\"h\":\"程序计数器\",\"t\":[\"程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。java 中最小的执行单位是线程，因为虚拟机的是多线程的，每个线程是抢夺 cpu 时间片，程序计数器就是存储这些指令去做什么，比如循环，跳转，异常处理等等需要依赖它。每个线程都有属于自己的程序计数器，而且互不影响，独立存储。\"]},\"201\":{\"h\":\"方法区\",\"t\":[\"用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。\",\"内存区域是很重要的系统资源，是硬盘和 CPU 的中间桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异，我们现在以使用最为流行的 HotSpot 虚拟机为例讲解。\"]},\"202\":{\"h\":\"堆\",\"t\":[\"是 Java 虚拟机中内存最大的一块，是被所有线程共享的，在虚拟机启动时候创建，Java 堆唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，随着 JIT 编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化的技术将会导致一些微妙的变化，所有对象都分配在堆上渐渐变得不那么“绝对”了。Java8及之后堆内存分为：新生区（新生代）+老年区（老年代），新生区分为Eden（伊甸园）区和Survivor（幸存者）区，堆内存的分配：老年代（2/3）+新生代（1/3）， 新生代= Eden(8/10) + From(1/10) + To(1/10)\"]},\"203\":{\"h\":\"执行引擎\",\"t\":[\"JVM 执行引擎的作用及工作过程\"]},\"204\":{\"h\":\"解释器\"},\"205\":{\"h\":\"JIT\",\"t\":[\"[Java 性能] 3. 什么是 JIT\"]},\"206\":{\"h\":\"垃圾回收器\",\"t\":[\"垃圾收集器\"]},\"207\":{\"h\":\"如何判断一个对象是否还存活\",\"t\":[\"引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。\",\"可达性分析：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。\",\"在Java语言中，GC Roots包括： \",\"虚拟机栈中引用的对象。\",\"方法区中类静态属性实体引用的对象。\",\"方法区中常量引用的对象。\",\"本地方法栈中JNI引用的对象。\"]},\"208\":{\"h\":\"垃圾收集算法\",\"t\":[\"标记-清除算法：算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。\",\"缺点：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\",\"复制算法：它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。\",\"缺点：内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低；在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。\",\"优点：每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。\",\"标记-压缩算法：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\",\"分代收集算法： 把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。\"]},\"209\":{\"h\":\"垃圾收集器\",\"t\":[\"Serial收集器：串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停）\",\"ParNew收集器：ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩\",\"Parallel收集器：Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩\",\"Parallel Old 收集器：Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供\",\"CMS收集器：CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。\",\"G1垃圾回收器：G1垃圾回收器将堆内存分割成不同的区域然后并发的对其进行垃圾回收。\",\"新生代GC策略\",\"老年老代GC策略\",\"说明\",\"组合1\",\"Serial\",\"Serial Old\",\"Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程。\",\"组合2\",\"Serial\",\"CMS+Serial Old\",\"CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。\",\"组合3\",\"ParNew\",\"CMS\",\"使用 -XX:+UseParNewGC选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项 -XX:+UseConcMarkSweepGC选项，则新生代默认使用ParNew GC策略。\",\"组合4\",\"ParNew\",\"Serial Old\",\"使用 -XX:+UseParNewGC选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。\",\"组合5\",\"Parallel Scavenge\",\"Serial Old\",\"Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。\",\"组合6\",\"Parallel Scavenge\",\"Parallel Old\",\"Parallel Old是Serial Old的并行版本\",\"组合7\",\"G1GC\",\"G1GC\",\"-XX:+UnlockExperimentalVMOptions -XX:+UseG1GC -XX:MaxGCPauseMillis=50 -XX:GCPauseIntervalMillis=200 -XX:+G1YoungGenSize=512m -XX:SurvivorRatio=6\"]},\"210\":{\"h\":\"优化\"},\"211\":{\"h\":\"获取 jvm 数据\",\"t\":[\"jmap -F -dump:format=b,file=dumpFile.phrof pid \"]},\"212\":{\"h\":\"jvm 数据分析\",\"t\":[\"http://www.fastthread.io\",\"https://spotify.github.io/threaddump-analyzer\",\"http://gceasy.io\",\"http://heaphero.io\"]},\"213\":{\"h\":\"调优\",\"t\":[\"JVM 优化\"]},\"214\":{\"h\":\"优化工具\",\"t\":[\"JVM 优化工具\",\"jps 虚拟机进程状况工具 jsp [options] [hostid]\",\"jstat 虚拟机统计信息监控工具 jstat [ option vmid [interval[s|ms] [count]] ]\",\"jinfo java 配置信息工具 jinfo [option] pid\",\"jmap java 内存映像工具 jmap [option] vmid\",\"jhat 虚拟机堆转储快照分析工具\",\"jstack java 堆栈跟踪工具 jstack [option] vmid\"]},\"215\":{\"h\":\"JDK 动态代理和 CGLIB 代理\"},\"216\":{\"h\":\"什么是代理\",\"t\":[\"代理模式（Proxy Pattern）给某一个对象提供一个代理，并由代理对象控制原对象的引用。代理对象在客户端和目标对象之间起到中介作用。即使用时通过中介使用，具体到对象原对象的操作则是需要代理对象处理的。\"]},\"217\":{\"h\":\"JDK 动态代理\",\"t\":[\"自Java 1.3以后，Java提供了动态代理技术，允许开发者在运行期创建接口的代理实例，后来这项技术被用到了Spring的很多地方。JDK动态代理主要涉及java.lang.reflect包下边的两个类：Proxy和InvocationHandler。其中，InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑（如：我们在方法执行前后打印的日志，本文只是为了演示，实际的应用一般不会只是简单的打印日志的），并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起。\"]},\"218\":{\"h\":\"实例\",\"t\":[\"代理的接口\",\"public interface Parent { void sayHell(String s); } \",\"代理的对象类\",\"public class Children implements Parent{ @Override public void sayHell(String s) { System.out.println(\\\"children\\\" + s); } } \",\"创建代理类\",\"public class ProxyHandler implements InvocationHandler { private Object o; public ProxyHandler(Object o) { this.o = o; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\\\"开始事务\\\"); method.invoke(o, args); System.out.println(\\\"结束事务\\\"); return null; } } \",\"测试类\",\"public class ProxyTest { public static void main(String[] args) { ProxyHandler handler = new ProxyHandler(new Children()); Parent parent = (Parent) Proxy.newProxyInstance( Children.class.getClassLoader(), new Class[]{Parent.class}, handler); parent.sayHell(\\\"hello\\\"); } } \",\"结果\",\"开始事务 childrenhello 结束事务 \"]},\"219\":{\"h\":\"JDK动态代理步骤\",\"t\":[\"拿到被代理对象的引用，并且通过反射获取到它的所有的接口。\",\"通过JDK Proxy类重新生成一个新的类，同时新的类要实现被代理类所实现的所有的接口。\",\"动态生成 Java 代码，把新加的业务逻辑方法由一定的逻辑代码去调用。\",\"编译新生成的 Java 代码.class。\",\"将新生成的Class文件重新加载到 JVM 中运行。\",\"所以说JDK动态代理的核心是通过重写被代理对象所实现的接口中的方法来重新生成代理类来实现的，那么假如被代理对象没有实现接口呢？那么这时候就需要CGLIB动态代理了。\"]},\"220\":{\"h\":\"CGLIB 代理\",\"t\":[\"CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。\"]},\"221\":{\"h\":\"实例\",\"t\":[\"代理的类\",\"public class Hello { public void sayHell(String s) { System.out.println(\\\"Hello \\\" + s); } } \",\"创建代理类\",\"public class HelloProxy implements MethodInterceptor{ private Enhancer enhancer = new Enhancer(); public <T> T getProxy(Class<T> clazz){ //设置需要创建子类的类 enhancer.setSuperclass(clazz); enhancer.setCallback(this); //通过字节码技术动态创建子类实例 return (T) enhancer.create(); } @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { System.out.println(\\\"开始事务\\\"); proxy.invokeSuper(obj,args); System.out.println(\\\"结束事务\\\"); return null; } } \",\"测试类\",\"public class HelloProxyTest { public static void main(String[] args) { HelloProxy helloProxy = new HelloProxy(); Hello hello = (Hello) helloProxy.getProxy(Hello.class); hello.sayHell(\\\"hello\\\"); } } \",\"结果\",\"开始事务 Hello hello 结束事务 \"]},\"222\":{\"h\":\"对比\"},\"223\":{\"h\":\"实现原理\",\"t\":[\"JDK动态代理具体实现原理：\",\"核心是通过重写被代理对象所实现的接口中的方法来重新生成代理类来实现的\",\"CGLib动态代理：\",\"利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。\"]},\"224\":{\"h\":\"面向\",\"t\":[\"JDK动态代理是面向接口的。\",\"CGLib动态代理是通过字节码底层继承要代理类来实现，因此如果被代理类被final关键字所修饰，会失败。\"]},\"225\":{\"h\":\"使用注意：\",\"t\":[\"如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）；\",\"如果要被代理的对象不是个实现类那么，Spring会强制使用CGLib来实现动态代理。\"]},\"226\":{\"h\":\"各自局限：\",\"t\":[\"JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理。\",\"cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。\"]},\"227\":{\"h\":\"性能对比\",\"t\":[\"关于两者之间的性能的话，网上有人对于不通版本的jdk进行测试，经过多次试验，测试结果大致是这样的，在1.6和1.7的时候，JDK动态代理的速度要比CGLib动态代理的速度要慢，但是并没有教科书上的10倍差距，在JDK1.8的时候，JDK动态代理的速度已经比CGLib动态代理的速度快很多了，但是JDK动态代理和CGLIB动态代理的适用场景还是不一样的哈！\"]},\"228\":{\"h\":\"String源码\"},\"229\":{\"h\":\"1. 属性\",\"t\":[\"/** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; \",\"使用 final 修饰的 value。只能初始化一次，如果大量拼接，不可使用该类型\",\"使用字符组进行缓存数据\"]},\"230\":{\"h\":\"2. 构造方法\"},\"231\":{\"h\":\"public String()\",\"t\":[\"/** * Initializes a newly created {@code String} object so that it represents * an empty character sequence. Note that use of this constructor is * unnecessary since Strings are immutable. */ public String() { this.value = \\\"\\\".value; } \",\"通过设置\\\"\\\".value，实现创建对象.\",\"hash 值默认为 0。\"]},\"232\":{\"h\":\"public String(String original)\",\"t\":[\"/** * Initializes a newly created {@code String} object so that it represents * the same sequence of characters as the argument; in other words, the * newly created string is a copy of the argument string. Unless an * explicit copy of {@code original} is needed, use of this constructor is * unnecessary since Strings are immutable. * * @param original * A {@code String} */ public String(String original) { this.value = original.value; this.hash = original.hash; } \",\"通过传入的字符串，设置对象，并且设置对应的 hash\"]},\"233\":{\"h\":\"public String(char value[])\",\"t\":[\"/** * Allocates a new {@code String} so that it represents the sequence of * characters currently contained in the character array argument. The * contents of the character array are copied; subsequent modification of * the character array does not affect the newly created string. * * @param value * The initial value of the string */ public String(char value[]) { this.value = Arrays.copyOf(value, value.length); } \",\"通过传入的字符组进行复制，从而创建对象。\"]},\"234\":{\"h\":\"public String(byte bytes[])\",\"t\":[\" /** * Constructs a new {@code String} by decoding the specified array of bytes * using the platform's default charset. The length of the new {@code * String} is a function of the charset, and hence may not be equal to the * length of the byte array. * * <p> The behavior of this constructor when the given bytes are not valid * in the default charset is unspecified. The {@link * java.nio.charset.CharsetDecoder} class should be used when more control * over the decoding process is required. * * @param bytes * The bytes to be decoded into characters * * @since JDK1.1 */ public String(byte bytes[]) { this(bytes, 0, bytes.length); } \",\"通过字节组进行创建对象，调用该对象的其他方法，传入字节组，开始和结束的位置进行创建\"]},\"235\":{\"h\":\"public String(StringBuffer buffer)\",\"t\":[\"/** * Allocates a new string that contains the sequence of characters * currently contained in the string buffer argument. The contents of the * string buffer are copied; subsequent modification of the string buffer * does not affect the newly created string. * * @param buffer * A {@code StringBuffer} */ public String(StringBuffer buffer) { synchronized(buffer) { this.value = Arrays.copyOf(buffer.getValue(), buffer.length()); } } \",\"通过 StringBuffer 进行构建对象，通过 StringBufer.getValue()返回字符组，配合字符组长度创建对象\",\"StringBuffer 通过 synchronized 进行出现线程数据共享，由此可见 StringBuffer 是线程安全的\"]},\"236\":{\"h\":\"public String(StringBuilder builder)\",\"t\":[\"/** * Allocates a new string that contains the sequence of characters * currently contained in the string builder argument. The contents of the * string builder are copied; subsequent modification of the string builder * does not affect the newly created string. * * <p> This constructor is provided to ease migration to {@code * StringBuilder}. Obtaining a string from a string builder via the {@code * toString} method is likely to run faster and is generally preferred. * * @param builder * A {@code StringBuilder} * * @since 1.5 */ public String(StringBuilder builder) { this.value = Arrays.copyOf(builder.getValue(), builder.length()); } \",\"和上个方法对比，可看出 StringBuilder 线程不安全。\"]},\"237\":{\"h\":\"3. 常用方法\"},\"238\":{\"h\":\"字符串的长度 length()\",\"t\":[\" /** * Returns the length of this string. * The length is equal to the number of <a href=\\\"Character.html#unicode\\\">Unicode * code units</a> in the string. * * @return the length of the sequence of characters represented by this * object. */ public int length() { return value.length; } \",\"通过字符组的长度从而获得字符串的长度\"]},\"239\":{\"h\":\"是否为空 isEmpty()\",\"t\":[\" /** * Returns {@code true} if, and only if, {@link #length()} is {@code 0}. * * @return {@code true} if {@link #length()} is {@code 0}, otherwise * {@code false} * * @since 1.6 */ public boolean isEmpty() { return value.length == 0; } \",\"检测是否为空时未检测对象是否为 null，所以使用该方法时需要考虑是否为 null\"]},\"240\":{\"h\":\"获得字符串的第几个字符 charAt(int index)\",\"t\":[\"/** * Returns the {@code char} value at the * specified index. An index ranges from {@code 0} to * {@code length() - 1}. The first {@code char} value of the sequence * is at index {@code 0}, the next at index {@code 1}, * and so on, as for array indexing. * * <p>If the {@code char} value specified by the index is a * <a href=\\\"Character.html#unicode\\\">surrogate</a>, the surrogate * value is returned. * * @param index the index of the {@code char} value. * @return the {@code char} value at the specified index of this string. * The first {@code char} value is at index {@code 0}. * @exception IndexOutOfBoundsException if the {@code index} * argument is negative or not less than the length of this * string. */ public char charAt(int index) { if ((index < 0) || (index >= value.length)) { throw new StringIndexOutOfBoundsException(index); } return value[index]; } \",\"通过传入的字符串的位置进行获取，如果不在返回内会抛出StringIndexOutOfBoundsException异常。\"]},\"241\":{\"h\":\"比较内容是否相等 equals(Object object)\",\"t\":[\"/** * Compares this string to the specified object. The result is {@code * true} if and only if the argument is not {@code null} and is a {@code * String} object that represents the same sequence of characters as this * object. * * @param anObject * The object to compare this {@code String} against * * @return {@code true} if the given object represents a {@code String} * equivalent to this string, {@code false} otherwise * * @see #compareTo(String) * @see #equalsIgnoreCase(String) */ public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } \",\"基本的数据类型相等的判断只需要==就可以判断，但是封装类型，需要通过 equals 进行判断。\",\"如果需要对自定义对象进行判断是否相等，需要重写对象的equals方法，从而实现自定义比较方法。如果不重写，则默认比较内存地址。\"]},\"242\":{\"h\":\"忽略大小写比较是否相等 equalsIgnoreCase(String anotherString)\",\"t\":[\"/** * Compares this {@code String} to another {@code String}, ignoring case * considerations. Two strings are considered equal ignoring case if they * are of the same length and corresponding characters in the two strings * are equal ignoring case. * * <p> Two characters {@code c1} and {@code c2} are considered the same * ignoring case if at least one of the following is true: * <ul> * <li> The two characters are the same (as compared by the * {@code ==} operator) * <li> Applying the method {@link * java.lang.Character#toUpperCase(char)} to each character * produces the same result * <li> Applying the method {@link * java.lang.Character#toLowerCase(char)} to each character * produces the same result * </ul> * * @param anotherString * The {@code String} to compare this {@code String} against * * @return {@code true} if the argument is not {@code null} and it * represents an equivalent {@code String} ignoring case; {@code * false} otherwise * * @see #equals(Object) */ public boolean equalsIgnoreCase(String anotherString) { return (this == anotherString) ? true : (anotherString != null) && (anotherString.value.length == value.length) && regionMatches(true, 0, anotherString, 0, value.length); } \",\"进行判断对象的内存地址是否相同--->地址相同，说明同一个对象，自己比较自己肯定 true\",\"然后判断是否为空，长度是否相同，然后再循环比较每个字符忽略大小写比较\"]},\"243\":{\"h\":\"比较字符串的大小 compareTo(String anotherString)\",\"t\":[\" /** * Compares two strings lexicographically. * The comparison is based on the Unicode value of each character in * the strings. The character sequence represented by this * {@code String} object is compared lexicographically to the * character sequence represented by the argument string. The result is * a negative integer if this {@code String} object * lexicographically precedes the argument string. The result is a * positive integer if this {@code String} object lexicographically * follows the argument string. The result is zero if the strings * are equal; {@code compareTo} returns {@code 0} exactly when * the {@link #equals(Object)} method would return {@code true}. * <p> * This is the definition of lexicographic ordering. If two strings are * different, then either they have different characters at some index * that is a valid index for both strings, or their lengths are different, * or both. If they have different characters at one or more index * positions, let <i>k</i> be the smallest such index; then the string * whose character at position <i>k</i> has the smaller value, as * determined by using the &lt; operator, lexicographically precedes the * other string. In this case, {@code compareTo} returns the * difference of the two character values at position {@code k} in * the two string -- that is, the value: * <blockquote> <pre> * this.charAt(k)-anotherString.charAt(k) * </pre></blockquote> * If there is no index position at which they differ, then the shorter * string lexicographically precedes the longer string. In this case, * {@code compareTo} returns the difference of the lengths of the * strings -- that is, the value: * <blockquote> <pre> * this.length()-anotherString.length() * </pre></blockquote> * * @param anotherString the {@code String} to be compared. * @return the value {@code 0} if the argument string is equal to * this string; a value less than {@code 0} if this string * is lexicographically less than the string argument; and a * value greater than {@code 0} if this string is * lexicographically greater than the string argument. */ public int compareTo(String anotherString) { int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k < lim) { char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) { return c1 - c2; } k++; } return len1 - len2; } \",\"找出长度最短的字符串长度\",\"循环比较，如果有不相等的则返回插值\",\"一直想等则返回长度差值\"]},\"244\":{\"h\":\"判断字符串是否从某个字符串开始的 startsWith(String prefix, int toffset)\",\"t\":[\"/** * Tests if the substring of this string beginning at the * specified index starts with the specified prefix. * * @param prefix the prefix. * @param toffset where to begin looking in this string. * @return {@code true} if the character sequence represented by the * argument is a prefix of the substring of this object starting * at index {@code toffset}; {@code false} otherwise. * The result is {@code false} if {@code toffset} is * negative or greater than the length of this * {@code String} object; otherwise the result is the same * as the result of the expression * <pre> * this.substring(toffset).startsWith(prefix) * </pre> */ public boolean startsWith(String prefix, int toffset) { char ta[] = value; int to = toffset; char pa[] = prefix.value; int po = 0; int pc = prefix.value.length; // Note: toffset might be near -1>>>1. if ((toffset < 0) || (toffset > value.length - pc)) { return false; } while (--pc >= 0) { if (ta[to++] != pa[po++]) { return false; } } return true; } \",\"获取对象的字符组、开始位置、传入的字符组，计算得出结束位置\",\"判断开始位置和结束位置是否超出\",\"循环比较是否相等\"]},\"245\":{\"h\":\"4. 常见问题\"},\"246\":{\"h\":\"Java 基础面试题\"},\"247\":{\"h\":\"1. Java 语言有哪些特点\",\"t\":[\"简单易学、有丰富的类库\",\"面向对象（Java 最重要的特性，让程序耦合度更低，内聚性更高）\",\"与平台无关性（JVM 是 Java 跨平台的根本）\",\"可靠安全\",\"支持多线程\"]},\"248\":{\"h\":\"2. 面向对象和面向过程的区别\",\"t\":[\"面向过程：是分析解决问题的步骤，然后用按说把这些步骤一步一步的实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发\",\"面向对象：是吧构成问题的事务分解成对象，而建立对象的目的也不完全是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。但是性能上来说，比面向过程要低。\"]},\"249\":{\"h\":\"3. 八种基本数据类型的大小、以及他们的封装类\",\"t\":[\"byte 1 字节 默认值 0 封装类 Byte\",\"short 2 字节 默认值 0 封装类型 Short\",\"char 2 字节 默认值 null（\\\\u000） 封装类型 Character\",\"int 4 字节 默认值 0 封装类型 Integer\",\"float 4 字节 默认值 0.0f 封装类型 Float\",\"long 8 字节 默认值 0L 封装类型 Long\",\"double 8 字节 默认值 0.0d 封装类型 Double\",\"boolean 默认值 false 封装类型 Boolean \",\"JVM 虚拟机中没有提供 boolean 值专用的字节码指令，编译后是用 int 数据类型代替的，而 boolean 数组则会被编译成 byte 数组。所以 boolean 单独使用时是 4 个字节，数组中是 1 个字节。\",\"注意： 除了八种基础类型外都是封装类型\"]},\"250\":{\"h\":\"4. instanceof\",\"t\":[\"双目运算符，obj instanceof Class，判断 obj 是否是 Class （或其子类）的对象，若是返回 true\",\"注意： 编译器会检查 obj 是否能够转换为右面的 class 类型，若是不能确定则看运行时，obj 不可使基础类型\"]},\"251\":{\"h\":\"5. 自动装箱和拆箱\",\"t\":[\"装箱：就是自动把基础类型自动转换为封装类型\",\"拆箱：就是自动把封装类型转化为基础类型\",\"注意： Integer 内部存在存在有缓存，缓存的数据大小为[-128,127]\"]},\"252\":{\"h\":\"6. 重载和重写\",\"t\":[\"重写： 子类把父类中的方法进行重写，要求方法名、参数列表、返回类型都相同，访问修饰权限不�����小于父类\",\"重载：方法名称一致，参数列表不一致，返回类型无要求\"]},\"253\":{\"h\":\"7. == 和 equals\",\"t\":[\"== 比较的地址，用于比较是否是同一个对象\",\"equals 比较的是地址中的数据是否相等\"]},\"254\":{\"h\":\"8. hashCode 作用\",\"t\":[\"hashCode：返回的是对象根据内存地址算出的一个值，提升直接通过 equals 进行判断数据是否一致的效率\",\"在集合中会使用到对象的 hashCode，以此来提升性能\"]},\"255\":{\"h\":\"9. String、StringBuffer、StringBuilder 区别\",\"t\":[\"String：内部是 final 修饰的字符数组，当 String 进行拼接时相当于新建字符数组进行替换，效率较低\",\"StringBuffer、StringBuilder： 内部都是可变数组，进行频繁的字符串操作性能较高\",\"StringBuffer： 对方法添加了同步锁或者调用的方法添加了同步锁，所以线程安全的\",\"StringBuilder：线程不安全\"]},\"256\":{\"h\":\"10. ArrayList 和 LinkedList 的区别\",\"t\":[\"ArrayList： 内部基于数组进行存储的，所以通过索引查询的效率是 O(1)，删除数据是开销较大，需要进行数组的处理。\",\"LinkedList： 内部是基于链表进行存储的，所以查询的效率较低，但是删除的效率较高。\"]},\"257\":{\"h\":\"11. HashMap 和 HashTable 的区别\",\"t\":[\"HashMap \",\"继承自 AbstractMap 类，实现了 Map、Cloneable、Serializable 接口\",\"kv 都支持 null，但实际 key 为 null 只会存在一个\",\"线程不安全\",\"HashTable \",\"继承自 Dictionary 类，实现了 Map、Cloneable、Serializable 接口\",\"kv 都不能为 null\",\"线程安全\"]},\"258\":{\"h\":\"12. Collection 包和 Collections 包的区别\",\"t\":[\"Collection：是集合的上级接口包\",\"Collections： 是集合的工具包\"]},\"259\":{\"h\":\"13. Java 的四种引用\",\"t\":[\"强引用 \",\"String s = new String(\\\"1);\",\"软引用 \",\"SoftReference wrf = new SoftReference(new String(\\\"1\\\")); new String 是软引用\",\"弱引用 \",\"WeakReference wrf = new WeakReference(str): WeakReference 的 key 是弱引用\",\"虚引用 \",\"PhantomReference prf = new PhantomReference(new String(\\\"1\\\"),new ReferenceQueue<>())\"]},\"260\":{\"h\":\"14.泛型常用特点\",\"t\":[\"不必因为类型不一致而创建不同类\"]},\"261\":{\"h\":\"15. Java 创建对象的方式\",\"t\":[\"new 创建对象\",\"反射 newInstance\",\"clone 克隆\",\"通过序列化\"]},\"262\":{\"h\":\"16. 有没有可能两个对象不等，但是 hashCode 相等？\",\"t\":[\"可能得，会存在哈希冲突\",\"解决方法 \",\"拉链法：例如 hashMap，若 hashCode 一致，则通过链表进行链接，获取的时候先通过 hashCode 查找，若存在多个则通过 equals 比较\",\"开放定址法：一旦发生冲突，就去寻找下一个散列，只要散列足够大，空的散列地��总能找到，并记录存入\",\"再哈希： 又叫双哈希，当第一个 哈希函数结果冲突就在用第二个、第三个，直到无冲突\"]},\"263\":{\"h\":\"17. 深拷贝和浅拷贝\",\"t\":[\"浅拷贝：只复制当前对象，当前对象的属性还是引用之前对象的值\",\"深拷贝：不仅仅复制当前对象，当前对象的属性也进行复制\"]},\"264\":{\"h\":\"18. final 有哪些用法\",\"t\":[\"修饰的类不可被继承\",\"被修饰的方法不可被重写\",\"被修饰的变量不可被变更，但若是封装对象这可以改变引用地址内的内容\",\"被修饰的方法 JVM 会尝试将其内联，以提高效率\",\"被修饰的常量，在编译阶段会存入常量池中\",\"遵守两个重排序规则 \",\"在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个变量，这两个操作之间不能重排序\",\"初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。\",\"对于 final 域，编译器会在写入时插入一个 StoreStore 屏障，当读取 final 域时会插入 LoadLoad 屏障，这些屏障可以防止编译器和处理器在处理 final 域时进行过度的指令重排序。\",\"happens-before 规则 \",\"单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作。\",\"管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。\",\"volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。\",\"线程启动规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。\",\"线程加入规则：Thread 对象的结束先行发生于 join() 方法返回\",\"线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。\",\"对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。\",\"传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C\"]},\"265\":{\"h\":\"19.static 的用法\",\"t\":[\"静态常量\",\"静态方法\",\"静态代码快\",\"import staic 静态导包\"]},\"266\":{\"h\":\"20. 3*0.1 == 0.3 返回值是什么？\",\"t\":[\"false，因为浮点数不能完全的精确的表示出来\"]},\"267\":{\"h\":\"21. a=a+b 和 a+=b 有什么区别\",\"t\":[\"+= 会隐式自动转换\",\"byte a = 127;byte b = 127;b= a+b; 会报错，类型转换为 intb+=a;不会报错\"]},\"268\":{\"h\":\"22. try catch finally,try 里面有 return，finally 还会执行吗？\",\"t\":[\"会，在 return 前会执行 finally，如果 finally 有 return 则会直接 return\"]},\"269\":{\"h\":\"23. Exception 和 Error 包结构\",\"t\":[\"可以抛出的异常有三种 \",\"RuntimeException：运行时异常\",\"CheckException: 检查时异常\",\"Error：错误\"]},\"270\":{\"h\":\"24. OOM 你遇到过哪些情况，SOF 你遇到过那些情况\",\"t\":[\"OOM\",\"SOF\"]},\"271\":{\"h\":\"25. 简述线程、程序、进程的基本概念。以及他们之间的关系\",\"t\":[\"线程：线程和进程类似，但是线程是一个比进程更小的执行单位，一个进程在其执行的过程中可以产生多个小城。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程或是在各个线程之间切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量进程。\",\"程序：含有指令和数据的文件，被存在磁盘或其他的数据存储设备中，也就是说程序是静态的代码\",\"进程：程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序及时一个进程从创建、运行至消亡的过程，简单来说，一个进程就是一个执行的程序，它在计算机中一个指令接着一个指令的执行着没同事，每一个程序还占用某些系统资源如 CPU 时间、内存空间、文件、输入输出设备的使用权等等。\"]},\"272\":{\"h\":\"26. 某些字段不行序列化怎么办？\",\"t\":[\"使用 transient 关键字，阻止实例化中那些用此关键字修饰的变量序列化，相反 transient 修饰的变量值在被反序列化是也不会被持久化和回复。transient 只能修饰变量，不能修饰类和方法\"]},\"273\":{\"h\":\"27. java 中的 IO 流\",\"t\":[\"按照流向 \",\"输入\",\"输出\",\"按照操作单元 \",\"字节流\",\"字符流\",\"按照角色 \",\"节点流\",\"处理流\"]},\"274\":{\"h\":\"28. IO 和 NIO 的区别\",\"t\":[\"有相同的作用和目的，但是实现方式不同\",\"NIO 效率要比 IO 高很多\",\"JAVA API 中提供了两套的 NIO，一套是针对标准的输入输出，另一套就是网络编程 NIO\"]},\"275\":{\"h\":\"29. java 反射的作用与原理\",\"t\":[\"定义\",\"反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法，只要给定类的名称，就可以通过反射机制获得类的所有信息\",\"哪里用到\",\"框架中经常使用\",\"JDBC 的 Class.forName(\\\"com.mysql.jdbc.Driver.class\\\");\",\"反射的实现方式\",\"获取 class 对象的四种方式 \",\"Class.forName(\\\"\\\")\",\"类名.class\",\"对象.getClass()\",\"基础类型的包装类，可以调用包装类的 Type 属性来获得改包装的 Class 对象\",\"反射能够获取的信息\",\"class：表示正在运行对象的类\",\"Field： 提供有关类和接口的属性信息，以及对他的动态访问权限\",\"Constructor： 构造方法\",\"Method： 方法\",\"优点\",\"能够运行时动态获取类的实例，提高灵活性\",\"与动态编译结合\",\"缺点\",\"使用反射性能较低，需要解析字节码，将内存的对象进行解析。 \",\"通过 setAccessible(true) 关闭 JDK 的安全检查来提升反射速度\",\"多次创建一个类的实例时，有缓存会更多\",\"ReflectASM 工具类，通过字节码生成的方式加快反射速度\",\"相对不安全，破换了封装性\"]},\"276\":{\"h\":\"30. List、Set、Map 什么区别\",\"t\":[\"List：是单元素集合且有序可重复\",\"Set：是单元素集合且无序不可重复\",\"Map：键值对存储，key 不能重复，value 可以重复\"]},\"277\":{\"h\":\"31. Object 有哪些方法\",\"t\":[\"clone：克隆方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常，深度拷贝也需要实现 Cloneable，同时其成员变量为引用类型也要实现 Cloneable，然后重写 clone 方法\",\"finalize： 和垃圾收集器有关系，判断一个对象是都可以被回收的最后一步就是判断是否重写了此方法\",\"equals\",\"hashCode\",\"wait\",\"notify\",\"notifyAll\"]},\"278\":{\"h\":\"32. ArrayList 和 LinkedList\"},\"279\":{\"h\":\"33. 存在数组了为什么还要 ArrayList\",\"t\":[\"数组不可以自动扩容\"]},\"280\":{\"h\":\"34. 什么是 fail-fast\",\"t\":[\"集合的一种错误机制，集合在操作的时候 modCount 会自增，在进行迭代其遍历时会缓存当前的 modCount，然后每次迭代都会进行比较，要是不一致则说明存在别的线程在操作，从而抛出 ConcurrentModificationException 异常\"]},\"281\":{\"h\":\"35. HashTable 和 HashMap\"},\"282\":{\"h\":\"36. HashMap 中的 key 可以使用任何类作为 key 吗？\",\"t\":[\"若类重写了 equals，它也应该重写 hashCode 方法\",\"类的所有实例需要遵守 equals 和 hashCode 相关的规则\",\"如果一个类没有使用 equals，你也不应该在 hashCode 中使用它\"]},\"283\":{\"h\":\"37. HashMap 的长度为什么是 2 的 n 次方\"},\"284\":{\"h\":\"38. HashMap 和 ConcurrentHashMap 的异同？\"},\"285\":{\"h\":\"39. 红黑树\"},\"286\":{\"h\":\"40. 怎么处理异常\"},\"287\":{\"h\":\"总览\"},\"288\":{\"h\":\"云平台搭建\",\"t\":[\"云平台主要采用的技术如下：\",\"名称\",\"简介\",\"Docker\",\"应用容器引擎，从而实现同一应用运行在任何地方\",\"Kubernetes\",\"容器化编排工具，能够实现容器化的集群部署\",\"Rancher\",\"Kubernetes 管理工具，能够快速搭建高可用 Kubernetes 和搭建部分常用服务\",\"Harbor\",\"私有镜像仓库\",\"Jenkins\",\"持续集成工具\"]},\"289\":{\"h\":\"环境准备\"},\"290\":{\"h\":\"1.关闭防火墙\",\"t\":[\"### 停止防火墙 systemctl stop firewalld.service ### 禁止开机启动 systemctl disable firewalld.service \"]},\"291\":{\"h\":\"2.更新 yum\",\"t\":[\"yum update \"]},\"292\":{\"h\":\"3.安装工具\",\"t\":[\"yum install -y yum-utils device-mapper-persistent-data lvm2 \"]},\"293\":{\"h\":\"安装 Docker\",\"t\":[\"### 添加Docker源 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo ### 更新yum yum update -y ### 安装Docker yum install -y docker-ce ### 启动Docker systemctl start docker \"]},\"294\":{\"h\":\"1. 设置开机启动\",\"t\":[\"systemctl enable docker \"]},\"295\":{\"h\":\"2.使用阿里加速\",\"t\":[\"### 使用阿里的容器镜像服务进行加速（个人加速器可更换） ### Linux 加速 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json <<-'EOF' { \\\"registry-mirrors\\\": [\\\"https://q47dgr1i.mirror.aliyuncs.com\\\"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker \"]},\"296\":{\"h\":\"安装 Rancher\",\"t\":[\"### 拉取镜像 sudo docker pull rancher/rancher ### 运行镜像 sudo docker run -d --restart=unless-stopped -p 8080:80 -p 8443:443 --name rancher rancher/rancher \",\"如果映射端口为 80、443 可能会导致无法访问，更换端口即可\"]},\"297\":{\"h\":\"安装 Kubernetes\"},\"298\":{\"h\":\"1.创建集群\",\"t\":[\"添加集群\",\"选择自定义，然后填写创建的配置，点击下一步\",\"添加节点\"]},\"299\":{\"h\":\"2.安装 master\",\"t\":[\"安装 master 节点，需要选择 Control 然后复制执行命令在相应的主机执行命令即可\"]},\"300\":{\"h\":\"3.安装 node\",\"t\":[\"只需要选择 work 然后复制执行命令在相应的主机执行命令即可\"]},\"301\":{\"h\":\"4.笔记本合盖\",\"t\":[\"需要设置合盖不影响，否则盒盖休眠就会影响该节点\"]},\"302\":{\"h\":\"5.主机名\",\"t\":[\"若主机名重复，则可能导致无法做安装节点 若 k8s.master k8s.node 他主机名显示的都为 k8s 导致无法添加\"]},\"303\":{\"h\":\"Rancher-cli 工具使用\",\"t\":[\"linux 下载链接：https://releases.rancher.com/cli2/v2.4.3/rancher-linux-amd64-v2.4.3.tar.gz\",\"window 下载链接：https://releases.rancher.com/cli2/v2.4.3/rancher-windows-386-v2.4.3.zip\",\"MacOS 下载链接：https://releases.rancher.com/cli2/v2.4.3/rancher-darwin-amd64-v2.4.3.tar.gz\"]},\"304\":{\"h\":\"通过 UI 添加 token\"},\"305\":{\"h\":\"使用\",\"t\":[\"## 进入解压包中，使用命令即可登录rancher ./rancher login https://172.22.190.240:8443/v3 -t token-d7sx4:jh2wgcjjnmvq7m9l9rbr8qdw5fr7nrd2bjssjfngmcjrsxncdphf7d \",\"需要下载kubectl工具对kubernetes进行操作\"]},\"306\":{\"h\":\"安装 kubectl\",\"t\":[\"# 1. 配置阿里云源 cat <<EOF > /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 EOF # 2. 开始安装 yum -y install kubectl # 3. 测试 查看节点 ./rancher kubectl get nodes \"]},\"307\":{\"h\":\"安装 Harbor\",\"t\":[\"# 1. 下载安装文件（可以在指定目录下载） wget https://storage.googleapis.com/harbor-releases/harbor-online-installer-v1.5.2.tgz # 2. 解压下载的文件 tar xvf harbor-online-installer-v1.5.2.tgz \"]},\"308\":{\"h\":\"配置 Harbor\",\"t\":[\"1. 修改Harbor的配置文件 cd harbor vim harbor.cfg 内容如下： # hostname设置访问地址，可以使用ip、域名，不可以设置为127.0.0.1或localhost hostname = hub.k8s.com # 访问协议，默认是http，也可以设置https，如果设置https，则nginx ssl需要设置on ui_url_protocol = http # mysql数据库root用户默认密码root123，实际使用时修改下 db_password = root@1234 max_job_workers = 3 customize_crt = on ssl_cert = /data/cert/server.crt ssl_cert_key = /data/cert/server.key secretkey_path = /data admiral_url = NA # 邮件设置，发送重置密码邮件时使用 email_identity = email_server = smtp.mydomain.com email_server_port = 25 email_username = sample_admin@mydomain.com email_password = abc email_from = admin <sample_admin@mydomain.com> email_ssl = false # 启动Harbor后，管理员UI登录的密码，默认是Harbor12345 harbor_admin_password = root@1234 # 认证方式，这里支持多种认证方式，如LADP、本次存储、数据库认证。默认是db_auth，mysql数据库认证 auth_mode = db_auth # LDAP认证时配置项 #ldap_url = ldaps://ldap.mydomain.com #ldap_searchdn = uid=searchuser,ou=people,dc=mydomain,dc=com #ldap_search_pwd = password #ldap_basedn = ou=people,dc=mydomain,dc=com #ldap_filter = (objectClass=person) #ldap_uid = uid #ldap_scope = 3 #ldap_timeout = 5 # 是否开启自注册 self_registration = on # Token有效时间，默认30分钟 token_expiration = 30 # 用户创建项目权限控制，默认是everyone（所有人），也可以设置为adminonly（只能管理员） project_creation_restriction = everyone verify_remote_cert = on \"]},\"309\":{\"h\":\"启动 Harbor\",\"t\":[\"# 1.在当前安装目录下 ./install.sh \"]},\"310\":{\"h\":\"注意\",\"t\":[\"执行 install.sh 报以下错误\",\"root@ubuntu:~/harbor# ./prepare Generated and saved secret to file: /data/secretkey Generated configuration file: ./common/config/nginx/nginx.conf Generated configuration file: ./common/config/adminserver/env Generated configuration file: ./common/config/ui/env Generated configuration file: ./common/config/registry/config.yml Generated configuration file: ./common/config/db/env Generated configuration file: ./common/config/jobservice/env Generated configuration file: ./common/config/jobservice/config.yml Generated configuration file: ./common/config/log/logrotate.conf Generated configuration file: ./common/config/jobservice/config.yml Generated configuration file: ./common/config/ui/app.conf Fail to generate key file: ./common/config/ui/private_key.pem, cert file: ./common/config/registry/root.crt \",\"需要修改 prepare 文件，将第 498 行：\",\"empty_subj = \\\"/C=/ST=/L=/O=/CN=/\\\" \",\"修改如下：\",\"empty_subj = \\\"/C=US/ST=California/L=Palo Alto/O=VMware, Inc./OU=Harbor/CN=notarysigner\\\" \"]},\"311\":{\"h\":\"安装 Jenkins\",\"t\":[\"sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key yum install jenkins ## 启动 systemctl restart jenkins ## 密码 cat /var/lib/jenkins/secrets/initialAdminPassowrd \"]},\"312\":{\"h\":\"提升权限\",\"t\":[\"# 将jenkins账号分别加入到root组中 gpasswd -a root jenkins vi /etc/sysconfig/jenkins # JENKINS_USER=root # JENKINS_GROUP=root ## 重启 service Jenkins restart \"]},\"313\":{\"h\":\"设置环境\",\"t\":[\"## 下载java wget --no-cookies --no-check-certificate --header \\\"Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie\\\" \\\"http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.tar.gz\\\" ## 下载maven wget https://archive.apache.org/dist/maven/maven-3/3.5.0/binaries/apache-maven-3.5.0-bin.tar.gz \"]},\"314\":{\"h\":\"配置 Jenkins 插件工具\",\"t\":[\"Manage Jenkins --- > Global Tool Configure\"]},\"315\":{\"h\":\"设置流水线\",\"t\":[\"新建 Item\",\"选择创建任务的类型和名称\",\"配置源码管理\",\"构建触发器：可设置定时构建、WebHooks 触发构建\",\"构建环境：需要 NodeJs 的可以添加环境，或者直接在脚本中直接通过 node 的位置直接执行\",\"build 命令：可指定文件执行 maven 命令\",\"Post Steps: 可以指定运行脚本等，根据安装的插件可添加很多功能\",\"构建设置：可设置通知\"]},\"316\":{\"h\":\"Kubernetes 部署 Nginx 测试\",\"t\":[\"通过 rancher-cli 进行部署，部署文件的内容：\",\"apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment namespace: \\\"default\\\" labels: app: nginx spec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.12.2 ports: - containerPort: 80 --- apiVersion: v1 kind: Service metadata: name: \\\"test-nginx\\\" namespace: \\\"default\\\" labels: app: \\\"test-nginx\\\" spec: ports: - name: \\\"80\\\" port: 80 targetPort: 80 selector: app: nginx status: loadBalancer: {} --- apiVersion: extensions/v1beta1 kind: Ingress metadata: labels: app: nginx name: test-nginx spec: rules: - host: test-nginx.default.172.22.190.240.xip.io http: paths: - backend: serviceName: test-nginx servicePort: 80 path: / status: loadBalancer: ingress: - ip: 172.22.190.240 \"]},\"317\":{\"h\":\"Jenkins 打包 SpringBoot 镜像测试\"},\"318\":{\"h\":\"设置 Jenkins 流水线\",\"t\":[\"添加源码管理并指定分支\",\"项目中使用到了 NodeJs，添加 NodeJs 构建环境\",\"执行 Maven 命令进行构建打包\",\"执行自定义（deploy）制作镜像-->推送镜像--->部署的脚本\",\"点击应用，保存该流水线。\",\"deploy 内容\",\"#!/bin/bash cd ./contract-parent/contract-server && \\\\ docker build -t 172.22.190.250/library/contract:latest . && \\\\ docker push 172.22.190.250/library/contract:latest && \\\\ /usr/local/bin/rancher kubectl apply -f deployment.yaml && \\\\ cd ../../ && \\\\ cd ./project-parent/project-server && \\\\ docker build -t 172.22.190.250/library/project:latest . && \\\\ docker push 172.22.190.250/library/project:latest && \\\\ /usr/local/bin/rancher kubectl apply -f deployment.yaml && \\\\ cd ../../ && \\\\ cd ./public-data-parent/public-data-server && \\\\ docker build -t 172.22.190.250/library/public-data:latest . && docker push 172.22.190.250/library/public-data:latest && /usr/local/bin/rancher kubectl apply -f deployment.yaml && cd ../../ && \\\\ cd ./omgt-web && rm -rf dest && npm install && \\\\ npm run build && docker build -t 172.22.190.250/library/omgt-web:latest . && \\\\ docker push 172.22.190.250/library/omgt-web:latest && \\\\ /usr/local/bin/rancher kubectl apply -f deployment.yaml && cd ../../ \",\"其中一个 Dockerfile 的内容\",\"FROM anapsix/alpine-java:8_server-jre_unlimited MAINTAINER 961099916@qq.com ENV TZ=Asia/Shanghai RUN ln -sf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone RUN mkdir -p /omgt WORKDIR /omgt EXPOSE 8038 ADD ./target/public-data-server.jar ./ CMD sleep 10;java -Djava.security.egd=file:/dev/./urandom -jar public-data-server.jar >> start.log \",\"其中一个 deployment.yaml 的内容\",\"apiVersion: apps/v1 kind: Deployment metadata: name: public-data-deployment namespace: default labels: app: public-data dept: omgt env: dev spec: replicas: 2 selector: matchLabels: app: public-data dept: omgt env: dev template: metadata: labels: app: public-data dept: omgt env: dev spec: containers: - name: omgt-public-data image: 172.22.190.250/library/public-data:latest imagePullPolicy: Always ports: - containerPort: 8038 --- apiVersion: v1 kind: Service metadata: name: public-data-service namespace: default labels: app: public-data dept: omgt env: dev spec: ports: - name: \\\"8038\\\" port: 8038 targetPort: 8038 selector: app: public-data dept: omgt env: dev status: loadBalancer: {} --- apiVersion: extensions/v1beta1 kind: Ingress metadata: labels: app: public-data dept: omgt name: public-data-ingress spec: rules: - host: public-data-ingress.default.172.22.190.240.xip.io http: paths: - backend: serviceName: public-data-service servicePort: 8038 path: / status: loadBalancer: ingress: - ip: 172.22.190.240 \"]},\"319\":{\"h\":\"查看打包过程\",\"t\":[\"点击 Build Now 运行流水线\",\"点击历史可进入正在运行的流水线\",\"通过控制台进行查看流水线日志\"]},\"320\":{\"h\":\"查看 Kubernetes 集群中是否部署成功\",\"t\":[\"查看指定的命名空间和服务名称\"]},\"321\":{\"h\":\"后记\",\"t\":[\"部署文件的编写可能需要学习 Kubernetes 才能编写，而次次重新编写可能过于麻烦，可通过cookiecutter进行模板化生成\"]},\"322\":{\"h\":\"1.安装 cookiecutter\",\"t\":[\"pip install cookiecutter \"]},\"323\":{\"h\":\"2.编写配置文件\",\"t\":[\"# 创建文件 mkdir cookiecutter.json \",\"cookiecutter 内容如下：\",\"{ \\\"project\\\": \\\"kubernetes\\\", \\\"dept\\\": \\\"omgt\\\", \\\"env\\\": \\\"dev\\\", \\\"namespace\\\": \\\"default\\\", \\\"app_name\\\": \\\"nginx\\\", \\\"app_port\\\": \\\"8080\\\", \\\"app_replicas\\\": \\\"1\\\", \\\"app_image\\\": \\\"nginx\\\", \\\"app_image_version\\\": \\\"latest\\\", \\\"lbip\\\": \\\"192.168.1.3\\\" } \"]},\"324\":{\"h\":\"3.创建模版文件\",\"t\":[\"mkdir {{cookiecutter.project}} touch default_dev.yaml \",\"default_dev.yaml 内容如下：\",\"apiVersion: apps/v1 kind: Deployment metadata: name: {{cookiecutter.app_name}}-deployment namespace: {{cookiecutter.namespace}} labels: app: {{cookiecutter.app_name}} dept: {{cookiecutter.dept}} env: {{cookiecutter.env}} spec: replicas: {{cookiecutter.app_replicas}} selector: matchLabels: app: {{cookiecutter.app_name}} dept: {{cookiecutter.dept}} env: {{cookiecutter.env}} template: metadata: labels: app: {{cookiecutter.app_name}} dept: {{cookiecutter.dept}} env: {{cookiecutter.env}} spec: containers: - name: nginx image: {{cookiecutter.app_image}}:{{cookiecutter.app_image_version}} ports: - containerPort: {{cookiecutter.app_port}} --- apiVersion: v1 kind: Service metadata: name: {{cookiecutter.app_name}}-service namespace: {{cookiecutter.namespace}} labels: app: {{cookiecutter.app_name}} dept: {{cookiecutter.dept}} env: {{cookiecutter.env}} spec: ports: - name: \\\"{{cookiecutter.app_port}}\\\" port: {{cookiecutter.app_port}} targetPort: {{cookiecutter.app_port}} selector: app: {{cookiecutter.app_name}} dept: {{cookiecutter.dept}} env: {{cookiecutter.env}} status: loadBalancer: {} --- apiVersion: extensions/v1beta1 kind: Ingress metadata: labels: app: {{cookiecutter.app_name}} dept: {{cookiecutter.dept}} name: {{cookiecutter.app_name}}-ingress spec: rules: - host: {{cookiecutter.app_name}}-ingress.{{cookiecutter.namespace}}.{{cookiecutter.lbip}}.xip.io http: paths: - backend: serviceName: {{cookiecutter.app_name}}-service servicePort: {{cookiecutter.app_port}} path: / status: loadBalancer: ingress: - ip: {{cookiecutter.lbip}} \"]},\"325\":{\"h\":\"Spring 整体架构\"},\"326\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"327\":{\"h\":\"中间件\"},\"328\":{\"h\":\"数据库\"},\"329\":{\"h\":\"框架\"},\"330\":{\"h\":\"算法\"},\"331\":{\"h\":\"运维\"},\"332\":{\"h\":\"通用\"}},\"dirtCount\":0,\"index\":[[\"运维\",{\"0\":{\"331\":1}}],[\"运行流水线\",{\"1\":{\"319\":1}}],[\"运行镜像\",{\"1\":{\"296\":1}}],[\"运行至消亡的过程\",{\"1\":{\"271\":1}}],[\"运行高效\",{\"1\":{\"208\":1}}],[\"运行时异常\",{\"1\":{\"269\":1}}],[\"运行时数据区\",{\"0\":{\"197\":1},\"1\":{\"197\":1}}],[\"运行时通过代码里标识的元数据动态处理\",{\"1\":{\"24\":1}}],[\"运行时动态处理\",{\"1\":{\"24\":1}}],[\"运行时多态有三个条件\",{\"1\":{\"4\":1}}],[\"运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定\",{\"1\":{\"4\":1}}],[\"框架\",{\"0\":{\"329\":1}}],[\"框架中经常使用\",{\"1\":{\"275\":1}}],[\"编写配置文件\",{\"0\":{\"323\":1}}],[\"编译后是用\",{\"1\":{\"249\":1}}],[\"编译新生成的\",{\"1\":{\"219\":1}}],[\"编译为\",{\"1\":{\"186\":1}}],[\"编译器会检查\",{\"1\":{\"250\":1}}],[\"编译器会在写入时插入一个\",{\"1\":{\"264\":1}}],[\"编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序\",{\"1\":{\"174\":1}}],[\"编译器会在final域写之后\",{\"1\":{\"156\":1}}],[\"编译器的发展和逃逸分析技术的逐渐成熟\",{\"1\":{\"197\":1,\"202\":1}}],[\"编译器和处理器会对指令进行重排序\",{\"1\":{\"171\":1}}],[\"编译器和处理器常常会对指令做重排序\",{\"1\":{\"92\":1}}],[\"编译器在生成字节码时\",{\"1\":{\"174\":1}}],[\"编译器在生成指令序列时\",{\"1\":{\"92\":1}}],[\"编译器在不改变单线程程序语义的前提下\",{\"1\":{\"92\":1}}],[\"编译器优化的重排序\",{\"1\":{\"92\":1}}],[\"编译程序优化指令执行次序\",{\"1\":{\"88\":1}}],[\"编译程序都做出了贡献\",{\"1\":{\"88\":1}}],[\"编译时通过代码里标识的元数据动态处理\",{\"1\":{\"24\":1}}],[\"编译时动态处理\",{\"1\":{\"24\":1}}],[\"编译时多态主要指方法的重载\",{\"1\":{\"4\":1}}],[\"编译检查\",{\"1\":{\"24\":1}}],[\"编译阶段无法判定类型\",{\"1\":{\"22\":1}}],[\"编译期没法确定泛型参数化类型\",{\"1\":{\"21\":1}}],[\"编译错误\",{\"1\":{\"15\":3}}],[\"集群中是否部署成功\",{\"0\":{\"320\":1}}],[\"集合在操作的时候\",{\"1\":{\"280\":1}}],[\"集合的一种错误机制\",{\"1\":{\"280\":1}}],[\"集合\",{\"0\":{\"179\":1}}],[\"集合元素数据\",{\"1\":{\"74\":1}}],[\"集合树化的最小元素个数\",{\"1\":{\"74\":1}}],[\"集合将为空\",{\"1\":{\"47\":1}}],[\"集合框架是每一个入门开发者必会的内容\",{\"1\":{\"46\":1}}],[\"$tz\",{\"1\":{\"318\":2}}],[\"保存该流水线\",{\"1\":{\"318\":1}}],[\"保证了\",{\"1\":{\"201\":1}}],[\"保证原子性\",{\"0\":{\"167\":1}}],[\"点击历史可进入正在运行的流水线\",{\"1\":{\"319\":1}}],[\"点击\",{\"1\":{\"319\":1}}],[\"点击应用\",{\"1\":{\"318\":1}}],[\"点击下一步\",{\"1\":{\"298\":1}}],[\"制作镜像\",{\"1\":{\"318\":1}}],[\"项目中使用到了\",{\"1\":{\"318\":1}}],[\"镜像测试\",{\"0\":{\"317\":1}}],[\"打包\",{\"0\":{\"317\":1}}],[\"部署文件的编写可能需要学习\",{\"1\":{\"321\":1}}],[\"部署文件的内容\",{\"1\":{\"316\":1}}],[\"部署\",{\"0\":{\"316\":1}}],[\"命令进行构建打包\",{\"1\":{\"318\":1}}],[\"命令\",{\"1\":{\"315\":2}}],[\"触发构建\",{\"1\":{\"315\":1}}],[\"构建设置\",{\"1\":{\"315\":1}}],[\"构建环境\",{\"1\":{\"315\":1,\"318\":1}}],[\"构建触发器\",{\"1\":{\"315\":1}}],[\"构造函数返回前插入一个storestore屏障\",{\"1\":{\"162\":1}}],[\"构造函数return之前\",{\"1\":{\"156\":1}}],[\"构造函数执行结束\",{\"1\":{\"97\":1,\"264\":1}}],[\"构造方法可以传入初始容量和扩容自增的数量\",{\"1\":{\"62\":1}}],[\"构造方法\",{\"0\":{\"50\":1,\"56\":1,\"62\":1,\"230\":1},\"1\":{\"275\":1}}],[\"构造方法不能被重写\",{\"1\":{\"6\":1}}],[\"选择创建任务的类型和名称\",{\"1\":{\"315\":1}}],[\"选择自定义\",{\"1\":{\"298\":1}}],[\"插件工具\",{\"0\":{\"314\":1}}],[\"插入一条内存屏障会告诉编译器和\",{\"1\":{\"171\":1}}],[\"插入一个storestore屏障\",{\"1\":{\"156\":1}}],[\"插入特定类型的内存屏障\",{\"1\":{\"92\":1}}],[\"密码\",{\"1\":{\"311\":1}}],[\"行\",{\"1\":{\"310\":1}}],[\"~\",{\"1\":{\"310\":1}}],[\"报以下错误\",{\"1\":{\"310\":1}}],[\"认证方式\",{\"1\":{\"308\":1}}],[\"启动\",{\"0\":{\"309\":1},\"1\":{\"311\":1}}],[\"启动harbor后\",{\"1\":{\"308\":1}}],[\"启动docker\",{\"1\":{\"293\":1}}],[\"发送重置密码邮件时使用\",{\"1\":{\"308\":1}}],[\"发现一个最优布置来最小化插入屏障的总数几乎是不可能的\",{\"1\":{\"174\":1}}],[\"邮件设置\",{\"1\":{\"308\":1}}],[\"修改如下\",{\"1\":{\"310\":1}}],[\"修改harbor的配置文件\",{\"1\":{\"308\":1}}],[\"修饰的变量值在被反序列化是也不会被持久化和回复\",{\"1\":{\"272\":1}}],[\"修饰的类不可被继承\",{\"1\":{\"264\":1}}],[\"修饰的字符数组\",{\"1\":{\"255\":1}}],[\"修饰的\",{\"1\":{\"229\":1}}],[\"修饰变量\",{\"0\":{\"153\":1}}],[\"修饰参数\",{\"0\":{\"152\":1}}],[\"修饰方法\",{\"0\":{\"151\":1}}],[\"修饰类\",{\"0\":{\"150\":1}}],[\"zoneinfo\",{\"1\":{\"318\":1}}],[\"zip\",{\"1\":{\"303\":1}}],[\"zero\",{\"1\":{\"243\":1}}],[\"他主机名显示的都为\",{\"1\":{\"302\":1}}],[\"他的原理是对指定的目标类生成一个子类\",{\"1\":{\"226\":1}}],[\"主机名\",{\"0\":{\"302\":1}}],[\"主要\",{\"1\":{\"190\":1}}],[\"主要有三种\",{\"1\":{\"127\":1}}],[\"主要体现为\",{\"1\":{\"88\":1}}],[\"主要是被框架的开发人员使用\",{\"1\":{\"43\":1}}],[\"笔记本合盖\",{\"0\":{\"301\":1}}],[\"节点\",{\"1\":{\"299\":1}}],[\"节点流\",{\"1\":{\"273\":1}}],[\"拉取镜像\",{\"1\":{\"296\":1}}],[\"拉链法\",{\"1\":{\"262\":1}}],[\"qq\",{\"1\":{\"318\":1}}],[\"q47dgr1i\",{\"1\":{\"295\":1}}],[\"queue\",{\"0\":{\"81\":1}}],[\"安装docker\",{\"1\":{\"293\":1}}],[\"安装\",{\"0\":{\"293\":1,\"296\":1,\"297\":1,\"299\":1,\"300\":1,\"306\":1,\"307\":1,\"311\":1,\"322\":1},\"1\":{\"299\":1}}],[\"安装工具\",{\"0\":{\"292\":1}}],[\"yaml\",{\"1\":{\"318\":5,\"324\":2}}],[\"yml\",{\"1\":{\"310\":3}}],[\"y\",{\"1\":{\"292\":1,\"293\":2,\"306\":1}}],[\"yum\",{\"0\":{\"291\":1},\"1\":{\"291\":1,\"292\":2,\"293\":3,\"306\":3,\"311\":2}}],[\"yield\",{\"0\":{\"130\":1},\"1\":{\"130\":1}}],[\"停止防火墙\",{\"1\":{\"290\":1}}],[\"环境准备\",{\"0\":{\"289\":1}}],[\"持续集成工具\",{\"1\":{\"288\":1}}],[\"持续复制长生存期的对象则导致效率降低\",{\"1\":{\"208\":1}}],[\"私有镜像仓库\",{\"1\":{\"288\":1}}],[\"容器化编排工具\",{\"1\":{\"288\":1}}],[\"云平台主要采用的技术如下\",{\"1\":{\"288\":1}}],[\"云平台搭建\",{\"0\":{\"288\":1}}],[\"总览\",{\"0\":{\"287\":1}}],[\"总是认为只要不去做正确的同步措施\",{\"1\":{\"108\":1}}],[\"怎么处理异常\",{\"0\":{\"286\":1}}],[\"红黑树\",{\"0\":{\"285\":1}}],[\"你也不应该在\",{\"1\":{\"282\":1}}],[\"你遇到过那些情况\",{\"0\":{\"270\":1}}],[\"你遇到过哪些情况\",{\"0\":{\"270\":1}}],[\"吗\",{\"0\":{\"282\":1}}],[\"存在数组了为什么还要\",{\"0\":{\"279\":1}}],[\"存活的极端情况\",{\"1\":{\"208\":1}}],[\"键值对存储\",{\"1\":{\"276\":1}}],[\"破换了封装性\",{\"1\":{\"275\":1}}],[\"能够快速搭建高可用\",{\"1\":{\"288\":1}}],[\"能够实现容器化的集群部署\",{\"1\":{\"288\":1}}],[\"能够运行时动态获取类的实例\",{\"1\":{\"275\":1}}],[\"能够让两个或以上的线程同时并行执行\",{\"1\":{\"143\":1}}],[\"哪里用到\",{\"1\":{\"275\":1}}],[\"另一套就是网络编程\",{\"1\":{\"274\":1}}],[\"另外\",{\"1\":{\"209\":1}}],[\"另外一个是空间问题\",{\"1\":{\"208\":1}}],[\"另外可以通过synchronized和lock来保证有序性\",{\"1\":{\"100\":1}}],[\"高很多\",{\"1\":{\"274\":1}}],[\"处理流\",{\"1\":{\"273\":1}}],[\"处理器会在读final域操作的前面插入一个loadload屏障\",{\"1\":{\"157\":1}}],[\"处理器可以改变语句对应机器指令的执行顺序\",{\"1\":{\"92\":1}}],[\"输出\",{\"1\":{\"273\":1}}],[\"输入\",{\"1\":{\"273\":1}}],[\"输入输出设备的使用权等等\",{\"1\":{\"271\":1}}],[\"流水线\",{\"0\":{\"318\":1}}],[\"流\",{\"0\":{\"273\":1}}],[\"阻止实例化中那些用此关键字修饰的变量序列化\",{\"1\":{\"272\":1}}],[\"阻塞和\",{\"1\":{\"132\":1}}],[\"阻塞和等待的区别在于\",{\"1\":{\"122\":1}}],[\"阻塞是被动的\",{\"1\":{\"122\":1}}],[\"阻塞\",{\"0\":{\"120\":1}}],[\"某些字段不行序列化怎么办\",{\"0\":{\"272\":1}}],[\"系统运行一个程序及时一个进程从创建\",{\"1\":{\"271\":1}}],[\"含有指令和数据的文件\",{\"1\":{\"271\":1}}],[\"含有参数的构造方法\",{\"1\":{\"52\":1}}],[\"负担要比进程小得多\",{\"1\":{\"271\":1}}],[\"负载因子\",{\"1\":{\"74\":1}}],[\"简介\",{\"1\":{\"288\":1}}],[\"简单来说\",{\"1\":{\"271\":1}}],[\"简单易学\",{\"1\":{\"247\":1}}],[\"简述线程\",{\"0\":{\"271\":1}}],[\"错误\",{\"1\":{\"269\":1}}],[\"检查时异常\",{\"1\":{\"269\":1}}],[\"检测是否为空时未检测对象是否为\",{\"1\":{\"239\":1}}],[\"前会执行\",{\"1\":{\"268\":1}}],[\"前提锁对象得是同一个对象或者class\",{\"1\":{\"146\":1}}],[\"还会执行吗\",{\"0\":{\"268\":1}}],[\"里面有\",{\"0\":{\"268\":1}}],[\"里面的key为string\",{\"1\":{\"11\":1}}],[\"里面的var类型为string类型\",{\"1\":{\"11\":1}}],[\"静态导包\",{\"1\":{\"265\":1}}],[\"静态代码快\",{\"1\":{\"265\":1}}],[\"静态方法\",{\"1\":{\"265\":1}}],[\"静态常量\",{\"1\":{\"265\":1}}],[\"静态变量\",{\"1\":{\"197\":1,\"201\":1}}],[\"域名\",{\"1\":{\"308\":1}}],[\"域时进行过度的指令重排序\",{\"1\":{\"264\":1}}],[\"域时会插入\",{\"1\":{\"264\":1}}],[\"域\",{\"1\":{\"264\":2}}],[\"域的对象的引用\",{\"1\":{\"264\":1}}],[\"域的读\",{\"0\":{\"173\":1}}],[\"域的写入\",{\"1\":{\"264\":1}}],[\"域的写\",{\"0\":{\"173\":1}}],[\"遵守两个重排序规则\",{\"1\":{\"264\":1}}],[\"浅拷贝\",{\"1\":{\"263\":1}}],[\"深度拷贝也需要实现\",{\"1\":{\"277\":1}}],[\"深拷贝\",{\"1\":{\"263\":1}}],[\"深拷贝和浅拷贝\",{\"0\":{\"263\":1}}],[\"深入的学习是十分有必要的\",{\"1\":{\"46\":1}}],[\"深入理解异常\",{\"0\":{\"37\":1}}],[\"深入理解注解\",{\"0\":{\"28\":1}}],[\"深入理解泛型\",{\"0\":{\"16\":1}}],[\"第三个\",{\"1\":{\"262\":1}}],[\"第一个是\",{\"1\":{\"135\":1}}],[\"第一次添加是会给\",{\"1\":{\"58\":1}}],[\"第一次则按照\",{\"1\":{\"52\":1}}],[\"第一次扩容时\",{\"1\":{\"52\":1}}],[\"哈希函数结果冲突就在用第二个\",{\"1\":{\"262\":1}}],[\"又叫双哈希\",{\"1\":{\"262\":1}}],[\"又称内存栅栏\",{\"1\":{\"171\":1}}],[\"空的散列地��总能找到\",{\"1\":{\"262\":1}}],[\"空间碎片太多可能会导致\",{\"1\":{\"208\":1}}],[\"开放定址法\",{\"1\":{\"262\":1}}],[\"开始安装\",{\"1\":{\"306\":1}}],[\"开始位置\",{\"1\":{\"244\":1}}],[\"开始和结束的位置进行创建\",{\"1\":{\"234\":1}}],[\"开始事务\",{\"1\":{\"218\":2,\"221\":2}}],[\"克隆方法\",{\"1\":{\"277\":1}}],[\"克隆\",{\"1\":{\"261\":1}}],[\"虚引用\",{\"1\":{\"259\":1}}],[\"虚拟机中没有提供\",{\"1\":{\"249\":1}}],[\"虚拟机中内存最大的一块\",{\"1\":{\"197\":1,\"202\":1}}],[\"虚拟机堆转储快照分析工具\",{\"1\":{\"214\":1}}],[\"虚拟机统计信息监控工具\",{\"1\":{\"214\":1}}],[\"虚拟机进程状况工具\",{\"1\":{\"214\":1}}],[\"虚拟机会根据当前系统的运行情况收集性能监控信息\",{\"1\":{\"209\":1}}],[\"虚拟机会把类的二级制数据中的符号引用替换为直接引用\",{\"1\":{\"195\":1}}],[\"虚拟机为例讲解\",{\"1\":{\"201\":1}}],[\"虚拟机为类的静态变量分配内存\",{\"1\":{\"194\":1}}],[\"虚拟机栈中引用的对象\",{\"1\":{\"207\":1}}],[\"虚拟机栈\",{\"0\":{\"198\":1},\"1\":{\"197\":1}}],[\"虚拟机安全地执行\",{\"1\":{\"193\":1}}],[\"虚拟机上运行的目标代码\",{\"1\":{\"185\":1}}],[\"虚拟机包括一套字节码指令集\",{\"1\":{\"185\":1}}],[\"虚拟机\",{\"1\":{\"185\":1}}],[\"弱引用\",{\"1\":{\"259\":1}}],[\"软引用\",{\"1\":{\"259\":1}}],[\"强引用\",{\"1\":{\"259\":1}}],[\"效率要比\",{\"1\":{\"274\":1}}],[\"效率较低\",{\"1\":{\"255\":1}}],[\"效率将会变低\",{\"1\":{\"208\":1}}],[\"961099916\",{\"1\":{\"318\":1}}],[\"9\",{\"0\":{\"255\":1}}],[\"作用\",{\"0\":{\"254\":1}}],[\"访问协议\",{\"1\":{\"308\":1}}],[\"访问修饰权限不�����小于父类\",{\"1\":{\"252\":1}}],[\"访问权限不能比父类中被重写的方法的访问权限更低\",{\"1\":{\"6\":1}}],[\"拆箱\",{\"1\":{\"251\":1}}],[\"装箱\",{\"1\":{\"251\":1}}],[\"双目运算符\",{\"1\":{\"250\":1}}],[\"双亲委派\",{\"1\":{\"190\":2}}],[\"个人加速器可更换\",{\"1\":{\"295\":1}}],[\"个字节\",{\"1\":{\"249\":2}}],[\"个操作数\",{\"1\":{\"110\":1}}],[\"八种基本数据类型的大小\",{\"0\":{\"249\":1}}],[\"易扩展\",{\"1\":{\"248\":1}}],[\"易复用\",{\"1\":{\"248\":1}}],[\"嵌入式开发等一般采用面向过程开发\",{\"1\":{\"248\":1}}],[\"支持多线程\",{\"1\":{\"247\":1}}],[\"跨平台的根本\",{\"1\":{\"247\":1}}],[\"让程序耦合度更低\",{\"1\":{\"247\":1}}],[\"让其使用更加方便和简单\",{\"1\":{\"49\":1}}],[\"循环比较是否相等\",{\"1\":{\"244\":1}}],[\"循环比较\",{\"1\":{\"243\":1}}],[\"找出长度最短的字符串长度\",{\"1\":{\"243\":1}}],[\"长度是否相同\",{\"1\":{\"242\":1}}],[\"忽略大小写比较是否相等\",{\"0\":{\"242\":1}}],[\"配合字符组长度创建对象\",{\"1\":{\"235\":1}}],[\"配置源码管理\",{\"1\":{\"315\":1}}],[\"配置\",{\"0\":{\"308\":1,\"314\":1}}],[\"配置阿里云源\",{\"1\":{\"306\":1}}],[\"配置信息工具\",{\"1\":{\"214\":1}}],[\"配置文件中有接口的具体实现类名\",{\"1\":{\"43\":1}}],[\"传入的字符组\",{\"1\":{\"244\":1}}],[\"传入字节组\",{\"1\":{\"234\":1}}],[\"传递性\",{\"1\":{\"97\":1,\"264\":1}}],[\"7\",{\"0\":{\"253\":1}}],[\"7的时候\",{\"1\":{\"227\":1}}],[\"75\",{\"1\":{\"74\":1}}],[\"75f\",{\"1\":{\"74\":1}}],[\"经过多次试验\",{\"1\":{\"227\":1}}],[\"网上有人对于不通版本的jdk进行测试\",{\"1\":{\"227\":1}}],[\"各自局限\",{\"0\":{\"226\":1}}],[\"面向过程\",{\"1\":{\"248\":1}}],[\"面向\",{\"0\":{\"224\":1}}],[\"面向对象有封装\",{\"1\":{\"248\":1}}],[\"面向对象和面向过程的区别\",{\"0\":{\"248\":1}}],[\"面向对象\",{\"0\":{\"1\":1},\"1\":{\"247\":1,\"248\":1}}],[\"利用asm开源包\",{\"1\":{\"223\":1}}],[\"利用抽象数据类型将数据和基于数据的操作封装在一起\",{\"1\":{\"2\":1}}],[\"核心是通过重写被代理对象所实现的接口中的方法来重新生成代理类来实现的\",{\"1\":{\"223\":1}}],[\"核心重写\",{\"1\":{\"6\":1}}],[\"把新加的业务逻辑方法由一定的逻辑代码去调用\",{\"1\":{\"219\":1}}],[\"把java堆分为新生代和老年代\",{\"1\":{\"208\":1}}],[\"代码\",{\"1\":{\"219\":2}}],[\"代理的类\",{\"1\":{\"221\":1}}],[\"代理的对象类\",{\"1\":{\"218\":1}}],[\"代理的接口\",{\"1\":{\"218\":1}}],[\"代理对象在客户端和目标对象之间起到中介作用\",{\"1\":{\"216\":1}}],[\"代理模式\",{\"1\":{\"216\":1}}],[\"代理\",{\"0\":{\"215\":1,\"220\":1}}],[\"拿到被代理对象的引用\",{\"1\":{\"219\":1}}],[\"结果\",{\"1\":{\"218\":1,\"221\":1}}],[\"结束事务\",{\"1\":{\"218\":2,\"221\":2}}],[\"创建模版文件\",{\"0\":{\"324\":1}}],[\"创建文件\",{\"1\":{\"323\":1}}],[\"创建集群\",{\"0\":{\"298\":1}}],[\"创建对象\",{\"1\":{\"261\":1}}],[\"创建对象的方式\",{\"0\":{\"261\":1}}],[\"创建代理类\",{\"1\":{\"218\":1,\"221\":1}}],[\"创建后尚未启动\",{\"1\":{\"118\":1}}],[\"允许开发者在运行期创建接口的代理实例\",{\"1\":{\"217\":1}}],[\"给某一个对象提供一个代理\",{\"1\":{\"216\":1}}],[\"调优\",{\"0\":{\"213\":1}}],[\"调用该对象的其他方法\",{\"1\":{\"234\":1}}],[\"调用\",{\"1\":{\"122\":2,\"134\":1,\"138\":1,\"191\":1}}],[\"调用者都不需要任何额外的同步措施\",{\"1\":{\"103\":1}}],[\"适用于后台持久运行的应用程序\",{\"1\":{\"209\":1}}],[\"适应性自旋锁\",{\"0\":{\"143\":1}}],[\"年老代默认使用serial\",{\"1\":{\"209\":1}}],[\"年龄\",{\"1\":{\"11\":1}}],[\"组合7\",{\"1\":{\"209\":1}}],[\"组合6\",{\"1\":{\"209\":1}}],[\"组合5\",{\"1\":{\"209\":1}}],[\"组合4\",{\"1\":{\"209\":1}}],[\"组合3\",{\"1\":{\"209\":1}}],[\"组合2\",{\"1\":{\"209\":1}}],[\"组合1\",{\"1\":{\"209\":1}}],[\"特点就是gc时暂停所有应用线程\",{\"1\":{\"209\":1}}],[\"特定类型的编译器重排序和处理器重排序\",{\"1\":{\"171\":1}}],[\"老年老代gc策略\",{\"1\":{\"209\":1}}],[\"老年代串行\",{\"1\":{\"209\":1}}],[\"老年代标记\",{\"1\":{\"209\":3}}],[\"老年代使用串行回收\",{\"1\":{\"209\":1}}],[\"老年代\",{\"1\":{\"202\":2}}],[\"希望系统停顿时间最短\",{\"1\":{\"209\":1}}],[\"收集器是一种以获取最短回收停顿时间为目标的收集器\",{\"1\":{\"209\":1}}],[\"收集器\",{\"1\":{\"209\":1}}],[\"动态生成\",{\"1\":{\"219\":1}}],[\"动态地将横切逻辑和业务逻辑编织在一起\",{\"1\":{\"217\":1}}],[\"动态代理\",{\"0\":{\"217\":1}}],[\"动态代理和\",{\"0\":{\"215\":1}}],[\"动态调整这些参数以提供最合适的停顿时间或最大的吞吐量\",{\"1\":{\"209\":1}}],[\"动态链接\",{\"1\":{\"197\":1,\"198\":1}}],[\"压缩\",{\"1\":{\"209\":3}}],[\"压缩算法\",{\"1\":{\"208\":1}}],[\"最重要的特性\",{\"1\":{\"247\":1}}],[\"最稳定以及效率高的收集器\",{\"1\":{\"209\":1}}],[\"最常采用的是cas算法\",{\"1\":{\"142\":1}}],[\"最常用的地方就是构造器的重载\",{\"1\":{\"7\":1}}],[\"串行收集器是最古老\",{\"1\":{\"209\":1}}],[\"整体架构\",{\"0\":{\"325\":1}}],[\"整体的吞吐效率高\",{\"1\":{\"145\":1}}],[\"整理\",{\"1\":{\"208\":1,\"209\":1}}],[\"算法\",{\"0\":{\"330\":1},\"1\":{\"209\":1}}],[\"算法来进行回收\",{\"1\":{\"208\":1}}],[\"算法一样\",{\"1\":{\"208\":1}}],[\"算法分为\",{\"1\":{\"208\":1}}],[\"按照角色\",{\"1\":{\"273\":1}}],[\"按照操作单元\",{\"1\":{\"273\":1}}],[\"按照流向\",{\"1\":{\"273\":1}}],[\"按照final修饰的数据类型分类\",{\"1\":{\"161\":1}}],[\"按顺序分配内存即可\",{\"1\":{\"208\":1}}],[\"更换端口即可\",{\"1\":{\"296\":1}}],[\"更新yum\",{\"1\":{\"293\":1}}],[\"更新\",{\"0\":{\"291\":1}}],[\"更关键的是\",{\"1\":{\"208\":1}}],[\"更加易于理解和维护\",{\"1\":{\"9\":1}}],[\"复制算法\",{\"1\":{\"208\":1}}],[\"之所以说它是最基础的收集算法\",{\"1\":{\"208\":1}}],[\"首先标记出所有需要回收的对象\",{\"1\":{\"208\":1}}],[\"两个阶段\",{\"1\":{\"208\":1}}],[\"清理\",{\"1\":{\"208\":1}}],[\"清除\",{\"1\":{\"208\":2}}],[\"清除算法\",{\"1\":{\"208\":1}}],[\"清空元素\",{\"1\":{\"73\":1}}],[\"搜索所走过的路径称为引用链\",{\"1\":{\"207\":1}}],[\"计算得出结束位置\",{\"1\":{\"244\":1}}],[\"计算机体系结构\",{\"1\":{\"88\":1}}],[\"计数为0时可以回收\",{\"1\":{\"207\":1}}],[\"垃圾收集的过程中会stop\",{\"1\":{\"209\":1}}],[\"垃圾收集算法\",{\"0\":{\"208\":1}}],[\"垃圾收集器\",{\"0\":{\"209\":1},\"1\":{\"206\":1}}],[\"垃圾回收器\",{\"0\":{\"206\":1}}],[\"性能较高\",{\"1\":{\"248\":1}}],[\"性能对比\",{\"0\":{\"227\":1}}],[\"性能\",{\"1\":{\"205\":1}}],[\"解压下载的文件\",{\"1\":{\"307\":1}}],[\"解决方法\",{\"1\":{\"262\":1}}],[\"解释器\",{\"0\":{\"204\":1}}],[\"解析\",{\"0\":{\"195\":1}}],[\"区别\",{\"0\":{\"255\":1}}],[\"区\",{\"1\":{\"202\":1}}],[\"区和survivor\",{\"1\":{\"202\":1}}],[\"幸存者\",{\"1\":{\"202\":1}}],[\"伊甸园\",{\"1\":{\"202\":1}}],[\"承载着操作系统和应用程序的实时运行\",{\"1\":{\"201\":1}}],[\"独立存储\",{\"1\":{\"200\":1}}],[\"独享锁也叫排他锁\",{\"1\":{\"147\":1}}],[\"独享锁\",{\"0\":{\"147\":1}}],[\"跳转\",{\"1\":{\"200\":1}}],[\"标记过程仍然与\",{\"1\":{\"208\":1}}],[\"标记清除之后会产生大量不连续的内存碎片\",{\"1\":{\"208\":1}}],[\"标记和清除过程的效率都不高\",{\"1\":{\"208\":1}}],[\"标记\",{\"1\":{\"208\":6,\"209\":1}}],[\"标量替换优化的技术将会导致一些微妙的变化\",{\"1\":{\"197\":1,\"202\":1}}],[\"标明要忽略的警告\",{\"1\":{\"24\":1}}],[\"标明某个类或方法过时\",{\"1\":{\"24\":1}}],[\"栈上分配\",{\"1\":{\"197\":1,\"202\":1}}],[\"随着\",{\"1\":{\"197\":1,\"202\":1}}],[\"随着硬件指令集的发展\",{\"1\":{\"110\":1}}],[\"几乎所有的对象实例都在这里分配内存\",{\"1\":{\"197\":1,\"202\":1}}],[\"堆栈跟踪工具\",{\"1\":{\"214\":1}}],[\"堆内存的分配\",{\"1\":{\"202\":1}}],[\"堆唯一的目的就是存放对象实例\",{\"1\":{\"197\":1,\"202\":1}}],[\"堆\",{\"0\":{\"202\":1},\"1\":{\"197\":1}}],[\"常见问题\",{\"0\":{\"245\":1}}],[\"常用方法\",{\"0\":{\"237\":1}}],[\"常量\",{\"1\":{\"197\":1,\"201\":1}}],[\"常常用\",{\"1\":{\"122\":2}}],[\"常常被代码生成工具使用\",{\"1\":{\"26\":1}}],[\"否\",{\"1\":{\"197\":3}}],[\"否则盒盖休眠就会影响该节点\",{\"1\":{\"301\":1}}],[\"否则抛出\",{\"1\":{\"277\":1}}],[\"否则会在运行时抛出\",{\"1\":{\"138\":1}}],[\"否则不会被分配\",{\"1\":{\"121\":1}}],[\"否则采取补偿措施\",{\"1\":{\"110\":1}}],[\"本次存储\",{\"1\":{\"308\":1}}],[\"本文只是为了演示\",{\"1\":{\"217\":1}}],[\"本地方法栈中jni引用的对象\",{\"1\":{\"207\":1}}],[\"本地方法栈\",{\"0\":{\"199\":1},\"1\":{\"197\":1}}],[\"本人结合源码和网络上的相关文章进行了总结\",{\"1\":{\"46\":1}}],[\"名称\",{\"1\":{\"197\":1,\"288\":1}}],[\"除了八种基础类型外都是封装类型\",{\"1\":{\"249\":1}}],[\"除了类的信息外\",{\"1\":{\"196\":1}}],[\"除了声明为\",{\"1\":{\"6\":1}}],[\"准备\",{\"0\":{\"194\":1}}],[\"二级制兼容性的验证\",{\"1\":{\"193\":1}}],[\"语言有哪些特点\",{\"0\":{\"247\":1}}],[\"语言的语法规定\",{\"1\":{\"193\":1}}],[\"语言天生就具备多线程特性\",{\"1\":{\"106\":1}}],[\"语义检查的错误在编译器编译阶段就会通不过\",{\"1\":{\"193\":1}}],[\"语义检查\",{\"1\":{\"193\":1}}],[\"确保相互引用的类之间的协调一致\",{\"1\":{\"193\":1}}],[\"确保字节码流可以被\",{\"1\":{\"193\":1}}],[\"确保类本身符合\",{\"1\":{\"193\":1}}],[\"确保类文件遵从\",{\"1\":{\"193\":1}}],[\"确保数据不会被别的线程修改\",{\"1\":{\"142\":1}}],[\"验证\",{\"0\":{\"193\":1}}],[\"连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去\",{\"1\":{\"192\":1}}],[\"连接阶段\",{\"1\":{\"192\":1}}],[\"链接\",{\"0\":{\"192\":1}}],[\"链表进行树化\",{\"1\":{\"74\":1}}],[\"链表树化的最小元素数量\",{\"1\":{\"74\":1}}],[\"链表\",{\"1\":{\"48\":1}}],[\"了\",{\"1\":{\"191\":1,\"197\":1,\"202\":1}}],[\"去加载\",{\"1\":{\"191\":4}}],[\"委托给\",{\"1\":{\"191\":2}}],[\"委派父加载器去查找\",{\"1\":{\"191\":1}}],[\"||\",{\"1\":{\"191\":1,\"240\":1,\"244\":1}}],[\"尝试用extclassloader\",{\"1\":{\"191\":1}}],[\"global\",{\"1\":{\"314\":1}}],[\"globals\",{\"1\":{\"191\":1}}],[\"group=root\",{\"1\":{\"312\":1}}],[\"greater\",{\"1\":{\"243\":2,\"244\":1}}],[\"gpw\",{\"1\":{\"313\":1}}],[\"gpasswd\",{\"1\":{\"312\":1}}],[\"gpgcheck=0\",{\"1\":{\"306\":1}}],[\"googleapis\",{\"1\":{\"307\":1}}],[\"gz\",{\"1\":{\"303\":2,\"313\":2}}],[\"given\",{\"1\":{\"234\":1,\"241\":1}}],[\"github\",{\"1\":{\"212\":1}}],[\"g1gc\",{\"1\":{\"209\":2}}],[\"g1垃圾回收器将堆内存分割成不同的区域然后并发的对其进行垃圾回收\",{\"1\":{\"209\":1}}],[\"g1垃圾回收器\",{\"1\":{\"209\":1}}],[\"gceasy\",{\"1\":{\"212\":1}}],[\"gcpauseintervalmillis=200\",{\"1\":{\"209\":1}}],[\"gc时间\",{\"1\":{\"209\":1}}],[\"gc策略\",{\"1\":{\"209\":3}}],[\"gc\",{\"1\":{\"207\":1}}],[\"generate\",{\"1\":{\"310\":1}}],[\"generated\",{\"1\":{\"310\":11}}],[\"generation\",{\"1\":{\"220\":1}}],[\"generally\",{\"1\":{\"236\":1}}],[\"genericsdemo21\",{\"1\":{\"14\":1}}],[\"genericsdemo24\",{\"1\":{\"12\":1}}],[\"genericsdemo09\",{\"1\":{\"11\":1}}],[\"genericsdemo06\",{\"1\":{\"11\":1}}],[\"getclass\",{\"1\":{\"275\":1}}],[\"getclassloadinglock\",{\"1\":{\"191\":1}}],[\"getclassloader\",{\"1\":{\"191\":1,\"218\":1}}],[\"getproxy\",{\"1\":{\"221\":2}}],[\"getresource\",{\"1\":{\"191\":1}}],[\"getjavaseclassloader\",{\"1\":{\"191\":1}}],[\"getmessage\",{\"1\":{\"191\":2}}],[\"getandincrement\",{\"1\":{\"111\":1}}],[\"getordefault\",{\"1\":{\"73\":1}}],[\"get\",{\"1\":{\"73\":1,\"306\":1}}],[\"getvalue\",{\"1\":{\"11\":2,\"235\":2,\"236\":1}}],[\"getvar\",{\"1\":{\"11\":2,\"12\":3,\"14\":2}}],[\"getkey\",{\"1\":{\"11\":2}}],[\"抛出异常\",{\"1\":{\"191\":1}}],[\"心类加载器\",{\"1\":{\"190\":1}}],[\"通用\",{\"0\":{\"332\":1}}],[\"通用类加载器\",{\"1\":{\"190\":1}}],[\"通过控制台进行查看流水线日志\",{\"1\":{\"319\":1}}],[\"通过序列化\",{\"1\":{\"261\":1}}],[\"通过字符组的长度从而获得字符串的长度\",{\"1\":{\"238\":1}}],[\"通过字节码生成的方式加快反射速度\",{\"1\":{\"275\":1}}],[\"通过字节码技术动态创建子类实例\",{\"1\":{\"221\":1}}],[\"通过字节组进行创建对象\",{\"1\":{\"234\":1}}],[\"通过传入的字符组进行复制\",{\"1\":{\"233\":1}}],[\"通过传入的字符串的位置进行获取\",{\"1\":{\"240\":1}}],[\"通过传入的字符串\",{\"1\":{\"232\":1}}],[\"通过设置\",{\"1\":{\"231\":1}}],[\"通过设置一些属性\",{\"1\":{\"74\":1}}],[\"通过修改其字节码生成子类来处理\",{\"1\":{\"223\":1}}],[\"通过jdk\",{\"1\":{\"219\":1}}],[\"通过一个类的全限定名获取定义此类的`二进制例\",{\"1\":{\"188\":1}}],[\"通过插入特定类型的内存屏障来禁止+\",{\"1\":{\"171\":1}}],[\"通过调用一个线程的\",{\"1\":{\"132\":1}}],[\"通过调用\",{\"1\":{\"122\":1}}],[\"通过synchronized和lock也能够保证可见性\",{\"1\":{\"99\":1}}],[\"通过内存屏障指令来禁止特定类型的处理器重排序\",{\"1\":{\"92\":1}}],[\"通过集合进行初始化的\",{\"1\":{\"56\":1}}],[\"通过equals判断数据是否相等\",{\"1\":{\"51\":1}}],[\"通过\",{\"0\":{\"304\":1},\"1\":{\"49\":1,\"73\":1,\"235\":3,\"275\":1,\"316\":1}}],[\"通过切面实现解耦\",{\"0\":{\"32\":1}}],[\"通过代码里标识的元数据让编译器在编译期间进行检查验证\",{\"1\":{\"24\":1}}],[\"通过代码里标识的元数据生成javadoc文档\",{\"1\":{\"24\":1}}],[\"通过子类实例化对象\",{\"1\":{\"12\":1}}],[\"通过构造方法设置属性内容\",{\"1\":{\"12\":1}}],[\"通过泛型\",{\"1\":{\"9\":1}}],[\"通过泛型可以将类型参数化\",{\"1\":{\"9\":1}}],[\"通过泛型指定的不同类型来控制形参具体限制的类型\",{\"1\":{\"8\":1}}],[\"真正实现\",{\"1\":{\"190\":1}}],[\"决定\",{\"1\":{\"187\":1}}],[\"执行自定义\",{\"1\":{\"318\":1}}],[\"执行\",{\"1\":{\"310\":1,\"318\":1}}],[\"执行引擎的作用及工作过程\",{\"1\":{\"203\":1}}],[\"执行引擎\",{\"0\":{\"203\":1},\"1\":{\"187\":1}}],[\"执行线程2的是cpu2\",{\"1\":{\"90\":1}}],[\"至于它是否可以运行\",{\"1\":{\"187\":1}}],[\"文件中常量池部分的内存映射\",{\"1\":{\"196\":1}}],[\"文件引入的错误\",{\"1\":{\"193\":1}}],[\"文件的加载\",{\"1\":{\"187\":1}}],[\"文件在文件开头有特定的文件标识\",{\"1\":{\"187\":1}}],[\"文件记录者整个源码的相关信息\",{\"1\":{\"186\":1}}],[\"文件\",{\"1\":{\"186\":1,\"187\":1,\"271\":1,\"310\":1}}],[\"文件由\",{\"1\":{\"186\":1}}],[\"字符流\",{\"1\":{\"273\":1}}],[\"字符串的长度\",{\"0\":{\"238\":1}}],[\"字节流\",{\"1\":{\"273\":1}}],[\"字节\",{\"1\":{\"249\":7}}],[\"字节码验证步骤会检查每个操作码是否合法\",{\"1\":{\"193\":1}}],[\"字节码验证\",{\"1\":{\"193\":1}}],[\"字节码\",{\"1\":{\"185\":1}}],[\"字段\",{\"1\":{\"24\":1}}],[\"程序的一次执行过程\",{\"1\":{\"271\":1}}],[\"程序\",{\"0\":{\"271\":1},\"1\":{\"271\":1}}],[\"程序计数器就是存储这些指令去做什么\",{\"1\":{\"200\":1}}],[\"程序计数器是一块较小的内存空间\",{\"1\":{\"197\":1,\"200\":1}}],[\"程序计数器\",{\"0\":{\"200\":1},\"1\":{\"197\":1}}],[\"程序都不可见\",{\"1\":{\"190\":1}}],[\"程序只需生成在\",{\"1\":{\"185\":1}}],[\"程序也就终止\",{\"1\":{\"128\":1}}],[\"屏蔽了与具体操作系统平台相关的信息\",{\"1\":{\"185\":1}}],[\"屏障\",{\"1\":{\"174\":8,\"264\":2}}],[\"工具使用\",{\"0\":{\"303\":1}}],[\"工具类\",{\"0\":{\"181\":1},\"1\":{\"275\":1}}],[\"工具为类生成帮助文档时是否要保留其注解信息\",{\"1\":{\"26\":1}}],[\"说明同一个对象\",{\"1\":{\"242\":1}}],[\"说明核心类库中没有这个类\",{\"1\":{\"191\":1}}],[\"说明\",{\"1\":{\"174\":1,\"209\":1}}],[\"采取了保守的策略\",{\"1\":{\"174\":1}}],[\"于任意后续对这个\",{\"0\":{\"173\":1}}],[\"鼓励大家将共享的long和double变量设置为volatile类型\",{\"1\":{\"169\":1}}],[\"共享的long和double变量的为什么要用volatile\",{\"0\":{\"169\":1}}],[\"共享锁是指该锁可被多个线程所持有\",{\"1\":{\"147\":1}}],[\"共享锁\",{\"0\":{\"147\":1}}],[\"目前很大一部分的java应用都集中在互联网站或b\",{\"1\":{\"209\":1}}],[\"目的是为了增加并发问题的产生几率\",{\"1\":{\"168\":1}}],[\"目录里创建一个以服务接口命名的文件\",{\"1\":{\"43\":1}}],[\"引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区\",{\"1\":{\"166\":1}}],[\"引用释放时计数减1\",{\"1\":{\"207\":1}}],[\"引用计数\",{\"1\":{\"207\":1}}],[\"引用数据类型\",{\"1\":{\"161\":1}}],[\"引用\",{\"1\":{\"3\":1}}],[\"防重排序\",{\"0\":{\"165\":1}}],[\"防止应用自己的类库覆盖了核心类库\",{\"1\":{\"191\":1}}],[\"防止应用覆盖jre的核心类\",{\"1\":{\"191\":1}}],[\"防止上面的\",{\"1\":{\"174\":1}}],[\"防止迭代器遍历的时候修改\",{\"1\":{\"74\":1}}],[\"防止并发问题\",{\"1\":{\"48\":1}}],[\"防止不同的对象校验的\",{\"1\":{\"47\":1}}],[\"xip\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"x64\",{\"1\":{\"313\":1}}],[\"xvf\",{\"1\":{\"307\":1}}],[\"x86\",{\"1\":{\"306\":1}}],[\"x86不会对写\",{\"1\":{\"162\":1}}],[\"xx\",{\"1\":{\"143\":1,\"209\":10}}],[\"很有意思的是\",{\"1\":{\"162\":1}}],[\"很显然\",{\"1\":{\"100\":1}}],[\"额外增加约束\",{\"1\":{\"161\":1}}],[\"禁止开机启动\",{\"1\":{\"290\":1}}],[\"禁止下面所有的普通写操作和上面的\",{\"1\":{\"174\":1}}],[\"禁止下面所有的普通读操作和上面的\",{\"1\":{\"174\":1}}],[\"禁止上面的普通写和下面的\",{\"1\":{\"174\":1}}],[\"禁止重排序\",{\"0\":{\"174\":1}}],[\"禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量\",{\"1\":{\"161\":1}}],[\"禁止初次读对象的引用与读该对象包含的final域的重排序\",{\"1\":{\"161\":1}}],[\"禁止final域写与构造方法重排序\",{\"1\":{\"161\":1}}],[\"增加\",{\"1\":{\"159\":1}}],[\"增加了缓存\",{\"1\":{\"88\":1}}],[\"针对引用数据类型\",{\"1\":{\"159\":1}}],[\"读重排序\",{\"1\":{\"174\":2}}],[\"读\",{\"1\":{\"174\":1}}],[\"读操作是在后面插入两个内存屏障\",{\"1\":{\"174\":1}}],[\"读操作的后面插入一个\",{\"1\":{\"174\":2}}],[\"读取i的值\",{\"1\":{\"168\":1}}],[\"读final域需要的loadload屏障也会被省略掉\",{\"1\":{\"162\":1}}],[\"读final域的重排序规则会要求编译器在读final域的操作前插入一个loadload屏障\",{\"1\":{\"162\":1}}],[\"读final域重排序规则\",{\"0\":{\"157\":1}}],[\"读对象的引用和读该对象的final域存在间接依赖性\",{\"1\":{\"157\":1}}],[\"初次读一个包含\",{\"1\":{\"264\":1}}],[\"初次读对象引用和初次读该对象包含的final域\",{\"1\":{\"157\":1}}],[\"初始化\",{\"0\":{\"196\":1}}],[\"初始化对象\",{\"1\":{\"165\":2}}],[\"初始化容量为\",{\"1\":{\"52\":1}}],[\"初始元素\",{\"1\":{\"50\":2}}],[\"初始容量为\",{\"1\":{\"74\":1}}],[\"初始容量\",{\"1\":{\"50\":2,\"74\":1}}],[\"写与下面可能有的\",{\"1\":{\"174\":1}}],[\"写是在前面和后面分别插入内存屏障\",{\"1\":{\"174\":1}}],[\"写操作的后面插入一个\",{\"1\":{\"174\":1}}],[\"写操作的前面插入一个\",{\"1\":{\"174\":1}}],[\"写操作都具有原子性\",{\"1\":{\"169\":1}}],[\"写操作具有原子性\",{\"1\":{\"167\":1}}],[\"写可能不是原子的\",{\"1\":{\"169\":1}}],[\"写\",{\"0\":{\"167\":1}}],[\"写的内存屏障都会被省略\",{\"1\":{\"162\":1}}],[\"写重排序\",{\"1\":{\"162\":1,\"174\":2}}],[\"写final域会要求编译器在final域写之后\",{\"1\":{\"162\":1}}],[\"写final域的重排序规则禁止对final域的写重排序到构造函数之外\",{\"1\":{\"156\":1}}],[\"写final域重排序规则\",{\"0\":{\"156\":1}}],[\"写缓冲区\",{\"1\":{\"92\":1}}],[\"详解\",{\"0\":{\"148\":1,\"163\":1,\"175\":1}}],[\"排他锁\",{\"0\":{\"147\":1}}],[\"再哈希\",{\"1\":{\"262\":1}}],[\"再进入该线程的内层方法会自动获取锁\",{\"1\":{\"146\":1}}],[\"再切换会线程1执行后续两条指令\",{\"1\":{\"91\":1}}],[\"队列中的第一个线程才能获得锁\",{\"1\":{\"145\":1}}],[\"公平锁的优点是等待锁的线程不会饿死\",{\"1\":{\"145\":1}}],[\"公平锁是指多个线程按照申请锁的顺序来获取锁\",{\"1\":{\"145\":1}}],[\"公平锁\",{\"0\":{\"145\":1}}],[\"避免线程阻塞和唤醒而影响性能\",{\"1\":{\"144\":1}}],[\"避免执行cas操作\",{\"1\":{\"144\":1}}],[\"轻量级锁\",{\"0\":{\"144\":1}}],[\"偏向锁通过对比mark\",{\"1\":{\"144\":1}}],[\"偏向锁\",{\"0\":{\"144\":1}}],[\"没有额外空间对它进行分配担保\",{\"1\":{\"208\":1}}],[\"没有成功获得锁\",{\"1\":{\"143\":1}}],[\"没有设置\",{\"1\":{\"121\":2}}],[\"默认30分钟\",{\"1\":{\"308\":1}}],[\"默认值\",{\"1\":{\"249\":8}}],[\"默认gc线程数为cpu的数量\",{\"1\":{\"209\":1}}],[\"默认是everyone\",{\"1\":{\"308\":1}}],[\"默认是db\",{\"1\":{\"308\":1}}],[\"默认是harbor12345\",{\"1\":{\"308\":1}}],[\"默认是http\",{\"1\":{\"308\":1}}],[\"默认是设置delegate是false的\",{\"1\":{\"191\":1}}],[\"默认是10次\",{\"1\":{\"143\":1}}],[\"默认的负载因子\",{\"1\":{\"74\":1}}],[\"默认的初始容量是\",{\"1\":{\"62\":1}}],[\"稍等一下\",{\"1\":{\"143\":1}}],[\"看看持有锁的线程是否很快就会释放锁\",{\"1\":{\"143\":1}}],[\"同时其成员变量为引用类型也要实现\",{\"1\":{\"277\":1}}],[\"同时新的类要实现被代理类所实现的所有的接口\",{\"1\":{\"219\":1}}],[\"同时会杀死所有守护线程\",{\"1\":{\"128\":1}}],[\"同步资源的锁定时间很短\",{\"1\":{\"143\":1}}],[\"根据安装的插件可添加很多功能\",{\"1\":{\"315\":1}}],[\"根据从上面的概念描述我们可以发现\",{\"1\":{\"142\":1}}],[\"根据类型参数的上下界推断并替换所有的类型参数为原生态类型\",{\"1\":{\"17\":1}}],[\"悲观锁适合写操作多的场景\",{\"1\":{\"142\":1}}],[\"悲观锁认为自己在使用数据的时候一定有别的线程来修改数据\",{\"1\":{\"142\":1}}],[\"悲观锁\",{\"0\":{\"142\":1}}],[\"乐观锁适合读操作多的场景\",{\"1\":{\"142\":1}}],[\"乐观锁在java中是通过使用无锁编程来实现\",{\"1\":{\"142\":1}}],[\"乐观锁认为自己在使用数据时不会有别的线程修改数据\",{\"1\":{\"142\":1}}],[\"乐观锁\",{\"0\":{\"142\":1}}],[\"乐观锁需要操作和冲突检测这两个步骤具备原子性\",{\"1\":{\"110\":1}}],[\"锁\",{\"0\":{\"141\":1,\"178\":1}}],[\"锁阻塞\",{\"1\":{\"132\":1}}],[\"或其子类\",{\"1\":{\"250\":1}}],[\"或\",{\"1\":{\"140\":1,\"208\":1}}],[\"或者直接在脚本中直接通过\",{\"1\":{\"315\":1}}],[\"或者等很久才会获得锁\",{\"1\":{\"145\":1}}],[\"或者\",{\"1\":{\"138\":2}}],[\"或者产生了异常而结束\",{\"1\":{\"123\":1}}],[\"或者是此类型的父类\",{\"1\":{\"14\":1}}],[\"或者是此类型的子类\",{\"1\":{\"14\":1}}],[\"或者构造函数\",{\"1\":{\"7\":1}}],[\"或者比被重写方法声明的更广泛的强制性异常\",{\"1\":{\"6\":1}}],[\"造成死锁\",{\"1\":{\"138\":1}}],[\"挂起期间\",{\"1\":{\"138\":1}}],[\"挂起一个线程\",{\"1\":{\"122\":1}}],[\"守护线程是程序运行时在后台提供服务的线程\",{\"1\":{\"128\":1}}],[\"所有人\",{\"1\":{\"308\":1}}],[\"所有对象都分配在堆上渐渐变得不那么\",{\"1\":{\"197\":1,\"202\":1}}],[\"所有任务只能使用固定大小的线程\",{\"1\":{\"127\":1}}],[\"所以系统在产生一个线程或是在各个线程之间切换工作时\",{\"1\":{\"271\":1}}],[\"所以查询的效率较低\",{\"1\":{\"256\":1}}],[\"所以通过索引查询的效率是\",{\"1\":{\"256\":1}}],[\"所以线程安全的\",{\"1\":{\"255\":1}}],[\"所以易维护\",{\"1\":{\"248\":1}}],[\"所以单片机\",{\"1\":{\"248\":1}}],[\"所以使用该方法时需要考虑是否为\",{\"1\":{\"239\":1}}],[\"所以不能对final修饰的类进行代理\",{\"1\":{\"226\":1}}],[\"所以不会添加锁\",{\"1\":{\"142\":1}}],[\"所以说jdk动态代理的核心是通过重写被代理对象所实现的接口中的方法来重新生成代理类来实现的\",{\"1\":{\"219\":1}}],[\"所以说它会优先尝试用\",{\"1\":{\"191\":1}}],[\"所以上面的过程也可能会变成如下过程\",{\"1\":{\"165\":1}}],[\"所以在老年代一般不能直接选用这种算法\",{\"1\":{\"208\":1}}],[\"所以在x86处理器中\",{\"1\":{\"162\":1}}],[\"所以在final类中给任何方法添加final关键字是没有任何意义的\",{\"1\":{\"150\":1}}],[\"所以storestore屏障可以省略\",{\"1\":{\"162\":1}}],[\"所以更不用说是覆盖了\",{\"1\":{\"151\":1}}],[\"所以非公平锁有可能出现后申请锁的线程先获取锁的场景\",{\"1\":{\"145\":1}}],[\"所以\",{\"1\":{\"143\":1,\"185\":1,\"249\":1}}],[\"所以最大值为\",{\"1\":{\"74\":1}}],[\"所以需要该数据对象实现对应的方法\",{\"1\":{\"51\":1}}],[\"所以本人认为完全的\",{\"1\":{\"46\":1}}],[\"所以自然就不行了\",{\"1\":{\"21\":1}}],[\"管理员ui登录的密码\",{\"1\":{\"308\":1}}],[\"管理工具\",{\"1\":{\"288\":1}}],[\"管理的策略\",{\"1\":{\"201\":1}}],[\"管理多个异步任务的执行\",{\"1\":{\"127\":1}}],[\"管程锁定规则\",{\"1\":{\"97\":1,\"264\":1}}],[\"基础类型的包装类\",{\"1\":{\"275\":1}}],[\"基础面试题\",{\"0\":{\"246\":1}}],[\"基础线程机制\",{\"0\":{\"126\":1}}],[\"基本的数据类型相等的判断只需要==就可以判断\",{\"1\":{\"241\":1}}],[\"基本数据类型\",{\"1\":{\"161\":1}}],[\"基本和arraylist\",{\"1\":{\"63\":1}}],[\"死亡\",{\"0\":{\"123\":1}}],[\"睡眠和挂起是用来描述行为\",{\"1\":{\"122\":1}}],[\"限期等待或者无限期等待状态\",{\"1\":{\"132\":1}}],[\"限期等待\",{\"0\":{\"122\":1}}],[\"退出方法\",{\"1\":{\"121\":1,\"122\":1}}],[\"wget\",{\"1\":{\"307\":1,\"311\":1,\"313\":2}}],[\"windows\",{\"1\":{\"303\":1}}],[\"window\",{\"1\":{\"303\":1}}],[\"with\",{\"1\":{\"244\":1}}],[\"wrf\",{\"1\":{\"259\":2}}],[\"would\",{\"1\":{\"243\":1}}],[\"workdir\",{\"1\":{\"318\":1}}],[\"workers\",{\"1\":{\"308\":1}}],[\"work\",{\"1\":{\"300\":1}}],[\"words\",{\"1\":{\"232\":1}}],[\"word解决加锁问题\",{\"1\":{\"144\":1}}],[\"world\",{\"1\":{\"209\":1}}],[\"where\",{\"1\":{\"244\":1}}],[\"when\",{\"1\":{\"191\":1,\"234\":2,\"243\":1}}],[\"which\",{\"1\":{\"243\":1}}],[\"while\",{\"1\":{\"241\":1,\"243\":1,\"244\":1}}],[\"whose\",{\"1\":{\"243\":1}}],[\"www\",{\"1\":{\"212\":1}}],[\"warn\",{\"1\":{\"191\":2}}],[\"wait\",{\"0\":{\"138\":1,\"139\":1},\"1\":{\"121\":1,\"122\":3,\"138\":2,\"139\":2,\"140\":1,\"277\":1}}],[\"waiting\",{\"0\":{\"121\":1,\"122\":1}}],[\"weakreference\",{\"1\":{\"259\":3}}],[\"weakhashmap\",{\"0\":{\"77\":1}}],[\"we\",{\"1\":{\"191\":1}}],[\"webhooks\",{\"1\":{\"315\":1}}],[\"webappclassloader\",{\"0\":{\"191\":1},\"1\":{\"190\":2,\"191\":3}}],[\"web\",{\"1\":{\"115\":2,\"190\":9,\"318\":3}}],[\"rf\",{\"1\":{\"318\":1}}],[\"rm\",{\"1\":{\"318\":1}}],[\"rules\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"runtimeexception\",{\"1\":{\"191\":2,\"269\":1}}],[\"run\",{\"1\":{\"133\":1,\"236\":1,\"296\":1,\"318\":3}}],[\"running\",{\"1\":{\"119\":1}}],[\"runnable\",{\"0\":{\"119\":1},\"1\":{\"124\":2}}],[\"rpm\",{\"1\":{\"311\":1}}],[\"root\",{\"1\":{\"308\":2,\"310\":2,\"312\":1}}],[\"roots包括\",{\"1\":{\"207\":1}}],[\"roots没有任何引用链相连时\",{\"1\":{\"207\":1}}],[\"roots开始向下搜索\",{\"1\":{\"207\":1}}],[\"rancher\",{\"0\":{\"296\":1,\"303\":1},\"1\":{\"288\":1,\"296\":5,\"303\":6,\"305\":1,\"306\":1,\"316\":1,\"318\":4}}],[\"ranges\",{\"1\":{\"240\":1}}],[\"redhat\",{\"1\":{\"311\":2}}],[\"releases\",{\"1\":{\"303\":3,\"307\":1}}],[\"reload\",{\"1\":{\"295\":1}}],[\"registration\",{\"1\":{\"308\":1}}],[\"registry\",{\"1\":{\"295\":1,\"310\":2}}],[\"regionmatches\",{\"1\":{\"242\":1}}],[\"reflectasm\",{\"1\":{\"275\":1}}],[\"reflect包下边的两个类\",{\"1\":{\"217\":1}}],[\"referencequeue<>\",{\"1\":{\"259\":1}}],[\"required\",{\"1\":{\"234\":1}}],[\"request\",{\"1\":{\"115\":1}}],[\"restriction\",{\"1\":{\"308\":1}}],[\"restart=unless\",{\"1\":{\"296\":1}}],[\"restart\",{\"1\":{\"295\":1,\"311\":1,\"312\":1}}],[\"result\",{\"1\":{\"241\":1,\"242\":2,\"243\":3,\"244\":3}}],[\"resourcename\",{\"1\":{\"191\":3}}],[\"resolveclass\",{\"1\":{\"191\":5}}],[\"resolve\",{\"0\":{\"195\":1},\"1\":{\"191\":6}}],[\"resize\",{\"1\":{\"75\":1}}],[\"reentrantlock\",{\"1\":{\"135\":1}}],[\"ready\",{\"1\":{\"119\":1}}],[\"remote\",{\"1\":{\"308\":1}}],[\"removeif\",{\"1\":{\"47\":1}}],[\"removeall\",{\"1\":{\"47\":1}}],[\"remove\",{\"1\":{\"47\":1,\"73\":2}}],[\"remappingfunction\",{\"1\":{\"73\":1}}],[\"replicas\",{\"1\":{\"316\":1,\"318\":1,\"323\":1,\"324\":2}}],[\"replace\",{\"1\":{\"73\":2}}],[\"repos\",{\"1\":{\"306\":2,\"311\":1}}],[\"repository\",{\"1\":{\"191\":1}}],[\"repositories\",{\"1\":{\"191\":1}}],[\"repo\",{\"1\":{\"293\":2,\"306\":1,\"311\":2}}],[\"represented\",{\"1\":{\"238\":1,\"243\":2,\"244\":1}}],[\"represents\",{\"1\":{\"231\":1,\"232\":1,\"233\":1,\"241\":2,\"242\":1}}],[\"repeatable\",{\"1\":{\"26\":2}}],[\"rethrown\",{\"1\":{\"191\":2}}],[\"retainall\",{\"1\":{\"47\":1}}],[\"retention用于标明注解被保留的阶段\",{\"1\":{\"24\":1}}],[\"retention\",{\"1\":{\"24\":1,\"26\":1}}],[\"returned\",{\"1\":{\"240\":1}}],[\"returns\",{\"1\":{\"238\":1,\"239\":1,\"240\":1,\"243\":3}}],[\"returning\",{\"1\":{\"191\":4}}],[\"return\",{\"0\":{\"268\":1},\"1\":{\"9\":4,\"11\":3,\"12\":1,\"14\":4,\"21\":1,\"52\":4,\"191\":7,\"218\":1,\"221\":2,\"238\":2,\"239\":2,\"240\":2,\"241\":5,\"242\":2,\"243\":4,\"244\":4,\"268\":3}}],[\"新生代使用parnew\",{\"1\":{\"209\":1}}],[\"新生代gc策略\",{\"1\":{\"209\":1}}],[\"新生代并行\",{\"1\":{\"209\":1}}],[\"新生代复制算法\",{\"1\":{\"209\":3}}],[\"新生代=\",{\"1\":{\"202\":1}}],[\"新生代\",{\"1\":{\"202\":1,\"209\":1}}],[\"新生区分为eden\",{\"1\":{\"202\":1}}],[\"新生区\",{\"1\":{\"202\":1}}],[\"新建\",{\"0\":{\"118\":1},\"1\":{\"315\":1}}],[\"新增一个引用时计数加1\",{\"1\":{\"207\":1}}],[\"新增操作和arraylist一致\",{\"1\":{\"64\":1}}],[\"新增\",{\"0\":{\"52\":1,\"58\":1,\"64\":1}}],[\"转而去执行另外一段代码\",{\"1\":{\"116\":1}}],[\"服务暂停\",{\"1\":{\"209\":1}}],[\"服务端应用都可以使用线程本地存储来解决线程安全问题\",{\"1\":{\"115\":1}}],[\"服务提供发现机制\",{\"1\":{\"43\":1}}],[\"交互模型中的\",{\"1\":{\"115\":1}}],[\"模式\",{\"1\":{\"115\":1}}],[\"大部分使用消费队列的架构模式\",{\"1\":{\"115\":1}}],[\"大部分情况下\",{\"1\":{\"112\":1}}],[\"符合这种特点的应用并不少见\",{\"1\":{\"115\":1}}],[\"改用传统的互斥同步可能会比原子类更高效\",{\"1\":{\"112\":1}}],[\"问题2\",{\"0\":{\"169\":1}}],[\"问题1\",{\"0\":{\"168\":1}}],[\"问题\",{\"1\":{\"112\":1}}],[\"问题不会影响程序并发的正确性\",{\"1\":{\"112\":1}}],[\"后记\",{\"0\":{\"321\":1}}],[\"后来这项技术被用到了spring的很多地方\",{\"1\":{\"217\":1}}],[\"后来又被改回为\",{\"1\":{\"112\":1}}],[\"后续创建则直接在先缓存\",{\"1\":{\"58\":1}}],[\"后续扩容\",{\"1\":{\"52\":1}}],[\"后续移出时会使用\",{\"1\":{\"52\":1}}],[\"值专用的字节码指令\",{\"1\":{\"249\":1}}],[\"值默认为\",{\"1\":{\"231\":1}}],[\"值\",{\"1\":{\"112\":1}}],[\"包结构\",{\"0\":{\"269\":1}}],[\"包的区别\",{\"0\":{\"258\":1}}],[\"包和\",{\"0\":{\"258\":1}}],[\"包含了操作系统线程状态中的\",{\"1\":{\"119\":1}}],[\"包提供了一个带有标记的原子引用类\",{\"1\":{\"112\":1}}],[\"包里面的整数原子类\",{\"1\":{\"111\":1}}],[\"包括三步骤\",{\"1\":{\"168\":1}}],[\"包括递归调用它本身\",{\"1\":{\"116\":1}}],[\"包括\",{\"1\":{\"24\":2,\"25\":1}}],[\"才能编写\",{\"1\":{\"321\":1}}],[\"才将\",{\"1\":{\"110\":1}}],[\"才会树化\",{\"1\":{\"74\":1}}],[\"旧的预期值\",{\"1\":{\"110\":1}}],[\"比面向过程要低\",{\"1\":{\"248\":1}}],[\"比较\",{\"1\":{\"262\":1}}],[\"比较的是地址中的数据是否相等\",{\"1\":{\"253\":1}}],[\"比较的地址\",{\"1\":{\"253\":1}}],[\"比较字符串的大小\",{\"0\":{\"243\":1}}],[\"比较内容是否相等\",{\"0\":{\"241\":1}}],[\"比较并交换\",{\"1\":{\"110\":1}}],[\"比如循环\",{\"1\":{\"200\":1}}],[\"比如java\",{\"1\":{\"43\":1}}],[\"硬件支持的原子性操作最典型的是\",{\"1\":{\"110\":1}}],[\"直到无冲突\",{\"1\":{\"262\":1}}],[\"直到目标线程结束\",{\"1\":{\"137\":1}}],[\"直到成功为止\",{\"1\":{\"110\":1}}],[\"直接让前一个节点关联后一节点\",{\"1\":{\"59\":1}}],[\"直接可以重复使用authority注解\",{\"1\":{\"26\":1}}],[\"直接打印\",{\"1\":{\"14\":2}}],[\"先在本地缓存中查找该类是否已经加载过\",{\"1\":{\"191\":1}}],[\"先在应用本地目录下查找类\",{\"1\":{\"191\":1}}],[\"先加锁可以保证写操作时数据正确\",{\"1\":{\"142\":1}}],[\"先进行操作\",{\"1\":{\"110\":1}}],[\"先行发生于操作\",{\"1\":{\"97\":3,\"264\":3}}],[\"先行发生于它的\",{\"1\":{\"97\":1,\"264\":1}}],[\"维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作\",{\"1\":{\"108\":1}}],[\"实例\",{\"0\":{\"218\":1,\"221\":1}}],[\"实例化一个对象其实可以分为三个步骤\",{\"1\":{\"165\":1}}],[\"实际使用时修改下\",{\"1\":{\"308\":1}}],[\"实际的应用一般不会只是简单的打印日志的\",{\"1\":{\"217\":1}}],[\"实际上最终还是把字节码解释成具体平台上的机器指令执行\",{\"1\":{\"185\":1}}],[\"实际上\",{\"1\":{\"157\":1}}],[\"实际上虚拟机会优化掉很大一部分不必要的加锁\",{\"1\":{\"108\":1}}],[\"实现对象的浅复制\",{\"1\":{\"277\":1}}],[\"实现了\",{\"1\":{\"257\":2}}],[\"实现创建对象\",{\"1\":{\"231\":1}}],[\"实现gc线程和应用线程并发工作\",{\"1\":{\"209\":1}}],[\"实现简单\",{\"1\":{\"208\":1}}],[\"实现可见性\",{\"0\":{\"166\":1}}],[\"实现的\",{\"1\":{\"135\":2}}],[\"实现接口会更好一些\",{\"1\":{\"125\":1}}],[\"实现接口\",{\"0\":{\"125\":1}}],[\"实现\",{\"1\":{\"124\":3,\"171\":1}}],[\"实现子类\",{\"1\":{\"49\":1}}],[\"实现原理\",{\"0\":{\"223\":1},\"1\":{\"48\":1}}],[\"实现类名称\",{\"1\":{\"48\":1}}],[\"实现类比较\",{\"0\":{\"48\":1}}],[\"互斥同步属于一种悲观的并发策略\",{\"1\":{\"108\":1}}],[\"互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题\",{\"1\":{\"108\":1}}],[\"互斥同步\",{\"0\":{\"108\":1}}],[\"应用容器引擎\",{\"1\":{\"288\":1}}],[\"应用的类加载器\",{\"1\":{\"190\":1}}],[\"应用程序运行时间\",{\"1\":{\"209\":2}}],[\"应用程序使用\",{\"1\":{\"190\":1}}],[\"应用程序都有一个\",{\"1\":{\"190\":1}}],[\"应用程序共同使用\",{\"1\":{\"190\":1}}],[\"应用程序相互隔离独立的\",{\"1\":{\"190\":1}}],[\"应用程序自己定义的类来实现\",{\"1\":{\"190\":1}}],[\"应用程序呢\",{\"1\":{\"190\":1}}],[\"应用程序之间的类加载器相互隔离\",{\"1\":{\"190\":1}}],[\"应当尽量避免\",{\"1\":{\"106\":1}}],[\"应该如何做呢\",{\"1\":{\"21\":1}}],[\"等会抛出\",{\"1\":{\"133\":1}}],[\"等方法进入\",{\"1\":{\"122\":1}}],[\"等方法都使用了\",{\"1\":{\"111\":1}}],[\"等待队列中除第一个线程以外的所有线程都会阻塞\",{\"1\":{\"145\":1}}],[\"等待其它线程显式地唤醒\",{\"1\":{\"121\":1}}],[\"等待获取一个排它锁\",{\"1\":{\"120\":1}}],[\"等\",{\"1\":{\"105\":1}}],[\"绝对\",{\"1\":{\"197\":1,\"202\":1}}],[\"绝对线程安全\",{\"0\":{\"103\":1}}],[\"绝大多数时候指的是这一种情况\",{\"1\":{\"105\":1}}],[\"我们在方法执行前后打印的日志\",{\"1\":{\"217\":1}}],[\"我们现在以使用最为流行的\",{\"1\":{\"201\":1}}],[\"我们需要将变量设置为volatile类型的变量\",{\"1\":{\"165\":1}}],[\"我们需让当前线程进行自旋\",{\"1\":{\"143\":1}}],[\"我们就可以让后面那个请求锁的线程不放弃cpu的执行时间\",{\"1\":{\"143\":1}}],[\"我们就可以把共享数据的可见范围限制在同一个线程之内\",{\"1\":{\"115\":1}}],[\"我们可以通过atomicinteger或者synchronized来保证+1操作的原子性\",{\"1\":{\"168\":1}}],[\"我们可以使用基于冲突检测的乐观并发策略\",{\"1\":{\"110\":1}}],[\"我们可以复用为一个方法\",{\"1\":{\"9\":1}}],[\"我们平常说一个类不是线程安全的\",{\"1\":{\"105\":1}}],[\"永远也不会看到它在多个线程之中处于不一致的状态\",{\"1\":{\"102\":1}}],[\"相关的规则\",{\"1\":{\"282\":1}}],[\"相反\",{\"1\":{\"272\":1}}],[\"相等\",{\"0\":{\"262\":1}}],[\"相当于大小为\",{\"1\":{\"127\":1}}],[\"相当于是让线程顺序执行同步代码\",{\"1\":{\"100\":1}}],[\"相对不安全\",{\"1\":{\"275\":1}}],[\"相对应的集合类\",{\"1\":{\"105\":1}}],[\"相对线程安全需要保证对这个对象单独的操作是线程安全的\",{\"1\":{\"104\":1}}],[\"相对线程安全\",{\"0\":{\"104\":1}}],[\"相比于\",{\"1\":{\"48\":1,\"140\":1}}],[\"具体到对象原对象的操作则是需要代理对象处理的\",{\"1\":{\"216\":1}}],[\"具体是否插入还是得看是什么处理器\",{\"1\":{\"162\":1}}],[\"具体原理在下一节讲述\",{\"1\":{\"100\":1}}],[\"具体来说\",{\"1\":{\"93\":1}}],[\"什么区别\",{\"0\":{\"276\":1}}],[\"什么时候被写入主存是不确定的\",{\"1\":{\"99\":1}}],[\"什么是代理\",{\"0\":{\"216\":1}}],[\"什么是\",{\"0\":{\"280\":1},\"1\":{\"205\":1}}],[\"什么是spi\",{\"1\":{\"43\":1}}],[\"什么是泛型擦除\",{\"1\":{\"16\":1}}],[\"什么是泛型\",{\"1\":{\"8\":1}}],[\"变量的内存可见性是基于内存屏障\",{\"1\":{\"171\":1}}],[\"变量的写操作先行发生于后面对这个变量的读操作\",{\"1\":{\"97\":1,\"264\":1}}],[\"变量规则\",{\"0\":{\"173\":1},\"1\":{\"97\":1,\"264\":1}}],[\"变更效率高\",{\"1\":{\"48\":1}}],[\"变更效率低\",{\"1\":{\"48\":1}}],[\"规则中有一条是\",{\"0\":{\"173\":1}}],[\"规则来保证有序性的\",{\"1\":{\"100\":1}}],[\"规则\",{\"1\":{\"93\":1,\"264\":1}}],[\"三个关键字\",{\"1\":{\"93\":1}}],[\"称之为\",{\"1\":{\"92\":1}}],[\"不仅仅复制当前对象\",{\"1\":{\"263\":1}}],[\"不必因为类型不一致而创建不同类\",{\"1\":{\"260\":1}}],[\"不可以设置为127\",{\"1\":{\"308\":1}}],[\"不可使基础类型\",{\"1\":{\"250\":1}}],[\"不可使用该类型\",{\"1\":{\"229\":1}}],[\"不可达对象\",{\"1\":{\"207\":1}}],[\"不可变\",{\"0\":{\"102\":1},\"1\":{\"102\":1}}],[\"不同的\",{\"1\":{\"201\":1}}],[\"不能重复\",{\"1\":{\"276\":1}}],[\"不能修饰类和方法\",{\"1\":{\"272\":1}}],[\"不能修改数据\",{\"1\":{\"147\":1}}],[\"不能加排它锁\",{\"1\":{\"147\":1}}],[\"不加锁的特点能够使其读操作的性能大幅提升\",{\"1\":{\"142\":1}}],[\"不会报错\",{\"1\":{\"267\":1}}],[\"不会因为之前已经获取过还没释放而阻塞\",{\"1\":{\"146\":1}}],[\"不会\",{\"1\":{\"139\":1}}],[\"不会出现线程安全问题\",{\"1\":{\"114\":1}}],[\"不属于程序中不可或缺的部分\",{\"1\":{\"128\":1}}],[\"不需要暂停所有应用线程\",{\"1\":{\"209\":1}}],[\"不需要进行同步操作\",{\"1\":{\"127\":1}}],[\"不需要再采取任何的线程安全保障措施\",{\"1\":{\"102\":1}}],[\"不支持多重继承\",{\"1\":{\"125\":1}}],[\"不是真正意义上的线程\",{\"1\":{\"124\":1}}],[\"不是所有的处理器重排序都要禁止\",{\"1\":{\"92\":1}}],[\"不是所有的编译器重排序都要禁止\",{\"1\":{\"92\":1}}],[\"不调用非可重入的方法等\",{\"1\":{\"116\":1}}],[\"不断地重试\",{\"1\":{\"110\":1}}],[\"不管什么指令都不能和这条\",{\"1\":{\"171\":1}}],[\"不管运行时环境如何\",{\"1\":{\"103\":1}}],[\"不管是使用还是面试频度否非常的高\",{\"1\":{\"46\":1}}],[\"属于非守护线程\",{\"1\":{\"128\":1}}],[\"属于线程私有的\",{\"1\":{\"114\":1}}],[\"属于处理器重排序\",{\"1\":{\"92\":1}}],[\"属于编译器重排序\",{\"1\":{\"92\":1}}],[\"属性来获得改包装的\",{\"1\":{\"275\":1}}],[\"属性\",{\"0\":{\"229\":1}}],[\"属性first\",{\"1\":{\"58\":1}}],[\"属性缓存数据的长度\",{\"1\":{\"49\":1}}],[\"上有相同的结果\",{\"1\":{\"171\":1}}],[\"上面几段代码中多处执行了thread\",{\"1\":{\"168\":1}}],[\"上面我们提到过\",{\"1\":{\"162\":1}}],[\"上调用\",{\"1\":{\"140\":1}}],[\"上述的\",{\"1\":{\"92\":1}}],[\"上限\",{\"1\":{\"14\":1}}],[\"源代码到最终实际执行的指令序列\",{\"1\":{\"92\":1}}],[\"来唤醒挂起的线程\",{\"1\":{\"138\":2}}],[\"来中断该线程\",{\"1\":{\"132\":1}}],[\"来调用\",{\"1\":{\"124\":1}}],[\"来解决这个问题\",{\"1\":{\"112\":1}}],[\"来将多条指令重叠执行\",{\"1\":{\"92\":1}}],[\"来使用\",{\"1\":{\"3\":1}}],[\"现代处理器采用了指令级并行技术\",{\"1\":{\"92\":1}}],[\"假如应用里自定义了一个叫\",{\"1\":{\"191\":1}}],[\"假如线程2执行了这三条指令后\",{\"1\":{\"91\":1}}],[\"假若执行线程1的是cpu1\",{\"1\":{\"90\":1}}],[\"缓存而不是内存\",{\"1\":{\"91\":1}}],[\"缓存机制导致可能写入的是\",{\"1\":{\"91\":1}}],[\"缓存的数据大小为\",{\"1\":{\"251\":1}}],[\"缓存的数据\",{\"1\":{\"74\":1}}],[\"缓存的last关联新元素\",{\"1\":{\"58\":1}}],[\"将jenkins账号分别加入到root组中\",{\"1\":{\"312\":1}}],[\"将第\",{\"1\":{\"310\":1}}],[\"将内存的对象进行解析\",{\"1\":{\"275\":1}}],[\"将内存空间的地址赋值给对应的引用\",{\"1\":{\"165\":2}}],[\"将新生成的class文件重新加载到\",{\"1\":{\"219\":1}}],[\"将i的值写回内存\",{\"1\":{\"168\":1}}],[\"将造成最后写到内存中的i值是2而不是3\",{\"1\":{\"91\":1}}],[\"将最后的结果i写入内存\",{\"1\":{\"91\":1}}],[\"将变量\",{\"1\":{\"91\":1}}],[\"将所有的泛型表示\",{\"1\":{\"16\":1}}],[\"指令重排序\",{\"1\":{\"171\":1}}],[\"指令需要有\",{\"1\":{\"110\":1}}],[\"指令级并行的重排序\",{\"1\":{\"92\":1}}],[\"指令\",{\"1\":{\"91\":1,\"92\":1,\"171\":1}}],[\"指向存储注解authorities\",{\"1\":{\"26\":1}}],[\"分代收集算法\",{\"1\":{\"208\":1}}],[\"分配\",{\"1\":{\"201\":1}}],[\"分配内存空间\",{\"1\":{\"165\":2}}],[\"分时复用引起\",{\"0\":{\"91\":1}}],[\"分别是内存地址\",{\"1\":{\"110\":1}}],[\"分别用于标明重写某个方法\",{\"1\":{\"24\":1}}],[\"分别被称为泛型类\",{\"1\":{\"8\":1}}],[\"注\",{\"1\":{\"168\":1}}],[\"注意这里的是\",{\"1\":{\"159\":1}}],[\"注意\",{\"0\":{\"310\":1},\"1\":{\"150\":1,\"157\":1,\"193\":1,\"249\":1,\"250\":1,\"251\":1}}],[\"注意此时内存当中i的值还是0\",{\"1\":{\"90\":1}}],[\"注解实现的原理\",{\"0\":{\"31\":1}}],[\"注解支持继承吗\",{\"0\":{\"30\":1}}],[\"注解修饰成员变量\",{\"1\":{\"26\":1}}],[\"注解的常见分类\",{\"1\":{\"24\":1}}],[\"注解是jdk1\",{\"1\":{\"24\":1}}],[\"注解基础\",{\"0\":{\"24\":1}}],[\"注解机制\",{\"0\":{\"23\":1}}],[\"却没有立即写入到主存当中\",{\"1\":{\"90\":1}}],[\"原因就是它打破了\",{\"1\":{\"190\":1}}],[\"原子类\",{\"0\":{\"177\":1}}],[\"原子性\",{\"0\":{\"91\":1,\"98\":1}}],[\"原子性问题\",{\"1\":{\"88\":1}}],[\"原来的程序不会出现任何错误\",{\"1\":{\"116\":1}}],[\"原始类型变为object\",{\"1\":{\"20\":1}}],[\"与动态编译结合\",{\"1\":{\"275\":1}}],[\"与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源\",{\"1\":{\"271\":1}}],[\"与随后初次读这个\",{\"1\":{\"264\":1}}],[\"与随后把这个被构造对象的引用赋值给一个变量\",{\"1\":{\"264\":1}}],[\"与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量\",{\"1\":{\"159\":1}}],[\"与平台无关性\",{\"1\":{\"247\":1}}],[\"与虚拟机栈相同的是栈的深度是固定的\",{\"1\":{\"197\":1,\"199\":1}}],[\"与虚拟机的作用是相似的\",{\"1\":{\"197\":1,\"199\":1}}],[\"与\",{\"1\":{\"88\":1}}],[\"进入解压包中\",{\"1\":{\"305\":1}}],[\"进入方法\",{\"1\":{\"121\":1,\"122\":1}}],[\"进程\",{\"1\":{\"271\":1}}],[\"进程的基本概念\",{\"0\":{\"271\":1}}],[\"进而均衡\",{\"1\":{\"88\":1}}],[\"进行部署\",{\"1\":{\"316\":1}}],[\"进行频繁的字符串操作性能较高\",{\"1\":{\"255\":1}}],[\"进行拼接时相当于新建字符数组进行替换\",{\"1\":{\"255\":1}}],[\"进行判断数据是否一致的效率\",{\"1\":{\"254\":1}}],[\"进行判断对象的内存地址是否相同\",{\"1\":{\"242\":1}}],[\"进行判断\",{\"1\":{\"241\":1}}],[\"进行出现线程数据共享\",{\"1\":{\"235\":1}}],[\"进行构建对象\",{\"1\":{\"235\":1}}],[\"进行代码编译\",{\"1\":{\"186\":1}}],[\"进行描述\",{\"1\":{\"122\":2}}],[\"进行树化处理\",{\"1\":{\"75\":1}}],[\"进行初始化或扩容\",{\"1\":{\"75\":1}}],[\"进行\",{\"1\":{\"75\":1}}],[\"进行控制某些行为\",{\"1\":{\"74\":1}}],[\"进行防止并发操作\",{\"1\":{\"64\":1}}],[\"进行比较数据对象是否存在\",{\"1\":{\"57\":1}}],[\"线程也被称为轻量进程\",{\"1\":{\"271\":1}}],[\"线程和进程类似\",{\"1\":{\"271\":1}}],[\"线程不安全\",{\"1\":{\"236\":1,\"255\":1,\"257\":1}}],[\"线程池\",{\"0\":{\"180\":1}}],[\"线程工作内存\",{\"1\":{\"166\":1}}],[\"线程b和线程c之间存在数据竞争\",{\"1\":{\"160\":1}}],[\"线程直接进入队列中排队\",{\"1\":{\"145\":1}}],[\"线程挂起和恢复现场的花费可能会让系统得不偿失\",{\"1\":{\"143\":1}}],[\"线程会释放锁\",{\"1\":{\"138\":1}}],[\"线程在等待时会被挂起\",{\"1\":{\"138\":1}}],[\"线程间的协作\",{\"0\":{\"136\":1}}],[\"线程互斥同步\",{\"0\":{\"135\":1}}],[\"线程中断\",{\"0\":{\"131\":1}}],[\"线程中断规则\",{\"1\":{\"97\":1,\"264\":1}}],[\"线程中抛出的其它异常也同样需要在本地进行处理\",{\"1\":{\"129\":1}}],[\"线程使用方式\",{\"0\":{\"124\":1}}],[\"线程状态\",{\"0\":{\"117\":1}}],[\"线程本地存储\",{\"0\":{\"115\":1}}],[\"线程对立这种排斥多线程的代码是很少出现的\",{\"1\":{\"106\":1}}],[\"线程对立是指无论调用端是否采取了同步措施\",{\"1\":{\"106\":1}}],[\"线程对立\",{\"0\":{\"106\":1}}],[\"线程兼容是指对象本身并不是线程安全的\",{\"1\":{\"105\":1}}],[\"线程兼容\",{\"0\":{\"105\":1}}],[\"线程加入规则\",{\"1\":{\"97\":1,\"264\":1}}],[\"线程启动规则\",{\"1\":{\"97\":1,\"264\":1}}],[\"线程1执行了第一条指令后\",{\"1\":{\"91\":1}}],[\"线程1对变量i修改了之后\",{\"1\":{\"90\":1}}],[\"线程切换\",{\"1\":{\"91\":1}}],[\"线程2没有立即看到线程1修改的值\",{\"1\":{\"90\":1}}],[\"线程\",{\"1\":{\"88\":1,\"271\":1}}],[\"线程安全的实现\",{\"0\":{\"107\":1}}],[\"线程安全分类\",{\"0\":{\"101\":1}}],[\"线程安全\",{\"1\":{\"61\":1,\"257\":1}}],[\"导致无法添加\",{\"1\":{\"302\":1}}],[\"导致\",{\"1\":{\"88\":3}}],[\"导致操作效率较低\",{\"1\":{\"48\":1}}],[\"操作数栈\",{\"1\":{\"197\":1,\"198\":1}}],[\"操作就会误认为它从来没有被改变过\",{\"1\":{\"112\":1}}],[\"操作先行发生于后面对同一个锁的\",{\"1\":{\"97\":1,\"264\":1}}],[\"操作\",{\"1\":{\"91\":1,\"97\":2,\"111\":1,\"264\":2}}],[\"操作系统增加了进程\",{\"1\":{\"88\":1}}],[\"操作系统\",{\"1\":{\"88\":1}}],[\"操作的数据类型被指定为一个参数\",{\"1\":{\"8\":1}}],[\"平衡这三者的速度差异\",{\"1\":{\"88\":1}}],[\"设备的速度差异\",{\"1\":{\"88\":1}}],[\"设备的速度是有极大差异的\",{\"1\":{\"88\":1}}],[\"设置\",{\"0\":{\"318\":1}}],[\"设置流水线\",{\"0\":{\"315\":1}}],[\"设置环境\",{\"0\":{\"313\":1}}],[\"设置开机启动\",{\"0\":{\"294\":1}}],[\"设置对象\",{\"1\":{\"232\":1}}],[\"设置需要创建子类的类\",{\"1\":{\"221\":1}}],[\"设置了\",{\"1\":{\"122\":2}}],[\"设置第二个内容\",{\"1\":{\"11\":1}}],[\"设置第一个内容\",{\"1\":{\"11\":1}}],[\"设置字符串\",{\"1\":{\"11\":1}}],[\"设置的类型也由外部决定\",{\"1\":{\"11\":1}}],[\"中间件\",{\"0\":{\"327\":1}}],[\"中使用它\",{\"1\":{\"282\":1}}],[\"中提供了两套的\",{\"1\":{\"274\":1}}],[\"中运行\",{\"1\":{\"219\":1}}],[\"中最小的执行单位是线程\",{\"1\":{\"200\":1}}],[\"中才能运行\",{\"1\":{\"185\":1}}],[\"中的\",{\"0\":{\"273\":1,\"282\":1}}],[\"中的类装载器完成的\",{\"1\":{\"185\":1}}],[\"中的所有类\",{\"1\":{\"185\":1}}],[\"中的配置文件\",{\"1\":{\"43\":1}}],[\"中\",{\"1\":{\"129\":1}}],[\"中大部分的类都是属于线程兼容的\",{\"1\":{\"105\":1}}],[\"中不存在哈希冲突则放置到对应的下标上\",{\"1\":{\"75\":1}}],[\"^\",{\"1\":{\"75\":1}}],[\"下载maven\",{\"1\":{\"313\":1}}],[\"下载java\",{\"1\":{\"313\":1}}],[\"下载安装文件\",{\"1\":{\"307\":1}}],[\"下载链接\",{\"1\":{\"303\":3}}],[\"下一次扩容的容量\",{\"1\":{\"74\":1}}],[\"下限\",{\"1\":{\"14\":1}}],[\"树退化为链表\",{\"1\":{\"74\":1}}],[\"树退化成链表的最大元素数量\",{\"1\":{\"74\":1}}],[\"6849794470754667710l\",{\"1\":{\"229\":1}}],[\"6和1\",{\"1\":{\"227\":1}}],[\"6中才开始提供\",{\"1\":{\"209\":1}}],[\"64\",{\"1\":{\"74\":3,\"306\":1}}],[\"6\",{\"0\":{\"252\":1},\"1\":{\"74\":2,\"191\":1,\"239\":1}}],[\"urandom\",{\"1\":{\"318\":1}}],[\"url\",{\"1\":{\"191\":5,\"308\":3}}],[\"ubuntu\",{\"1\":{\"310\":1}}],[\"uid\",{\"1\":{\"308\":2}}],[\"uid=searchuser\",{\"1\":{\"308\":1}}],[\"ui\",{\"0\":{\"304\":1},\"1\":{\"308\":1,\"310\":3}}],[\"update\",{\"1\":{\"291\":1,\"293\":1}}],[\"u000\",{\"1\":{\"249\":1}}],[\"ul>\",{\"1\":{\"242\":1}}],[\"usr\",{\"1\":{\"318\":5}}],[\"user=root\",{\"1\":{\"312\":1}}],[\"username\",{\"1\":{\"308\":1}}],[\"use\",{\"1\":{\"229\":1,\"231\":1,\"232\":1}}],[\"used\",{\"1\":{\"229\":1,\"234\":1}}],[\"using\",{\"1\":{\"191\":1,\"234\":1,\"243\":1}}],[\"u\",{\"1\":{\"111\":1,\"112\":1}}],[\"units<\",{\"1\":{\"238\":1}}],[\"unicode\",{\"1\":{\"238\":1,\"240\":1,\"243\":1}}],[\"unspecified\",{\"1\":{\"234\":1}}],[\"unsafe\",{\"1\":{\"111\":1}}],[\"unlimited\",{\"1\":{\"318\":1}}],[\"unless\",{\"1\":{\"232\":1}}],[\"unlock\",{\"1\":{\"97\":1,\"264\":1}}],[\"unnecessary\",{\"1\":{\"231\":1,\"232\":1}}],[\"untreeify\",{\"1\":{\"74\":1}}],[\"utils\",{\"1\":{\"292\":1}}],[\"util\",{\"1\":{\"43\":1,\"140\":1}}],[\"8u141\",{\"1\":{\"313\":2}}],[\"8443\",{\"1\":{\"296\":1,\"305\":1}}],[\"8038\",{\"1\":{\"318\":6}}],[\"80\",{\"1\":{\"296\":2,\"316\":5}}],[\"8080\",{\"1\":{\"296\":1,\"323\":1}}],[\"8的时候\",{\"1\":{\"227\":1}}],[\"8\",{\"0\":{\"254\":1},\"1\":{\"74\":3,\"202\":1,\"249\":2,\"318\":1}}],[\"8中提供了两个元注解\",{\"1\":{\"26\":1}}],[\"次方\",{\"0\":{\"283\":1},\"1\":{\"74\":1}}],[\"498\",{\"1\":{\"310\":1}}],[\"443\",{\"1\":{\"296\":2}}],[\"404\",{\"1\":{\"326\":1}}],[\"40\",{\"0\":{\"286\":1}}],[\"4\",{\"0\":{\"245\":1,\"250\":1,\"301\":1},\"1\":{\"74\":1,\"191\":1,\"193\":1,\"249\":3,\"303\":6}}],[\"以提高效率\",{\"1\":{\"264\":1}}],[\"以此来提升性能\",{\"1\":{\"254\":1}}],[\"以及对他的动态访问权限\",{\"1\":{\"275\":1}}],[\"以及他们之间的关系\",{\"0\":{\"271\":1}}],[\"以及他们的封装类\",{\"0\":{\"249\":1}}],[\"以及$\",{\"1\":{\"190\":1}}],[\"以给用户带来较好的体验\",{\"1\":{\"209\":1}}],[\"以应对被使用的内存中所有对象都100\",{\"1\":{\"208\":1}}],[\"以x86为例的话\",{\"1\":{\"162\":1}}],[\"以分时复用\",{\"1\":{\"88\":1}}],[\"以均衡与内存的速度差异\",{\"1\":{\"88\":1}}],[\"以下是\",{\"1\":{\"74\":1}}],[\"以保证擦除类型后的代码仍然具有泛型的\",{\"1\":{\"17\":1}}],[\"且返回newvalue\",{\"1\":{\"73\":1}}],[\"且添加到集合中\",{\"1\":{\"73\":1}}],[\"到\",{\"1\":{\"73\":1}}],[\"获得字符串的第几个字符\",{\"0\":{\"240\":1}}],[\"获得共享锁的线程只能读数据\",{\"1\":{\"147\":1}}],[\"获得排它锁的线程即能读数据又能修改数据\",{\"1\":{\"147\":1}}],[\"获得元素中的所有\",{\"1\":{\"73\":1}}],[\"获取的时候先通过\",{\"1\":{\"262\":1}}],[\"获取不到才会到等待队列的队尾等待\",{\"1\":{\"145\":1}}],[\"获取新的\",{\"1\":{\"73\":1}}],[\"获取\",{\"0\":{\"211\":1},\"1\":{\"73\":2,\"275\":1}}],[\"获取所有的\",{\"1\":{\"73\":1}}],[\"获取元素的\",{\"1\":{\"73\":1}}],[\"获取对象的字符组\",{\"1\":{\"244\":1}}],[\"获取对象的\",{\"1\":{\"73\":1}}],[\"获取单列数据集合中存储数据的数量\",{\"1\":{\"47\":1}}],[\"对方法添加了同步锁或者调用的方法添加了同步锁\",{\"1\":{\"255\":1}}],[\"对代理对象类的class文件加载进来\",{\"1\":{\"223\":1}}],[\"对比\",{\"0\":{\"222\":1}}],[\"对\",{\"1\":{\"190\":1}}],[\"对i加1\",{\"1\":{\"168\":1}}],[\"对final域的读\",{\"1\":{\"162\":1}}],[\"对final修饰的对象的成员域读操作\",{\"0\":{\"160\":1}}],[\"对final修饰的对象的成员域写操作\",{\"0\":{\"159\":1}}],[\"对静态方法\",{\"1\":{\"130\":1}}],[\"对线程\",{\"1\":{\"97\":1,\"264\":1}}],[\"对一个\",{\"0\":{\"173\":1},\"1\":{\"97\":1,\"264\":1}}],[\"对于任意个对象\",{\"1\":{\"275\":1}}],[\"对于任意一个类\",{\"1\":{\"275\":1}}],[\"对于\",{\"1\":{\"264\":1}}],[\"对于内存的划分方式和管理机制存在着部分差异\",{\"1\":{\"201\":1}}],[\"对于处理器重排序\",{\"1\":{\"92\":1}}],[\"对于编译器来说\",{\"1\":{\"174\":1}}],[\"对于编译器\",{\"1\":{\"92\":1}}],[\"对应的值\",{\"1\":{\"73\":2}}],[\"对应的值为\",{\"1\":{\"73\":1}}],[\"对应的值且等于\",{\"1\":{\"73\":1}}],[\"对应的\",{\"1\":{\"73\":4}}],[\"对象终结规则\",{\"1\":{\"97\":1,\"264\":1}}],[\"对象的四种方式\",{\"1\":{\"275\":1}}],[\"对象的结束先行发生于\",{\"1\":{\"97\":1,\"264\":1}}],[\"对象的\",{\"1\":{\"97\":1,\"264\":1}}],[\"对象\",{\"1\":{\"3\":1,\"73\":1,\"275\":2}}],[\"移出\",{\"1\":{\"73\":1}}],[\"移出通过\",{\"1\":{\"47\":1}}],[\"添加源码管理并指定分支\",{\"1\":{\"318\":1}}],[\"添加节点\",{\"1\":{\"298\":1}}],[\"添加集群\",{\"1\":{\"298\":1}}],[\"添加集合中的所有元素\",{\"1\":{\"73\":1}}],[\"添加docker源\",{\"1\":{\"293\":1}}],[\"添加\",{\"0\":{\"304\":1},\"1\":{\"73\":1,\"318\":1}}],[\"添加元素时先让modcount\",{\"1\":{\"52\":1}}],[\"元素数目\",{\"1\":{\"74\":1}}],[\"元素\",{\"1\":{\"73\":1}}],[\"元素个数是否是0\",{\"1\":{\"73\":1}}],[\"元注解是用于定义注解的注解\",{\"1\":{\"24\":1}}],[\"元注解\",{\"0\":{\"26\":1},\"1\":{\"24\":1}}],[\"查看指定的命名空间和服务名称\",{\"1\":{\"320\":1}}],[\"查看\",{\"0\":{\"320\":1}}],[\"查看打包过程\",{\"0\":{\"319\":1}}],[\"查看节点\",{\"1\":{\"306\":1}}],[\"查看元素数目\",{\"1\":{\"73\":1}}],[\"查找\",{\"1\":{\"262\":1}}],[\"查询元素在集合的下标索引\",{\"1\":{\"53\":1}}],[\"抽象了键值对数据集合的通用方法\",{\"1\":{\"73\":1}}],[\"抽象方法的返回值就是泛型类型\",{\"1\":{\"12\":1}}],[\"然后复制执行命令在相应的主机执行命令即可\",{\"1\":{\"299\":1,\"300\":1}}],[\"然后填写创建的配置\",{\"1\":{\"298\":1}}],[\"然后每次迭代都会进行比较\",{\"1\":{\"280\":1}}],[\"然后重写\",{\"1\":{\"277\":1}}],[\"然后在使用的时候一一调用则可\",{\"1\":{\"248\":1}}],[\"然后用按说把这些步骤一步一步的实现\",{\"1\":{\"248\":1}}],[\"然后再循环比较每个字符忽略大小写比较\",{\"1\":{\"242\":1}}],[\"然后再把已使用过的内存空间一次清理掉\",{\"1\":{\"208\":1}}],[\"然后判断是否为空\",{\"1\":{\"242\":1}}],[\"然后直接清理掉端边界以外的内存\",{\"1\":{\"208\":1}}],[\"然后赋值为10\",{\"1\":{\"90\":1}}],[\"然后\",{\"1\":{\"58\":1}}],[\"然后通过system\",{\"1\":{\"53\":1}}],[\"赋值\",{\"1\":{\"58\":1}}],[\"刚创建时\",{\"1\":{\"58\":1}}],[\"该对象的final域全部已经初始化过\",{\"1\":{\"161\":1}}],[\"该方法只是对线程调度器的一个建议\",{\"1\":{\"130\":1}}],[\"该方法返回后\",{\"1\":{\"47\":1}}],[\"该下标的数据是否是树\",{\"1\":{\"75\":1}}],[\"该元素在\",{\"1\":{\"75\":1}}],[\"该类的构造方法并未进行特殊的处理\",{\"1\":{\"56\":1}}],[\"也正因为如此\",{\"1\":{\"271\":1}}],[\"也可以设置为adminonly\",{\"1\":{\"308\":1}}],[\"也可以设置https\",{\"1\":{\"308\":1}}],[\"也可以通过参数控制gc的时间不大于多少毫秒或者比例\",{\"1\":{\"209\":1}}],[\"也可能正在等待\",{\"1\":{\"119\":1}}],[\"也没有查找到\",{\"1\":{\"191\":1}}],[\"也没加载过\",{\"1\":{\"191\":1}}],[\"也是实现collection\",{\"1\":{\"55\":1}}],[\"也就避免了覆盖了核心类库的问题\",{\"1\":{\"191\":1}}],[\"也就说前面对final基本数据类型的重排序规则在这里还是使用\",{\"1\":{\"159\":1}}],[\"也就是无法被继承\",{\"1\":{\"151\":1}}],[\"也就是说程序是静态的代码\",{\"1\":{\"271\":1}}],[\"也就是说\",{\"1\":{\"162\":1}}],[\"也就是说在泛型使用过程中\",{\"1\":{\"8\":1}}],[\"也就是说可以使用\",{\"1\":{\"3\":1}}],[\"也就找不到对应的类字节码文件\",{\"1\":{\"21\":1}}],[\"扩容时下次数量\",{\"1\":{\"74\":1}}],[\"扩容代码如下\",{\"1\":{\"52\":1}}],[\"扩展方法\",{\"0\":{\"54\":1,\"60\":1,\"66\":1}}],[\"提升权限\",{\"0\":{\"312\":1}}],[\"提升直接通过\",{\"1\":{\"254\":1}}],[\"提高灵活性\",{\"1\":{\"275\":1}}],[\"提高软件的可重用性\",{\"1\":{\"2\":1}}],[\"提供有关类和接口的属性信息\",{\"1\":{\"275\":1}}],[\"提供了内存屏障阻止这种重排序\",{\"1\":{\"174\":1}}],[\"提供了两种锁机制来控制多个线程对共享资源的互斥访问\",{\"1\":{\"135\":1}}],[\"提示在并发修改\",{\"1\":{\"53\":1}}],[\"会自增\",{\"1\":{\"280\":1}}],[\"会自动使用serial\",{\"1\":{\"209\":1}}],[\"会\",{\"1\":{\"268\":1}}],[\"会报错\",{\"1\":{\"267\":1}}],[\"会隐式自动转换\",{\"1\":{\"267\":1}}],[\"会尝试将其内联\",{\"1\":{\"264\":1}}],[\"会存在哈希冲突\",{\"1\":{\"262\":1}}],[\"会失败\",{\"1\":{\"224\":1}}],[\"会在指令序列中插入内存屏障来禁止特定类型的处理器重排序\",{\"1\":{\"174\":1}}],[\"会针对编译器制定\",{\"1\":{\"174\":1}}],[\"会允许编译器和处理器对指令序列进行重排序\",{\"1\":{\"174\":1}}],[\"会释放锁\",{\"1\":{\"139\":1}}],[\"会将当前线程挂起\",{\"1\":{\"137\":1}}],[\"会分别经历下面三种重排序\",{\"1\":{\"92\":1}}],[\"会先把i的初始值加载到cpu1的高速缓存中\",{\"1\":{\"90\":1}}],[\"会先进行判断\",{\"1\":{\"75\":1}}],[\"会先去取\",{\"1\":{\"75\":1}}],[\"会缓存modcount\",{\"1\":{\"53\":1}}],[\"会给属性\",{\"1\":{\"50\":3}}],[\"批量删除时\",{\"1\":{\"53\":1}}],[\"删除数据是开销较大\",{\"1\":{\"256\":1}}],[\"删除则是查询到对应的节点后\",{\"1\":{\"59\":1}}],[\"删除\",{\"0\":{\"53\":1,\"59\":1,\"65\":1},\"1\":{\"73\":1}}],[\"删除单列数据集合中的该数据\",{\"1\":{\"47\":1}}],[\"倍之后是否超出\",{\"1\":{\"52\":1}}],[\"倍扩容\",{\"1\":{\"52\":1}}],[\"时间\",{\"1\":{\"271\":1}}],[\"时间结束\",{\"1\":{\"122\":3}}],[\"时间片\",{\"1\":{\"119\":1,\"121\":1,\"200\":1}}],[\"时\",{\"1\":{\"52\":1,\"74\":1,\"75\":1}}],[\"判断一个对象是都可以被回收的最后一步就是判断是否重写了此方法\",{\"1\":{\"277\":1}}],[\"判断开始位置和结束位置是否超出\",{\"1\":{\"244\":1}}],[\"判断字符串是否从某个字符串开始的\",{\"0\":{\"244\":1}}],[\"判断是否设置了delegate属性\",{\"1\":{\"191\":1}}],[\"判断若当前链表的数量大于默认树化的数目\",{\"1\":{\"75\":1}}],[\"判断集合中是否存在该元素是通过遍历集合的属性elementdata的数据\",{\"1\":{\"51\":1}}],[\"判断\",{\"0\":{\"51\":1,\"57\":1,\"63\":1},\"1\":{\"250\":1}}],[\"0d\",{\"1\":{\"249\":1}}],[\"0l\",{\"1\":{\"249\":1}}],[\"0f\",{\"1\":{\"249\":1}}],[\"0\",{\"0\":{\"266\":2},\"1\":{\"50\":5,\"52\":6,\"62\":1,\"74\":2,\"75\":1,\"160\":1,\"191\":2,\"229\":2,\"231\":1,\"234\":1,\"239\":3,\"240\":4,\"241\":2,\"242\":2,\"243\":5,\"244\":3,\"249\":5,\"308\":2,\"313\":2}}],[\"若主机名重复\",{\"1\":{\"302\":1}}],[\"若类重写了\",{\"1\":{\"282\":1}}],[\"若不是树\",{\"1\":{\"75\":1}}],[\"若不为空\",{\"1\":{\"73\":1}}],[\"若不存在\",{\"1\":{\"73\":1}}],[\"若不存在在返回\",{\"1\":{\"73\":1}}],[\"若\",{\"1\":{\"73\":1,\"75\":1,\"262\":1,\"302\":1}}],[\"若存在多个则通过\",{\"1\":{\"262\":1}}],[\"若存在哈希冲突则需要判断\",{\"1\":{\"75\":1}}],[\"若存在\",{\"1\":{\"73\":2}}],[\"若是返回\",{\"1\":{\"250\":1}}],[\"若是树则进行添加子节点\",{\"1\":{\"75\":1}}],[\"若是存在key\",{\"1\":{\"73\":1}}],[\"若是不能确定则看运行时\",{\"1\":{\"250\":1}}],[\"若是不存在\",{\"1\":{\"73\":1}}],[\"若是不一致则会抛出concurrentmodificationexception异常\",{\"1\":{\"53\":1}}],[\"若是会超过则取\",{\"1\":{\"52\":1}}],[\"若是无参的构造方法\",{\"1\":{\"52\":1}}],[\"若初始元素数量大于\",{\"1\":{\"50\":1}}],[\"若初始元素数量等于\",{\"1\":{\"50\":1}}],[\"若设置容量小于\",{\"1\":{\"50\":1}}],[\"若设置容量等于\",{\"1\":{\"50\":1}}],[\"若设置容量大于\",{\"1\":{\"50\":1}}],[\"若都存在则返回\",{\"1\":{\"47\":1}}],[\"内部基于数组进行存储的\",{\"1\":{\"256\":1}}],[\"内部都是可变数组\",{\"1\":{\"255\":1}}],[\"内部是基于链表进行存储的\",{\"1\":{\"256\":1}}],[\"内部是\",{\"1\":{\"255\":1}}],[\"内部存在存在有缓存\",{\"1\":{\"251\":1}}],[\"内部的实现原理是通过数组进行缓存元素数据\",{\"1\":{\"49\":1}}],[\"内聚性更高\",{\"1\":{\"247\":1}}],[\"内存空间\",{\"1\":{\"271\":1}}],[\"内存映像工具\",{\"1\":{\"214\":1}}],[\"内存分配时也就不用考虑内存碎片等复杂情况\",{\"1\":{\"208\":1}}],[\"内存缩小为原来的一半\",{\"1\":{\"208\":1}}],[\"内存布局规定了\",{\"1\":{\"201\":1}}],[\"内存区域是很重要的系统资源\",{\"1\":{\"201\":1}}],[\"内存语义时\",{\"1\":{\"174\":1}}],[\"内存屏障\",{\"1\":{\"171\":1,\"174\":1}}],[\"内存模型规范了\",{\"1\":{\"93\":1}}],[\"内存系统的重排序\",{\"1\":{\"92\":1}}],[\"内存\",{\"1\":{\"88\":1}}],[\"内容如下\",{\"1\":{\"308\":1,\"323\":1,\"324\":1}}],[\"内容\",{\"1\":{\"12\":1,\"318\":1}}],[\"功能更加强大\",{\"1\":{\"48\":1}}],[\"由此可见\",{\"1\":{\"235\":1}}],[\"由于不会对有间接依赖性的操作重排序\",{\"1\":{\"162\":1}}],[\"由于\",{\"1\":{\"106\":1}}],[\"由于synchronized和lock能够保证任一时刻只有一个线程执行该代码块\",{\"1\":{\"98\":1}}],[\"由于处理器使用缓存和读\",{\"1\":{\"92\":1}}],[\"由于cpu分时复用\",{\"1\":{\"91\":1}}],[\"由于加锁问题\",{\"1\":{\"48\":1}}],[\"由上面的分析可知\",{\"1\":{\"90\":1}}],[\"由外部指定\",{\"1\":{\"11\":1}}],[\"加速\",{\"1\":{\"295\":1}}],[\"加载的类信息存放于一块称为方法区的内存空间\",{\"1\":{\"196\":1}}],[\"加载不到同样也会委托给\",{\"1\":{\"191\":1}}],[\"加载流程\",{\"0\":{\"191\":1}}],[\"加载\",{\"0\":{\"188\":1}}],[\"加一\",{\"1\":{\"52\":1}}],[\"加锁\",{\"1\":{\"48\":1}}],[\"加上\",{\"1\":{\"26\":1}}],[\"索引查询慢\",{\"1\":{\"48\":1}}],[\"索引查询快\",{\"1\":{\"48\":1}}],[\"缺点是处于等待队列中的线程可能会饿死\",{\"1\":{\"145\":1}}],[\"缺点是整体吞吐效率相对非公平锁要低\",{\"1\":{\"145\":1}}],[\"缺点\",{\"1\":{\"48\":1,\"208\":2,\"275\":1}}],[\"可通过cookiecutter进行模板化生成\",{\"1\":{\"321\":1}}],[\"可设置通知\",{\"1\":{\"315\":1}}],[\"可设置定时构建\",{\"1\":{\"315\":1}}],[\"可指定文件执行\",{\"1\":{\"315\":1}}],[\"可靠安全\",{\"1\":{\"247\":1}}],[\"可看出\",{\"1\":{\"236\":1}}],[\"可见这会使得cpu的利用率尽可能的高\",{\"1\":{\"209\":1}}],[\"可见性实现\",{\"0\":{\"171\":1}}],[\"可见性\",{\"0\":{\"90\":1,\"99\":1}}],[\"可见性问题主要指一个线程修改了共享变量值\",{\"1\":{\"166\":1}}],[\"可见性问题\",{\"1\":{\"88\":1}}],[\"可达性分析\",{\"1\":{\"207\":1}}],[\"可使用锁或者volatile\",{\"1\":{\"160\":1}}],[\"可重入锁的一个优点是可一定程度避免死锁\",{\"1\":{\"146\":1}}],[\"可重入锁又名递归锁\",{\"1\":{\"146\":1}}],[\"可重入锁\",{\"0\":{\"146\":1}}],[\"可重入代码有一些共同的特征\",{\"1\":{\"116\":1}}],[\"可能得\",{\"1\":{\"262\":1}}],[\"可能会导致无法访问\",{\"1\":{\"296\":1}}],[\"可能会产生较长的停顿\",{\"1\":{\"209\":1}}],[\"可能会抛出\",{\"1\":{\"129\":1}}],[\"可能还包括字符串字而量和数字常量\",{\"1\":{\"196\":1}}],[\"可能正在运行\",{\"1\":{\"119\":1}}],[\"可运行\",{\"0\":{\"119\":1}}],[\"可选操作\",{\"1\":{\"47\":1}}],[\"可以重复\",{\"1\":{\"276\":1}}],[\"可以重新安排语句的执行顺序\",{\"1\":{\"92\":1}}],[\"可以调用包装类的\",{\"1\":{\"275\":1}}],[\"可以抛出的异常有三种\",{\"1\":{\"269\":1}}],[\"可以设计出低耦合的系统\",{\"1\":{\"248\":1}}],[\"可以指定运行脚本等\",{\"1\":{\"315\":1}}],[\"可以指定gc线程数\",{\"1\":{\"209\":1}}],[\"可以指定等待的条件\",{\"1\":{\"140\":1}}],[\"可以被\",{\"1\":{\"190\":1}}],[\"可以在指定目录下载\",{\"1\":{\"307\":1}}],[\"可以在\",{\"1\":{\"140\":1}}],[\"可以在代码执行的任何时刻中断它\",{\"1\":{\"116\":1}}],[\"可以切换给其它线程来执行\",{\"1\":{\"130\":1}}],[\"可以说任务是通过线程驱动从而执行的\",{\"1\":{\"124\":1}}],[\"可以是线程结束任务之后自己结束\",{\"1\":{\"123\":1}}],[\"可以使用ip\",{\"1\":{\"308\":1}}],[\"可以使用任何类作为\",{\"0\":{\"282\":1}}],[\"可以使用\",{\"1\":{\"115\":1,\"143\":1,\"209\":1}}],[\"可以存在链表长度大于\",{\"1\":{\"74\":1}}],[\"可以根据这个类名进行加载实例化\",{\"1\":{\"43\":1}}],[\"可以根据自己的需求定义注解\",{\"1\":{\"24\":1}}],[\"可以用来启用框架扩展和替换组件\",{\"1\":{\"43\":1}}],[\"可以对包\",{\"1\":{\"24\":1}}],[\"可以通过实现该接口定义横切逻辑\",{\"1\":{\"217\":1}}],[\"可以通过参数来打开自适应调节策略\",{\"1\":{\"209\":1}}],[\"可以通过volatile关键字来保证一定的\",{\"1\":{\"100\":1}}],[\"可以通过synchronized和lock来实现\",{\"1\":{\"98\":1}}],[\"可以通过\",{\"1\":{\"97\":1,\"264\":1}}],[\"可以通过反射进行获取参数的实际类型\",{\"1\":{\"22\":1}}],[\"可以通过反射实现\",{\"1\":{\"21\":1}}],[\"可以通过剖析确定哪些模块影响了系统的性能\",{\"1\":{\"2\":1}}],[\"可以当做\",{\"1\":{\"3\":1}}],[\"可以继承自\",{\"1\":{\"3\":1}}],[\"可以更容易被程序员理解\",{\"1\":{\"2\":1}}],[\"可以独立地开发\",{\"1\":{\"2\":1}}],[\"从gc\",{\"1\":{\"207\":1}}],[\"从appclassloader中查找是否加载过此类\",{\"1\":{\"191\":1}}],[\"从本地缓存中查找是否加载过此类\",{\"1\":{\"191\":1}}],[\"从\",{\"1\":{\"92\":1}}],[\"从内存读取到\",{\"1\":{\"91\":1}}],[\"从而抛出\",{\"1\":{\"280\":1}}],[\"从而实现同一应用运行在任何地方\",{\"1\":{\"288\":1}}],[\"从而实现自定义比较方法\",{\"1\":{\"241\":1}}],[\"从而实现该节点的删除\",{\"1\":{\"59\":1}}],[\"从而创建对象\",{\"1\":{\"233\":1}}],[\"从而导致不可预料的结果\",{\"1\":{\"165\":1}}],[\"从而保证该对象对所有线程可见时\",{\"1\":{\"161\":1}}],[\"从而保证了原子性\",{\"1\":{\"98\":1}}],[\"从而避免切换线程的开销\",{\"1\":{\"143\":1}}],[\"从而提前结束线程\",{\"1\":{\"133\":1}}],[\"从而提前结束该线程\",{\"1\":{\"132\":1}}],[\"从而先新元素的添加\",{\"1\":{\"58\":1}}],[\"从而获得\",{\"1\":{\"3\":1}}],[\"从此集合中移除所有元素\",{\"1\":{\"47\":1}}],[\"从该集合中删除未包含在指定集合中的所有元素\",{\"1\":{\"47\":1}}],[\"筛选的数据集合\",{\"1\":{\"47\":1}}],[\"向当前单列数据集合中添加该数据结合\",{\"1\":{\"47\":1}}],[\"向上转型\",{\"1\":{\"3\":1,\"4\":1}}],[\"校验当前数据集合是否在该单列数据中\",{\"1\":{\"47\":1}}],[\"数据库\",{\"0\":{\"328\":1}}],[\"数据库认证\",{\"1\":{\"308\":1}}],[\"数据类型代替的\",{\"1\":{\"249\":1}}],[\"数据分析\",{\"0\":{\"212\":1}}],[\"数据\",{\"0\":{\"211\":1}}],[\"数据长度也是通过属性进行获取的\",{\"1\":{\"55\":1}}],[\"数据被保护在抽象数据类型的内部\",{\"1\":{\"2\":1}}],[\"数组不可以自动扩容\",{\"1\":{\"279\":1}}],[\"数组中是\",{\"1\":{\"249\":1}}],[\"数组则会被编译成\",{\"1\":{\"249\":1}}],[\"数组\",{\"1\":{\"48\":1,\"249\":1}}],[\"数组类型为参数类型\",{\"1\":{\"47\":1}}],[\"单独使用时是\",{\"1\":{\"249\":1}}],[\"单次读\",{\"0\":{\"167\":1}}],[\"单位为毫秒\",{\"1\":{\"129\":1}}],[\"单一线程原则\",{\"1\":{\"97\":1,\"264\":1}}],[\"单个删除时\",{\"1\":{\"53\":1}}],[\"单列数据集合添加数据\",{\"1\":{\"47\":1}}],[\"单列数据集合转数组\",{\"1\":{\"47\":1}}],[\"单列数据结合转数组\",{\"1\":{\"47\":1}}],[\"单元泛型\",{\"1\":{\"11\":1}}],[\"一套是针对标准的输入输出\",{\"1\":{\"274\":1}}],[\"一旦发生冲突\",{\"1\":{\"262\":1}}],[\"一直想等则返回长度差值\",{\"1\":{\"243\":1}}],[\"一组寄存器\",{\"1\":{\"185\":1}}],[\"一般处理器不会重排序这两个操作\",{\"1\":{\"157\":1}}],[\"一般都是以jar包做依赖\",{\"1\":{\"43\":1}}],[\"一个进程就是一个执行的程序\",{\"1\":{\"271\":1}}],[\"一个进程在其执行的过程中可以产生多个小城\",{\"1\":{\"271\":1}}],[\"一个是效率问题\",{\"1\":{\"208\":1}}],[\"一个垃圾回收堆和一个存储方法域\",{\"1\":{\"185\":1}}],[\"一个栈\",{\"1\":{\"185\":1}}],[\"一个线程执行完毕之后会自动结束\",{\"1\":{\"131\":1}}],[\"一个任务创建一个线程\",{\"1\":{\"127\":1}}],[\"一个请求对应一个服务器线程\",{\"1\":{\"115\":1}}],[\"一个对象的初始化完成\",{\"1\":{\"97\":1,\"264\":1}}],[\"一个\",{\"1\":{\"97\":1,\"264\":1}}],[\"一致\",{\"1\":{\"47\":1,\"48\":2,\"63\":1,\"262\":1}}],[\"hub\",{\"1\":{\"308\":1}}],[\"hugecapacity\",{\"1\":{\"52\":2}}],[\"html\",{\"1\":{\"238\":1,\"240\":1}}],[\"https\",{\"1\":{\"212\":1,\"295\":1,\"303\":3,\"305\":1,\"307\":1,\"311\":2,\"313\":1}}],[\"http\",{\"1\":{\"212\":3,\"293\":1,\"308\":1,\"313\":1,\"316\":1,\"318\":1,\"324\":1}}],[\"href=\",{\"1\":{\"238\":1,\"240\":1}}],[\"header\",{\"1\":{\"313\":1}}],[\"heaphero\",{\"1\":{\"212\":1}}],[\"hence\",{\"1\":{\"234\":1}}],[\"helloproxytest\",{\"1\":{\"221\":1}}],[\"helloproxy\",{\"1\":{\"221\":5}}],[\"hello\",{\"1\":{\"14\":1,\"218\":1,\"221\":10}}],[\"host\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"hostname\",{\"1\":{\"308\":1}}],[\"hostname设置访问地址\",{\"1\":{\"308\":1}}],[\"hostid\",{\"1\":{\"214\":1}}],[\"hotspot\",{\"1\":{\"201\":1}}],[\"home\",{\"1\":{\"190\":1}}],[\"harbor\",{\"0\":{\"307\":1,\"308\":1,\"309\":1},\"1\":{\"288\":1,\"307\":3,\"308\":3,\"310\":1}}],[\"handler\",{\"1\":{\"218\":2}}],[\"have\",{\"1\":{\"191\":1,\"243\":2}}],[\"has\",{\"1\":{\"243\":1}}],[\"hasexternalrepositories\",{\"1\":{\"191\":1}}],[\"hashtable\",{\"0\":{\"78\":1,\"257\":1,\"281\":1},\"1\":{\"105\":1,\"257\":1}}],[\"hash\",{\"1\":{\"75\":1,\"229\":2,\"231\":1,\"232\":3}}],[\"hashmap的扩缩容\",{\"0\":{\"75\":1}}],[\"hashmap\",{\"0\":{\"74\":1,\"257\":1,\"281\":1,\"282\":1,\"283\":1,\"284\":1},\"1\":{\"74\":2,\"105\":1,\"257\":1,\"262\":1}}],[\"hashset\",{\"0\":{\"68\":1}}],[\"hashcode\",{\"0\":{\"254\":1,\"262\":1},\"1\":{\"47\":3,\"75\":1,\"254\":2,\"262\":2,\"277\":1,\"282\":3}}],[\"happens\",{\"0\":{\"97\":1,\"173\":2},\"1\":{\"93\":1,\"264\":1}}],[\"h\",{\"1\":{\"75\":2}}],[\"它也应该重写\",{\"1\":{\"282\":1}}],[\"它在计算机中一个指令接着一个指令的执行着没同事\",{\"1\":{\"271\":1}}],[\"它允许我们在运行时对字节码进行修改和动态生成\",{\"1\":{\"220\":1}}],[\"它将可用内存按容量划分为大小相等的两块\",{\"1\":{\"208\":1}}],[\"它可以看作是当前线程所执行的字节码的行号指示器\",{\"1\":{\"197\":1,\"200\":1}}],[\"它可以通过控制变量值的版本来保证\",{\"1\":{\"112\":1}}],[\"它为什么可以隔离每个\",{\"1\":{\"190\":1}}],[\"它是一个虚构出来的计算机\",{\"1\":{\"185\":1}}],[\"它是在等待获取一个排它锁\",{\"1\":{\"122\":1}}],[\"它不能代替阻塞\",{\"1\":{\"143\":1}}],[\"它们都属于\",{\"1\":{\"138\":1}}],[\"它的值被改成了\",{\"1\":{\"112\":1}}],[\"它都要进行加锁\",{\"1\":{\"108\":1}}],[\"它会先尝试自己去加载\",{\"1\":{\"190\":1}}],[\"它会先去主存读取i的值并加载到cpu2的缓存当中\",{\"1\":{\"90\":1}}],[\"它会去内存中读取新值\",{\"1\":{\"99\":1}}],[\"它会保证修改的值会立即被更新到主存\",{\"1\":{\"99\":1}}],[\"它包含以下方法\",{\"1\":{\"73\":1}}],[\"它包含了以下的方法\",{\"1\":{\"47\":1}}],[\"它内部的数据接口是采用链表的方式进行存储\",{\"1\":{\"55\":1}}],[\"它实现了\",{\"1\":{\"49\":1}}],[\"它抽象了单列数据集合的基本方法\",{\"1\":{\"47\":1}}],[\"它主要的作用有以下四方面\",{\"1\":{\"24\":1}}],[\"↩︎\",{\"1\":{\"45\":1}}],[\"必须被装载到\",{\"1\":{\"185\":1}}],[\"必须能够替换掉他们的基类型\",{\"1\":{\"45\":1}}],[\"必要时插入强制类型转换代码\",{\"1\":{\"17\":1}}],[\"jre\",{\"1\":{\"318\":1}}],[\"jobservice\",{\"1\":{\"310\":3}}],[\"job\",{\"1\":{\"308\":1}}],[\"join\",{\"0\":{\"137\":1},\"1\":{\"97\":1,\"121\":1,\"122\":1,\"137\":1,\"264\":1}}],[\"jh2wgcjjnmvq7m9l9rbr8qdw5fr7nrd2bjssjfngmcjrsxncdphf7d\",{\"1\":{\"305\":1}}],[\"jhat\",{\"1\":{\"214\":1}}],[\"jenkins\",{\"0\":{\"311\":1,\"314\":1,\"317\":1,\"318\":1},\"1\":{\"288\":1,\"311\":8,\"312\":5,\"314\":1}}],[\"jdbc\",{\"1\":{\"275\":2}}],[\"jdk1\",{\"1\":{\"234\":1}}],[\"jdk的动态代理机制只能代理实现了接口的类\",{\"1\":{\"226\":1}}],[\"jdk动态代理的速度已经比cglib动态代理的速度快很多了\",{\"1\":{\"227\":1}}],[\"jdk动态代理的速度要比cglib动态代理的速度要慢\",{\"1\":{\"227\":1}}],[\"jdk动态代理是面向接口的\",{\"1\":{\"224\":1}}],[\"jdk动态代理具体实现原理\",{\"1\":{\"223\":1}}],[\"jdk动态代理步骤\",{\"0\":{\"219\":1}}],[\"jdk动态代理主要涉及java\",{\"1\":{\"217\":1}}],[\"jdk中的synchronized和juc中lock的实现类就是互斥锁\",{\"1\":{\"147\":1}}],[\"jdk中查找服务的实现的工具类是\",{\"1\":{\"43\":1}}],[\"jdk\",{\"0\":{\"215\":1,\"217\":1},\"1\":{\"135\":1,\"229\":1,\"275\":1,\"313\":2}}],[\"jinfo\",{\"1\":{\"214\":2}}],[\"jit\",{\"0\":{\"205\":1},\"1\":{\"197\":1,\"202\":1,\"205\":1}}],[\"json\",{\"1\":{\"295\":1,\"323\":1}}],[\"jstack\",{\"1\":{\"214\":2}}],[\"jstat\",{\"1\":{\"214\":2}}],[\"jsp\",{\"1\":{\"214\":1}}],[\"jps\",{\"1\":{\"214\":1}}],[\"jmap\",{\"1\":{\"211\":1,\"214\":2}}],[\"jmm不保证线程b的写入对线程c可见\",{\"1\":{\"160\":1}}],[\"jmm会禁止这两个操作的重排序\",{\"1\":{\"157\":1}}],[\"jmm禁止编译器把final域的写重排序到构造函数之外\",{\"1\":{\"156\":1}}],[\"jmm\",{\"1\":{\"92\":2,\"171\":1,\"174\":4}}],[\"jar\",{\"1\":{\"190\":2,\"318\":3}}],[\"java提供了动态代理技术\",{\"1\":{\"217\":1}}],[\"java提供了volatile关键字来保证可见性\",{\"1\":{\"99\":1}}],[\"java8及之后堆内存分为\",{\"1\":{\"202\":1}}],[\"java8提供了哪些新的注解\",{\"0\":{\"29\":1}}],[\"javaseloader\",{\"1\":{\"191\":2}}],[\"javac\",{\"1\":{\"186\":1}}],[\"java原子类中的递增操作就通过cas自旋实现的\",{\"1\":{\"142\":1}}],[\"java中reentrantlock和synchronized都是可重入锁\",{\"1\":{\"146\":1}}],[\"java中\",{\"1\":{\"142\":1}}],[\"java中spi机制主要思想是将装配的控制权移到程序之外\",{\"1\":{\"43\":1}}],[\"java内存模型只保证了基本读取和赋值是原子性操作\",{\"1\":{\"98\":1}}],[\"java是怎么解决并发问题的\",{\"0\":{\"93\":1}}],[\"java集合框架\",{\"0\":{\"46\":1}}],[\"java注解的本质以及注解的底层实现原理\",{\"1\":{\"31\":1}}],[\"javadoc\",{\"1\":{\"26\":1}}],[\"java自带的标准注解\",{\"0\":{\"25\":1},\"1\":{\"24\":1}}],[\"java泛型的实现采取了\",{\"1\":{\"16\":1}}],[\"java泛型这个特性是从jdk\",{\"1\":{\"16\":1}}],[\"java\",{\"0\":{\"87\":1,\"141\":1,\"184\":1,\"246\":1,\"247\":1,\"259\":1,\"261\":1,\"273\":1,\"275\":1},\"1\":{\"14\":1,\"21\":1,\"25\":1,\"43\":1,\"46\":1,\"92\":2,\"93\":1,\"105\":1,\"106\":1,\"115\":1,\"125\":1,\"135\":1,\"140\":1,\"174\":1,\"185\":6,\"186\":1,\"191\":2,\"193\":3,\"194\":1,\"195\":1,\"197\":4,\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":2,\"205\":1,\"214\":3,\"219\":2,\"234\":1,\"242\":2,\"247\":2,\"274\":1,\"313\":1,\"318\":2}}],[\"java7\",{\"1\":{\"6\":1}}],[\"java5\",{\"1\":{\"6\":1}}],[\"juc\",{\"0\":{\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":1}}],[\"jvm\",{\"0\":{\"185\":1,\"186\":1,\"211\":1,\"212\":1},\"1\":{\"93\":1,\"135\":1,\"185\":7,\"192\":1,\"197\":1,\"201\":3,\"203\":1,\"213\":1,\"214\":1,\"219\":1,\"247\":1,\"249\":1,\"264\":1}}],[\"j\",{\"1\":{\"90\":1,\"111\":1,\"112\":1}}],[\"当读取\",{\"1\":{\"264\":1}}],[\"当第一个\",{\"1\":{\"262\":1}}],[\"当\",{\"1\":{\"255\":1}}],[\"当cms进行gc失败时\",{\"1\":{\"209\":1}}],[\"当这一块的内存用完了\",{\"1\":{\"208\":1}}],[\"当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作\",{\"1\":{\"208\":1}}],[\"当一个对象到gc\",{\"1\":{\"207\":1}}],[\"当一个共享变量被volatile修饰时\",{\"1\":{\"99\":1}}],[\"当然虚拟机栈也可以动态的扩展\",{\"1\":{\"197\":1,\"199\":1}}],[\"当然jmm是通过happens\",{\"1\":{\"100\":1}}],[\"当线程申请的大于虚拟机栈的深度就会抛出\",{\"1\":{\"197\":1,\"199\":1}}],[\"当线程1执行\",{\"1\":{\"90\":1}}],[\"当某个类的整体定义为final时\",{\"1\":{\"150\":1}}],[\"当多个线程可以一起工作去解决某个问题时\",{\"1\":{\"136\":1}}],[\"当所有非守护线程结束时\",{\"1\":{\"128\":1}}],[\"当执行操作时\",{\"1\":{\"110\":1}}],[\"当其他线程的运行使得这个条件满足时\",{\"1\":{\"138\":1}}],[\"当其他线程去读取时\",{\"1\":{\"99\":1}}],[\"当其他的程序需要这个服务的时候\",{\"1\":{\"43\":1}}],[\"当有其他线程需要读取时\",{\"1\":{\"99\":1}}],[\"当进行新增时\",{\"1\":{\"75\":1}}],[\"当集合元素数目大于\",{\"1\":{\"74\":1}}],[\"当树的元素数量小于\",{\"1\":{\"74\":1}}],[\"当前对象的属性也进行复制\",{\"1\":{\"263\":1}}],[\"当前对象的属性还是引用之前对象的值\",{\"1\":{\"263\":1}}],[\"当前对象需要实现\",{\"1\":{\"47\":1}}],[\"当前线程将自己修改的数据成功写入\",{\"1\":{\"142\":1}}],[\"当前单列数据集合中移出指定的数据集合\",{\"1\":{\"47\":1}}],[\"当前单列数据集合是否为空\",{\"1\":{\"47\":1}}],[\"当前单列数据合计是否存在该数据对象\",{\"1\":{\"47\":1}}],[\"当服务的提供者提供了一种接口的实现之后\",{\"1\":{\"43\":1}}],[\"这两个操作之间不能重排序\",{\"1\":{\"264\":2}}],[\"这两个操作是不能被重排序的\",{\"1\":{\"159\":1}}],[\"这类应用尤其重视服务的响应速度\",{\"1\":{\"209\":1}}],[\"这部分常量信息是\",{\"1\":{\"196\":1}}],[\"这么做的目的就是\",{\"1\":{\"191\":1}}],[\"这么做的目的就是为了优先加载\",{\"1\":{\"190\":1}}],[\"这条禁止重排序规则就是针对这些处理器而设定的\",{\"1\":{\"157\":1}}],[\"这个收集器是在jdk\",{\"1\":{\"209\":1}}],[\"这个装载工作是由\",{\"1\":{\"185\":1}}],[\"这个规则仅仅是针对处理器\",{\"1\":{\"157\":1}}],[\"这个规则的实现主要包含了两个方面\",{\"1\":{\"156\":1}}],[\"这个屏障可以禁止处理器把final域的写重排序到构造函数之外\",{\"1\":{\"156\":1}}],[\"这个文件里的内容就是这个接口的具体的实现类\",{\"1\":{\"43\":1}}],[\"这就是自旋锁\",{\"1\":{\"143\":1}}],[\"这就是可见性问题\",{\"1\":{\"90\":1}}],[\"这是因为\",{\"1\":{\"138\":1}}],[\"这样就可以根据各个年代的特点采用最适当的收集算法\",{\"1\":{\"208\":1}}],[\"这样能保证任何情况下对long和double的单次读\",{\"1\":{\"169\":1}}],[\"这样\",{\"1\":{\"115\":1}}],[\"这种等待方式\",{\"1\":{\"140\":1}}],[\"这种代码也叫做纯代码\",{\"1\":{\"116\":1}}],[\"这种处理方式的广泛应用使得很多\",{\"1\":{\"115\":1}}],[\"这种乐观的并发策略的许多实现都不需要将线程阻塞\",{\"1\":{\"110\":1}}],[\"这种参数类型可以用在类\",{\"1\":{\"8\":1}}],[\"这里支持多种认证方式\",{\"1\":{\"308\":1}}],[\"这里是通过\",{\"1\":{\"191\":1}}],[\"这里的异步是指多个任务的执行互不干扰\",{\"1\":{\"127\":1}}],[\"这里就不能再使用互斥同步来保证了\",{\"1\":{\"110\":1}}],[\"这里讨论的是概念模型\",{\"1\":{\"108\":1}}],[\"这里判断对象是否存在也是进行数据遍历\",{\"1\":{\"57\":1}}],[\"这些屏障可以防止编译器和处理器在处理\",{\"1\":{\"264\":1}}],[\"这些方法包括\",{\"1\":{\"93\":1}}],[\"这些重排序都可能会导致多线程程序出现内存可见性问题\",{\"1\":{\"92\":1}}],[\"这使得加载和存储操作看上去可能是在乱序执行\",{\"1\":{\"92\":1}}],[\"需要\",{\"1\":{\"315\":1}}],[\"需要修改\",{\"1\":{\"310\":1}}],[\"需要下载kubectl工具对kubernetes进行操作\",{\"1\":{\"305\":1}}],[\"需要设置合盖不影响\",{\"1\":{\"301\":1}}],[\"需要选择\",{\"1\":{\"299\":1}}],[\"需要解析字节码\",{\"1\":{\"275\":1}}],[\"需要进行数组的处理\",{\"1\":{\"256\":1}}],[\"需要重写对象的equals方法\",{\"1\":{\"241\":1}}],[\"需要通过\",{\"1\":{\"241\":1}}],[\"需要打破双亲委托机制\",{\"1\":{\"191\":1}}],[\"需要在classpath下的meta\",{\"1\":{\"43\":1}}],[\"需要强转类型\",{\"1\":{\"15\":1}}],[\"而次次重新编写可能过于麻烦\",{\"1\":{\"321\":1}}],[\"而是为了描述某个事物在解决整个问题的过程中所发生的行为\",{\"1\":{\"248\":1}}],[\"而是让所有存活的对象都向一端移动\",{\"1\":{\"208\":1}}],[\"而建立对象的目的也不完全是为了完成一个个步骤\",{\"1\":{\"248\":1}}],[\"而老年代中因为对象存活率高\",{\"1\":{\"208\":1}}],[\"而本地方法栈是为虚拟机调用\",{\"1\":{\"197\":1,\"199\":1}}],[\"而另一个线程却看不到\",{\"1\":{\"166\":1}}],[\"而另一个是\",{\"1\":{\"135\":1}}],[\"而写线程b对数组元素的写入可能看到可能看不到\",{\"1\":{\"160\":1}}],[\"而轻量级锁是通过用cas操作和自旋来解决加锁问题\",{\"1\":{\"144\":1}}],[\"而为了让当前线程\",{\"1\":{\"143\":1}}],[\"而\",{\"1\":{\"139\":1,\"174\":1,\"249\":1}}],[\"而不能实现接口的类就不能实现jdk的动态代理\",{\"1\":{\"226\":1}}],[\"而不适用于交互较多的应用程序\",{\"1\":{\"209\":1}}],[\"而不属于\",{\"1\":{\"138\":1}}],[\"而不是忙等待\",{\"1\":{\"137\":1}}],[\"而不是10\",{\"1\":{\"90\":1}}],[\"而无需程序员显式地管理线程的生命周期\",{\"1\":{\"127\":1}}],[\"而等待是主动的\",{\"1\":{\"122\":1}}],[\"而阻塞和等待用来描述状态\",{\"1\":{\"122\":1}}],[\"而在控制权返回后\",{\"1\":{\"116\":1}}],[\"而且互不影响\",{\"1\":{\"200\":1}}],[\"而且也不允许别人这么做\",{\"1\":{\"150\":1}}],[\"而且也只是建议具有相同优先级的其它线程可以运行\",{\"1\":{\"130\":1}}],[\"而且通常都是有害的\",{\"1\":{\"106\":1}}],[\"而且在较长的时间内容\",{\"1\":{\"46\":1}}],[\"而普通的共享变量不能保证可见性\",{\"1\":{\"99\":1}}],[\"而java的spi机制可以为某个接口寻找服务实现\",{\"1\":{\"43\":1}}],[\"而参数不同\",{\"1\":{\"7\":1}}],[\"mydomain\",{\"1\":{\"308\":4}}],[\"mysql数据库认证\",{\"1\":{\"308\":1}}],[\"mysql数据库root用户默认密码root123\",{\"1\":{\"308\":1}}],[\"mysql\",{\"1\":{\"275\":1}}],[\"mysql和postgresql都有不同的实现提供给用户\",{\"1\":{\"43\":1}}],[\"mkdir\",{\"1\":{\"295\":1,\"318\":1,\"323\":1,\"324\":1}}],[\"more\",{\"1\":{\"234\":1,\"243\":1}}],[\"mode\",{\"1\":{\"308\":1}}],[\"modification\",{\"1\":{\"233\":1,\"235\":1,\"236\":1}}],[\"modcount\",{\"1\":{\"74\":1,\"280\":2}}],[\"metadata\",{\"1\":{\"316\":4,\"318\":4,\"324\":4}}],[\"methodproxy\",{\"1\":{\"221\":1}}],[\"methodinterceptor\",{\"1\":{\"221\":1}}],[\"method\",{\"1\":{\"218\":3,\"221\":2,\"236\":1,\"242\":2,\"243\":1,\"275\":1}}],[\"memory\",{\"1\":{\"92\":2,\"171\":2}}],[\"mm可以确保线程c至少能看到写线程a对final引用的对象的成员域的写入\",{\"1\":{\"160\":1}}],[\"mirror\",{\"1\":{\"295\":1}}],[\"mirrors\",{\"1\":{\"293\":1,\"295\":1,\"306\":1}}],[\"might\",{\"1\":{\"244\":1}}],[\"migration\",{\"1\":{\"236\":1}}],[\"millisec\",{\"1\":{\"129\":2}}],[\"min\",{\"1\":{\"74\":1,\"243\":1}}],[\"mincapacity\",{\"1\":{\"52\":10}}],[\"m\",{\"1\":{\"73\":1}}],[\"matchlabels\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"math\",{\"1\":{\"52\":1,\"243\":1}}],[\"manage\",{\"1\":{\"314\":1}}],[\"manager\",{\"1\":{\"293\":1}}],[\"maven\",{\"1\":{\"313\":3,\"315\":1,\"318\":1}}],[\"macos\",{\"1\":{\"303\":1}}],[\"machine\",{\"1\":{\"185\":1}}],[\"master\",{\"0\":{\"299\":1},\"1\":{\"299\":1,\"302\":1}}],[\"may\",{\"1\":{\"234\":1}}],[\"mark\",{\"1\":{\"209\":2}}],[\"mapper\",{\"1\":{\"292\":1}}],[\"mappingfunction\",{\"1\":{\"73\":3}}],[\"map<\",{\"1\":{\"73\":1}}],[\"map\",{\"0\":{\"73\":1,\"276\":1},\"1\":{\"73\":1,\"257\":2,\"276\":1}}],[\"maxgcpausemillis=50\",{\"1\":{\"209\":1}}],[\"maximum\",{\"1\":{\"74\":1}}],[\"max\",{\"1\":{\"52\":6,\"308\":1}}],[\"maintainer\",{\"1\":{\"318\":1}}],[\"main\",{\"1\":{\"11\":2,\"12\":1,\"14\":2,\"128\":1,\"129\":1,\"218\":1,\"221\":1}}],[\"其它线程调用\",{\"1\":{\"140\":1}}],[\"其它线程会调用\",{\"1\":{\"138\":1}}],[\"其中一个\",{\"1\":{\"318\":2}}],[\"其中\",{\"1\":{\"217\":1}}],[\"其中有可能会含有语义错误\",{\"1\":{\"193\":1}}],[\"其中最重要的一个应用实例就是经典\",{\"1\":{\"115\":1}}],[\"其中的\",{\"1\":{\"111\":1}}],[\"其核心思想就是解耦\",{\"1\":{\"43\":1}}],[\"其他不同厂商可以针对同一接口做出不同的实现\",{\"1\":{\"43\":1}}],[\"其对应的原生态类型\",{\"1\":{\"16\":1}}],[\"机制的\",{\"1\":{\"190\":1}}],[\"机制的实现原理\",{\"0\":{\"45\":1}}],[\"机制的使用\",{\"0\":{\"44\":1}}],[\"机制介绍\",{\"0\":{\"43\":1}}],[\"机制\",{\"0\":{\"42\":1}}],[\"反之\",{\"1\":{\"143\":1}}],[\"反之则可以\",{\"1\":{\"6\":1}}],[\"反射能够获取的信息\",{\"1\":{\"275\":1}}],[\"反射的实现方式\",{\"1\":{\"275\":1}}],[\"反射的作用与原理\",{\"0\":{\"275\":1}}],[\"反射\",{\"1\":{\"261\":1}}],[\"反射使用\",{\"0\":{\"40\":1}}],[\"反射基础\",{\"0\":{\"39\":1}}],[\"反射机制是在运行时\",{\"1\":{\"275\":1}}],[\"反射机制执行的流程\",{\"0\":{\"41\":1}}],[\"反射机制\",{\"0\":{\"38\":1}}],[\"异常处理等等需要依赖它\",{\"1\":{\"200\":1}}],[\"异常\",{\"1\":{\"197\":2,\"199\":2,\"277\":1,\"280\":1}}],[\"异常实践\",{\"0\":{\"36\":1}}],[\"异常基础\",{\"0\":{\"35\":1}}],[\"异常的层次结构\",{\"0\":{\"34\":1}}],[\"异常机制\",{\"0\":{\"33\":1}}],[\"描述的是\",{\"1\":{\"197\":1,\"198\":1}}],[\"描述\",{\"1\":{\"197\":1}}],[\"描述在使用\",{\"1\":{\"26\":1}}],[\"描述注解是否可以被子类继承\",{\"1\":{\"26\":1}}],[\"描述注解保留的时间范围\",{\"1\":{\"26\":1}}],[\"描述注解的使用范围\",{\"1\":{\"26\":1}}],[\"表示正在运行对象的类\",{\"1\":{\"275\":1}}],[\"表示禁止重排序\",{\"1\":{\"174\":1}}],[\"表示关闭编译器警告信息\",{\"1\":{\"25\":1}}],[\"表示代码被弃用\",{\"1\":{\"25\":1}}],[\"表示当前的方法定义将覆盖父类中的方法\",{\"1\":{\"25\":1}}],[\"表示参数化的类型可能是指定的类型\",{\"1\":{\"14\":1}}],[\"表示参数化的类型可能是所指定的类型\",{\"1\":{\"14\":1}}],[\"并记录存入\",{\"1\":{\"262\":1}}],[\"并覆盖其中方法实现增强\",{\"1\":{\"226\":1}}],[\"并通过反射机制调用目标类的代码\",{\"1\":{\"217\":1}}],[\"并由代理对象控制原对象的引用\",{\"1\":{\"216\":1}}],[\"并设置默认的初始值\",{\"1\":{\"194\":1}}],[\"并不是一定就要进行同步\",{\"1\":{\"113\":1}}],[\"并可用元注解对自定义注解进行注解\",{\"1\":{\"24\":1}}],[\"并且设置对应的\",{\"1\":{\"232\":1}}],[\"并且通过反射获取到它的所有的接口\",{\"1\":{\"219\":1}}],[\"并且没有执行\",{\"1\":{\"133\":1}}],[\"并且在释放锁之前会将对变量的修改刷新到主存当中\",{\"1\":{\"99\":1}}],[\"并且在调试的时候可以不影响其他模块\",{\"1\":{\"2\":1}}],[\"并且子类方法的实现覆盖了父类方法的实现\",{\"1\":{\"6\":1}}],[\"自动装箱和拆箱\",{\"0\":{\"251\":1}}],[\"自动产生\",{\"1\":{\"17\":1}}],[\"自己比较自己肯定\",{\"1\":{\"242\":1}}],[\"自java\",{\"1\":{\"217\":1}}],[\"自旋等待的时间必须要有一定的限度\",{\"1\":{\"143\":1}}],[\"自旋等待的效果就会非常好\",{\"1\":{\"143\":1}}],[\"自旋等待虽然避免了线程切换的开销\",{\"1\":{\"143\":1}}],[\"自旋锁本身是有缺点的\",{\"1\":{\"143\":1}}],[\"自旋锁\",{\"0\":{\"143\":1},\"1\":{\"143\":1}}],[\"自然就保证了有序性\",{\"1\":{\"100\":1}}],[\"自增的属性值设置为\",{\"1\":{\"62\":1}}],[\"自定义注解和aop\",{\"0\":{\"32\":1}}],[\"自定义注解\",{\"0\":{\"27\":1},\"1\":{\"24\":1}}],[\"生成文档\",{\"1\":{\"24\":1}}],[\"生产者\",{\"1\":{\"115\":1}}],[\"生产者有上限\",{\"1\":{\"14\":1}}],[\"生产者或者消费者\",{\"1\":{\"14\":1}}],[\"局部变量等进行注解\",{\"1\":{\"24\":1}}],[\"接口才可以调用该方法\",{\"1\":{\"277\":1}}],[\"接口的类只能当做一个可以在线程中运行的任务\",{\"1\":{\"124\":1}}],[\"接口\",{\"1\":{\"24\":1,\"124\":2,\"257\":2}}],[\"接口和方法中\",{\"1\":{\"8\":1}}],[\"类名\",{\"1\":{\"275\":1}}],[\"类型转换为\",{\"1\":{\"267\":1}}],[\"类型\",{\"1\":{\"250\":1}}],[\"类型擦除\",{\"1\":{\"16\":1}}],[\"类文件的固定格式\",{\"1\":{\"193\":1}}],[\"类文件的结构检查\",{\"1\":{\"193\":1}}],[\"类库仅仅可以被此\",{\"1\":{\"190\":1}}],[\"类库中提供了\",{\"1\":{\"140\":1}}],[\"类加载器的\",{\"1\":{\"191\":1}}],[\"类加载器加载类\",{\"1\":{\"191\":1}}],[\"类加载器\",{\"1\":{\"190\":1}}],[\"类加载器有哪些\",{\"0\":{\"189\":1}}],[\"类加载器子系统负责从文件系统或者网络中加载\",{\"1\":{\"187\":1}}],[\"类加载过程如下图\",{\"1\":{\"187\":1}}],[\"类加载子系统详解\",{\"1\":{\"187\":1}}],[\"类加载子系统\",{\"0\":{\"187\":1}}],[\"类装载器所做的工作实质是把类文件从硬盘读取到内存中\",{\"1\":{\"185\":1}}],[\"类来实现线程之间的协调\",{\"1\":{\"140\":1}}],[\"类来实现线程本地存储功能\",{\"1\":{\"115\":1}}],[\"类开销过大\",{\"1\":{\"125\":1}}],[\"类可能只要求可执行就行\",{\"1\":{\"125\":1}}],[\"类就无法继承其它类\",{\"1\":{\"125\":1}}],[\"类的所有实例需要遵守\",{\"1\":{\"282\":1}}],[\"类的\",{\"1\":{\"111\":1}}],[\"类似于\",{\"1\":{\"61\":1}}],[\"类\",{\"1\":{\"24\":1,\"124\":1,\"257\":2}}],[\"用于比较是否是同一个对象\",{\"1\":{\"253\":1}}],[\"用于存储已被虚拟机加载的类信息\",{\"1\":{\"197\":1,\"201\":1}}],[\"用于对代码进行说明\",{\"1\":{\"24\":1}}],[\"用到的状态量都由参数中传入\",{\"1\":{\"116\":1}}],[\"用户创建项目权限控制\",{\"1\":{\"308\":1}}],[\"用户态核心态转换\",{\"1\":{\"108\":1}}],[\"用户无需知道对象内部的细节\",{\"1\":{\"2\":1}}],[\"用这些注解标明后编译器就会进行检查\",{\"1\":{\"24\":1}}],[\"5\",{\"0\":{\"251\":1,\"302\":1},\"1\":{\"52\":3,\"191\":1,\"236\":1,\"307\":2,\"308\":1,\"313\":2}}],[\"5中提供了4个标准的元注解\",{\"1\":{\"26\":1}}],[\"5开始自带的标准注解\",{\"1\":{\"25\":1}}],[\"5版本开始引入的一个特性\",{\"1\":{\"24\":1}}],[\"5才开始加入的\",{\"1\":{\"16\":1}}],[\"失去了本意\",{\"1\":{\"21\":1}}],[\"则nginx\",{\"1\":{\"308\":1}}],[\"则可能导致无法做安装节点\",{\"1\":{\"302\":1}}],[\"则默认比较内存地址\",{\"1\":{\"241\":1}}],[\"则新生代默认使用parnew\",{\"1\":{\"209\":1}}],[\"则证明此对象是不可用的\",{\"1\":{\"207\":1}}],[\"则由\",{\"1\":{\"187\":1}}],[\"则其他线程只能对a再加共享锁\",{\"1\":{\"147\":1}}],[\"则其他线程不能再对a加任何类型的锁\",{\"1\":{\"147\":1}}],[\"则根据不同的实现方式执行不同的操作\",{\"1\":{\"142\":1}}],[\"则相当于调用每个线程的\",{\"1\":{\"134\":1}}],[\"则执行\",{\"1\":{\"75\":1}}],[\"则链接在链表后\",{\"1\":{\"75\":1}}],[\"则修改集合中key\",{\"1\":{\"73\":1}}],[\"则传入\",{\"1\":{\"73\":1}}],[\"则通过链表进行链接\",{\"1\":{\"262\":1}}],[\"则通过\",{\"1\":{\"73\":1}}],[\"则重新赋值\",{\"1\":{\"73\":1}}],[\"则进行添加\",{\"1\":{\"73\":1}}],[\"则直接调用的addall\",{\"1\":{\"56\":1}}],[\"则需要判断扩容\",{\"1\":{\"52\":1}}],[\"则需要进行扩容\",{\"1\":{\"52\":1}}],[\"则第一次扩容容量会变更为\",{\"1\":{\"52\":1}}],[\"则会直接\",{\"1\":{\"268\":1}}],[\"则会进行默认为容量是\",{\"1\":{\"52\":1}}],[\"则会把元素赋值给this\",{\"1\":{\"50\":1}}],[\"则会给属性\",{\"1\":{\"50\":1}}],[\"则抛出异常\",{\"1\":{\"50\":1}}],[\"则表示这个变量可以被本地代码引用\",{\"1\":{\"26\":1}}],[\"则就变成了\",{\"1\":{\"21\":1}}],[\"则不能重写该类的方法\",{\"1\":{\"6\":1}}],[\"被存在磁盘或其他的数据存储设备中\",{\"1\":{\"271\":1}}],[\"被修饰的常量\",{\"1\":{\"264\":1}}],[\"被修饰的方法\",{\"1\":{\"264\":1}}],[\"被修饰的方法不可被重写\",{\"1\":{\"264\":1}}],[\"被修饰的变量不可被变更\",{\"1\":{\"264\":1}}],[\"被修饰的注解可以用在什么地方\",{\"1\":{\"26\":1}}],[\"被调用的线程执行完毕\",{\"1\":{\"121\":1,\"122\":1}}],[\"被描述的注解在它所修饰的类中可以被保留到何时\",{\"1\":{\"26\":1}}],[\"被擦除为\",{\"1\":{\"21\":1}}],[\"被重载的方法可以声明新的或更广的检查异常\",{\"1\":{\"7\":1}}],[\"被重载的方法可以改变访问修饰符\",{\"1\":{\"7\":1}}],[\"被重载的方法可以改变返回类型\",{\"1\":{\"7\":1}}],[\"被重载的方法必须改变参数列表\",{\"1\":{\"7\":1}}],[\"擦除方法定义中的类型参数\",{\"1\":{\"18\":2}}],[\"擦除类定义中的类型参数\",{\"1\":{\"18\":2}}],[\"有哪些方法\",{\"0\":{\"277\":1}}],[\"有哪些用法\",{\"0\":{\"264\":1}}],[\"有缓存会更多\",{\"1\":{\"275\":1}}],[\"有相同的作用和目的\",{\"1\":{\"274\":1}}],[\"有\",{\"1\":{\"268\":1}}],[\"有什么区别\",{\"0\":{\"267\":1}}],[\"有没有可能两个对象不等\",{\"0\":{\"262\":1}}],[\"有丰富的类库\",{\"1\":{\"247\":1}}],[\"有三种使用线程的方法\",{\"1\":{\"124\":1}}],[\"有三个构造方法\",{\"1\":{\"50\":1}}],[\"有序性实现\",{\"0\":{\"172\":1}}],[\"有序性\",{\"0\":{\"92\":1,\"100\":1},\"1\":{\"100\":1}}],[\"有序性问题\",{\"1\":{\"88\":1}}],[\"有限制类型擦除\",{\"1\":{\"18\":2}}],[\"有效地调节性能\",{\"1\":{\"2\":1}}],[\"如ladp\",{\"1\":{\"308\":1}}],[\"如\",{\"1\":{\"115\":1,\"217\":1}}],[\"如与前面的\",{\"1\":{\"105\":1}}],[\"如何判断一个对象是否还存活\",{\"0\":{\"207\":1}}],[\"如何提供按需禁用缓存和编译优化的方法\",{\"1\":{\"93\":1}}],[\"如何获取泛型的参数类型\",{\"0\":{\"22\":1}}],[\"如何理解泛型类型不能实例化\",{\"0\":{\"21\":1}}],[\"如何理解泛型的多态\",{\"0\":{\"19\":1}}],[\"如何理解基本类型不能作为泛型类型\",{\"0\":{\"20\":1}}],[\"如何进行擦除\",{\"0\":{\"18\":1}}],[\"如果设置https\",{\"1\":{\"308\":1}}],[\"如果设置为true那么就按照双亲委派机制加载类\",{\"1\":{\"191\":1}}],[\"如果映射端口为\",{\"1\":{\"296\":1}}],[\"如果有不相等的则返回插值\",{\"1\":{\"243\":1}}],[\"如果需要对自定义对象进行判断是否相等\",{\"1\":{\"241\":1}}],[\"如果需要解决\",{\"1\":{\"112\":1}}],[\"如果大量拼接\",{\"1\":{\"229\":1}}],[\"如果要被代理的对象不是个实现类那么\",{\"1\":{\"225\":1}}],[\"如果要被代理的对象是个实现类\",{\"1\":{\"225\":1}}],[\"如果要实现更大范围操作的原子性\",{\"1\":{\"98\":1}}],[\"如果指定了选项\",{\"1\":{\"209\":1}}],[\"如果扩展到无法申请到足够的内存就会抛出\",{\"1\":{\"197\":1,\"199\":1}}],[\"如果上述都没有找到\",{\"1\":{\"191\":1}}],[\"如果本地应用目录下还有没有这个类\",{\"1\":{\"191\":1}}],[\"如果先加载这个类\",{\"1\":{\"191\":1}}],[\"如果\",{\"1\":{\"191\":2,\"268\":1}}],[\"如果加载过就返回\",{\"1\":{\"191\":1}}],[\"如果加载过就返回缓存中的\",{\"1\":{\"191\":1}}],[\"如果父加载器也没找到\",{\"1\":{\"191\":1}}],[\"如果父类的一个方法被声明为\",{\"1\":{\"6\":1}}],[\"如果找不到在交给父加载器去加载\",{\"1\":{\"190\":1}}],[\"如果收到类加载的请求\",{\"1\":{\"190\":1}}],[\"如果是这个流程\",{\"1\":{\"165\":1}}],[\"如果以x86处理为例\",{\"1\":{\"162\":1}}],[\"如果可见的\",{\"1\":{\"160\":1}}],[\"如果可以\",{\"1\":{\"21\":1}}],[\"如果线程t对数据a加上共享锁后\",{\"1\":{\"147\":1}}],[\"如果线程t对数据a加上排它锁后\",{\"1\":{\"147\":1}}],[\"如果自旋超过了限定次数\",{\"1\":{\"143\":1}}],[\"如果锁被占用的时间很长\",{\"1\":{\"143\":1}}],[\"如果锁被占用的时间很短\",{\"1\":{\"143\":1}}],[\"如果在webappclassloader没找到类\",{\"1\":{\"191\":1}}],[\"如果在本地目录没有找到\",{\"1\":{\"191\":1}}],[\"如果在自旋完成后前面锁定同步资源的线程已经释放了锁\",{\"1\":{\"143\":1}}],[\"如果在运行过程中发生异常也会提前结束\",{\"1\":{\"131\":1}}],[\"如果物理机器有多个处理器\",{\"1\":{\"143\":1}}],[\"如果数据已经被其他线程更新\",{\"1\":{\"142\":1}}],[\"如果这个数据没有被更新\",{\"1\":{\"142\":1}}],[\"如果某些部分必须在其它部分之前完成\",{\"1\":{\"136\":1}}],[\"如果该线程处于阻塞\",{\"1\":{\"132\":1}}],[\"如果其线程释放了锁就会结束此状态\",{\"1\":{\"120\":1}}],[\"如果能保证\",{\"1\":{\"115\":1}}],[\"如果一段代码中所需要的数据必须与其他代码共享\",{\"1\":{\"115\":1}}],[\"如果一个类没有使用\",{\"1\":{\"282\":1}}],[\"如果一个线程的\",{\"1\":{\"133\":1}}],[\"如果一个方法本来就不涉及共享数据\",{\"1\":{\"113\":1}}],[\"如果一个变量初次读取的时候是\",{\"1\":{\"112\":1}}],[\"如果操作\",{\"1\":{\"97\":1,\"264\":1}}],[\"如果不重写\",{\"1\":{\"241\":1}}],[\"如果不在返回内会抛出stringindexoutofboundsexception异常\",{\"1\":{\"240\":1}}],[\"如果不想浪费50\",{\"1\":{\"208\":1}}],[\"如果不存在数据依赖性\",{\"1\":{\"92\":1}}],[\"如果不能继承一个类\",{\"1\":{\"6\":1}}],[\"如果没有加载过\",{\"1\":{\"191\":1}}],[\"如果没有释放锁\",{\"1\":{\"138\":1}}],[\"如果没有其它线程争用共享数据\",{\"1\":{\"110\":1}}],[\"如果没有则调用\",{\"1\":{\"75\":1}}],[\"如果没有泛型\",{\"1\":{\"9\":1}}],[\"如果当前插入的位置等于元素数量即当前集合数据已满\",{\"1\":{\"52\":1}}],[\"如果使用了被\",{\"1\":{\"25\":1}}],[\"如果我们确实需要实例化一个泛型\",{\"1\":{\"21\":1}}],[\"如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型\",{\"1\":{\"17\":1}}],[\"如果类型参数是无限制通配符或没有上下界限定则替换为object\",{\"1\":{\"17\":1}}],[\"如果既是生产又是消费\",{\"1\":{\"14\":1}}],[\"如果它表示一个\",{\"1\":{\"14\":1}}],[\"如果参数化类型表示一个\",{\"1\":{\"14\":1}}],[\"桥接方法\",{\"1\":{\"17\":1}}],[\"消费者\",{\"1\":{\"115\":1}}],[\"消费者有下限\",{\"1\":{\"14\":1}}],[\"消除类型参数声明\",{\"1\":{\"17\":1}}],[\"都能够调用它的任意一个方法\",{\"1\":{\"275\":1}}],[\"都能够知道这个类的所有属性和方法\",{\"1\":{\"275\":1}}],[\"都不能为\",{\"1\":{\"257\":1}}],[\"都支持\",{\"1\":{\"257\":1}}],[\"都对应这一个线帧在虚拟机栈中入栈到出栈的过程\",{\"1\":{\"197\":1,\"198\":1}}],[\"都会将产品的消费过程尽量在一个线程中消费完\",{\"1\":{\"115\":1}}],[\"都无法在多线程环境中并发使用的代码\",{\"1\":{\"106\":1}}],[\"都是基于数组的存储结构\",{\"1\":{\"61\":1}}],[\"都是空的\",{\"1\":{\"58\":1}}],[\"都替换为具体的类型\",{\"1\":{\"16\":1}}],[\"都必须有一个独一无二的参数类型列表\",{\"1\":{\"7\":1}}],[\"尖括号中的内容\",{\"1\":{\"16\":1}}],[\"伪泛型\",{\"1\":{\"16\":1}}],[\"lbip\",{\"1\":{\"323\":1,\"324\":2}}],[\"ln\",{\"1\":{\"318\":1}}],[\"l=palo\",{\"1\":{\"310\":1}}],[\"l=\",{\"1\":{\"310\":1}}],[\"ldaps\",{\"1\":{\"308\":1}}],[\"ldap\",{\"1\":{\"308\":9}}],[\"ldap认证时配置项\",{\"1\":{\"308\":1}}],[\"lvm2\",{\"1\":{\"292\":1}}],[\"lt\",{\"1\":{\"243\":1}}],[\"latest\",{\"1\":{\"318\":9,\"323\":1}}],[\"labels\",{\"1\":{\"316\":4,\"318\":4,\"324\":4}}],[\"lang\",{\"1\":{\"115\":1,\"191\":2,\"217\":1,\"242\":2}}],[\"lastindexof\",{\"1\":{\"191\":1}}],[\"last等于新元素\",{\"1\":{\"58\":1}}],[\"last\",{\"1\":{\"58\":3}}],[\"looking\",{\"1\":{\"244\":1}}],[\"longer\",{\"1\":{\"243\":1}}],[\"long\",{\"1\":{\"229\":1,\"249\":2}}],[\"logrotate\",{\"1\":{\"310\":1}}],[\"login\",{\"1\":{\"305\":1}}],[\"log\",{\"1\":{\"191\":38,\"310\":1,\"318\":1}}],[\"located\",{\"1\":{\"191\":1}}],[\"locate\",{\"1\":{\"191\":1}}],[\"localtime\",{\"1\":{\"318\":1}}],[\"local\",{\"0\":{\"115\":1,\"183\":1},\"1\":{\"191\":2,\"318\":4}}],[\"locksupport\",{\"1\":{\"121\":1,\"122\":2}}],[\"lock\",{\"1\":{\"97\":1,\"264\":1}}],[\"loadbalancer\",{\"1\":{\"316\":2,\"318\":2,\"324\":2}}],[\"loading\",{\"1\":{\"191\":3}}],[\"loadclass\",{\"1\":{\"191\":1}}],[\"loaded\",{\"1\":{\"191\":1}}],[\"loadstore\",{\"1\":{\"174\":2}}],[\"loadload\",{\"1\":{\"174\":2,\"264\":1}}],[\"loadfactor\",{\"1\":{\"74\":1}}],[\"load\",{\"1\":{\"74\":1}}],[\"len2\",{\"1\":{\"243\":3}}],[\"len1\",{\"1\":{\"243\":3}}],[\"lengths\",{\"1\":{\"243\":2}}],[\"length\",{\"0\":{\"238\":1},\"1\":{\"11\":1,\"52\":1,\"233\":1,\"234\":3,\"235\":1,\"236\":1,\"238\":5,\"239\":3,\"240\":3,\"241\":2,\"242\":4,\"243\":4,\"244\":3}}],[\"let\",{\"1\":{\"243\":1}}],[\"lexicographic\",{\"1\":{\"243\":1}}],[\"lexicographically\",{\"1\":{\"243\":8}}],[\"least\",{\"1\":{\"242\":1}}],[\"less\",{\"1\":{\"240\":1,\"243\":2}}],[\"level\",{\"1\":{\"92\":1}}],[\"linux\",{\"1\":{\"293\":1,\"295\":1,\"303\":2,\"313\":1}}],[\"link\",{\"1\":{\"234\":1,\"239\":2,\"242\":2,\"243\":1}}],[\"linking\",{\"0\":{\"192\":1}}],[\"linkedblockingdeque\",{\"0\":{\"84\":1}}],[\"linkedblockingqueue\",{\"0\":{\"83\":1}}],[\"linkedlist\",{\"0\":{\"55\":1,\"256\":1,\"278\":1},\"1\":{\"48\":1,\"55\":1,\"256\":1}}],[\"lim\",{\"1\":{\"243\":2}}],[\"likely\",{\"1\":{\"236\":1}}],[\"library\",{\"1\":{\"220\":1,\"318\":9}}],[\"lib\",{\"1\":{\"190\":2,\"311\":1}}],[\"list\",{\"0\":{\"276\":1},\"1\":{\"47\":1,\"276\":1}}],[\"list6\",{\"1\":{\"15\":1}}],[\"list<\",{\"1\":{\"15\":2}}],[\"list<string>\",{\"1\":{\"15\":5}}],[\"list15\",{\"1\":{\"15\":1}}],[\"list14\",{\"1\":{\"15\":1}}],[\"list13\",{\"1\":{\"15\":1}}],[\"list12\",{\"1\":{\"15\":1}}],[\"list11\",{\"1\":{\"15\":1}}],[\"因为浮点数不能完全的精确的表示出来\",{\"1\":{\"266\":1}}],[\"因为虚拟机的是多线程的\",{\"1\":{\"200\":1}}],[\"因为long和double两种数据类型的操作可分为高32位和低32位两部分\",{\"1\":{\"169\":1}}],[\"因为base中的test方法是private的\",{\"1\":{\"151\":1}}],[\"因为private所修饰的方法是隐式的final\",{\"1\":{\"151\":1}}],[\"因为无法覆盖他们\",{\"1\":{\"150\":1}}],[\"因为线程有几率不阻塞直接获得锁\",{\"1\":{\"145\":1}}],[\"因为异常不能跨线程传播回\",{\"1\":{\"129\":1}}],[\"因为\",{\"1\":{\"125\":1,\"191\":3}}],[\"因为局部变量存储在虚拟机栈中\",{\"1\":{\"114\":1}}],[\"因为普通共享变量被修改之后\",{\"1\":{\"99\":1}}],[\"因为在\",{\"1\":{\"21\":1}}],[\"因为当类型擦除后\",{\"1\":{\"20\":1}}],[\"因为你需要的是精确的参数类型\",{\"1\":{\"14\":1}}],[\"因此进程是动态的\",{\"1\":{\"271\":1}}],[\"因此如果被代理类被final关键字所修饰\",{\"1\":{\"224\":1}}],[\"因此普通的long或double类型读\",{\"1\":{\"169\":1}}],[\"因此在获取数据的时候会先加锁\",{\"1\":{\"142\":1}}],[\"因此更加灵活\",{\"1\":{\"140\":1}}],[\"因此可以在循环体中使用\",{\"1\":{\"133\":1}}],[\"因此可以保证可见性\",{\"1\":{\"99\":1}}],[\"因此必须在本地进行处理\",{\"1\":{\"129\":1}}],[\"因此继承了\",{\"1\":{\"125\":1}}],[\"因此最后还需要通过\",{\"1\":{\"124\":1}}],[\"因此这种同步操作称为非阻塞同步\",{\"1\":{\"110\":1}}],[\"因此这种同步也称为阻塞同步\",{\"1\":{\"108\":1}}],[\"因此无法保证可见性\",{\"1\":{\"99\":1}}],[\"因此为了兼容之前的版本\",{\"1\":{\"16\":1}}],[\"因此\",{\"1\":{\"3\":1,\"157\":1,\"165\":1,\"169\":1}}],[\"那就选用复制算法\",{\"1\":{\"208\":1}}],[\"那就看看这些共享数据的代码是否能保证在同一个线程中执行\",{\"1\":{\"115\":1}}],[\"那就肯定会出现问题\",{\"1\":{\"108\":1}}],[\"那它自然就无须任何同步措施去保证正确性\",{\"1\":{\"113\":1}}],[\"那\",{\"1\":{\"112\":1}}],[\"那操作就成功了\",{\"1\":{\"110\":1}}],[\"那使用通配符就没什么意义了\",{\"1\":{\"14\":1}}],[\"那么spring会使用jdk动态代理来完成操作\",{\"1\":{\"225\":1}}],[\"那么这时候就需要cglib动态代理了\",{\"1\":{\"219\":1}}],[\"那么这个线程可以无需阻塞直接获取到锁\",{\"1\":{\"145\":1}}],[\"那么假如被代理对象没有实现接口呢\",{\"1\":{\"219\":1}}],[\"那么只能抛出\",{\"1\":{\"191\":1}}],[\"那么肯定不是应用自己定义的类\",{\"1\":{\"191\":1}}],[\"那么自旋的线程只会白浪费处理器资源\",{\"1\":{\"143\":1}}],[\"那么自然就不存在原子性问题了\",{\"1\":{\"98\":1}}],[\"那么当前线程就可以不必阻塞而是直接获取同步资源\",{\"1\":{\"143\":1}}],[\"那么其它线程就无法进入对象的同步方法或者同步控制块中\",{\"1\":{\"138\":1}}],[\"那么就由\",{\"1\":{\"191\":1}}],[\"那么就在本地应用目录下查找此类并加载\",{\"1\":{\"191\":1}}],[\"那么就委托给appclassloader去加载\",{\"1\":{\"191\":1}}],[\"那么就无法执行\",{\"1\":{\"138\":1}}],[\"那么就需要对线程进行协调\",{\"1\":{\"136\":1}}],[\"那么就会先用webappclassloader进行加载\",{\"1\":{\"191\":1}}],[\"那么就会抛出\",{\"1\":{\"132\":1}}],[\"那么就会使得j的值为0\",{\"1\":{\"90\":1}}],[\"那么调用线程的\",{\"1\":{\"133\":1}}],[\"那么操作\",{\"1\":{\"97\":1,\"264\":1}}],[\"那么在cpu1的高速缓存当中i的值变为10了\",{\"1\":{\"90\":1}}],[\"那么在子类中重写该方法就不能声明为\",{\"1\":{\"6\":1}}],[\"那么子类只能够重写父类的声明为\",{\"1\":{\"6\":1}}],[\"那么子类可以重写父类所有方法\",{\"1\":{\"6\":1}}],[\"3a\",{\"1\":{\"313\":1}}],[\"39\",{\"0\":{\"285\":1}}],[\"386\",{\"1\":{\"303\":1}}],[\"38\",{\"0\":{\"284\":1}}],[\"37\",{\"0\":{\"283\":1}}],[\"36\",{\"0\":{\"282\":1}}],[\"35\",{\"0\":{\"281\":1}}],[\"34\",{\"0\":{\"280\":1}}],[\"336fa29ff2bb4ef291e347e091f7f4a7\",{\"1\":{\"313\":1}}],[\"33\",{\"0\":{\"279\":1}}],[\"32\",{\"0\":{\"278\":1}}],[\"3以后\",{\"1\":{\"217\":1}}],[\"31\",{\"0\":{\"277\":1},\"1\":{\"74\":1}}],[\"30\",{\"0\":{\"276\":1},\"1\":{\"74\":2,\"308\":1}}],[\"3\",{\"0\":{\"237\":1,\"249\":1,\"266\":2,\"292\":1,\"300\":1,\"324\":1},\"1\":{\"14\":1,\"92\":1,\"110\":1,\"191\":2,\"193\":1,\"202\":2,\"205\":1,\"303\":6,\"306\":1,\"308\":2,\"313\":3,\"316\":1,\"323\":1}}],[\"就去寻找下一个散列\",{\"1\":{\"262\":1}}],[\"就是自动把封装类型转化为基础类型\",{\"1\":{\"251\":1}}],[\"就是自动把基础类型自动转换为封装类型\",{\"1\":{\"251\":1}}],[\"就是一种\",{\"1\":{\"3\":1}}],[\"就必须使用\",{\"1\":{\"208\":1}}],[\"就需要有额外的空间进行分配担保\",{\"1\":{\"208\":1}}],[\"就将还存活着的对象复制到另外一块上面\",{\"1\":{\"208\":1}}],[\"就会覆盖核心类库的\",{\"1\":{\"191\":1}}],[\"就表明了你不能打算继承该类\",{\"1\":{\"150\":1}}],[\"就应当挂起线程\",{\"1\":{\"143\":1}}],[\"就可能需要在调用端使用额外的同步手段来保证调用的正确性\",{\"1\":{\"104\":1}}],[\"就可以通过反射机制获得类的所有信息\",{\"1\":{\"275\":1}}],[\"就可以通过查找这个jar包\",{\"1\":{\"43\":1}}],[\"就可以在多种平台上不加修改地运行\",{\"1\":{\"185\":1}}],[\"就可以使用该服务了\",{\"1\":{\"43\":1}}],[\"就切换到线程2执行\",{\"1\":{\"91\":1}}],[\"就添加\",{\"1\":{\"73\":1}}],[\"就像完全没有泛型一样\",{\"1\":{\"16\":1}}],[\"就使用\",{\"1\":{\"14\":1}}],[\"2fwww\",{\"1\":{\"313\":1}}],[\"2f\",{\"1\":{\"313\":2}}],[\"29\",{\"0\":{\"275\":1}}],[\"28\",{\"0\":{\"274\":1}}],[\"27\",{\"0\":{\"273\":1}}],[\"26\",{\"0\":{\"272\":1}}],[\"250\",{\"1\":{\"318\":9}}],[\"25\",{\"0\":{\"271\":1},\"1\":{\"308\":1}}],[\"240\",{\"1\":{\"305\":1,\"316\":2,\"318\":2}}],[\"24\",{\"0\":{\"270\":1}}],[\"23\",{\"0\":{\"269\":1}}],[\"22\",{\"0\":{\"268\":1},\"1\":{\"305\":1,\"316\":2,\"318\":11}}],[\"21\",{\"0\":{\"267\":1}}],[\"2\",{\"0\":{\"230\":1,\"248\":1,\"283\":1,\"291\":1,\"295\":1,\"299\":1,\"323\":1},\"1\":{\"14\":1,\"74\":2,\"92\":1,\"191\":2,\"193\":1,\"202\":1,\"229\":1,\"249\":2,\"306\":1,\"307\":3,\"316\":1,\"318\":1}}],[\"20\",{\"0\":{\"266\":1},\"1\":{\"11\":1}}],[\"要是不一致则说明存在别的线程在操作\",{\"1\":{\"280\":1}}],[\"要求方法名\",{\"1\":{\"252\":1}}],[\"要保证线程安全\",{\"1\":{\"113\":1}}],[\"要在表示\",{\"1\":{\"14\":1}}],[\"要实现不同类型的加法\",{\"1\":{\"9\":1}}],[\"为\",{\"1\":{\"257\":1}}],[\"为此\",{\"1\":{\"174\":1}}],[\"为什么要自定义类加载器\",{\"0\":{\"190\":1}}],[\"为什么要这么计算哈希值\",{\"1\":{\"75\":1}}],[\"为什么会出现并发问题\",{\"0\":{\"89\":1}}],[\"为什么需要多线程\",{\"0\":{\"88\":1}}],[\"为什么引入泛型\",{\"0\":{\"9\":1}}],[\"为空则会清除\",{\"1\":{\"73\":1}}],[\"为了实现\",{\"1\":{\"174\":1}}],[\"为了性能优化\",{\"1\":{\"174\":1}}],[\"为了保证在不同的编译器和\",{\"1\":{\"171\":1}}],[\"为了保证类型安全\",{\"1\":{\"17\":1}}],[\"为了提高执行性能\",{\"1\":{\"171\":1}}],[\"为了防止这个过程的重排序\",{\"1\":{\"165\":1}}],[\"为了这一小段时间去切换线程\",{\"1\":{\"143\":1}}],[\"为了合理利用\",{\"1\":{\"88\":1}}],[\"为了获得最大限度的灵活性\",{\"1\":{\"14\":1}}],[\"关闭防火墙\",{\"0\":{\"290\":1}}],[\"关闭\",{\"1\":{\"275\":1}}],[\"关键字\",{\"1\":{\"272\":1}}],[\"关键字声明了类型的下界\",{\"1\":{\"14\":1}}],[\"关键字声明了类型的上界\",{\"1\":{\"14\":1}}],[\"关于两者之间的性能的话\",{\"1\":{\"227\":1}}],[\"关于final重排序的总结\",{\"0\":{\"161\":1}}],[\"关系\",{\"1\":{\"3\":2}}],[\"egd=file\",{\"1\":{\"318\":1}}],[\"echo\",{\"1\":{\"318\":1}}],[\"e24=http\",{\"1\":{\"313\":1}}],[\"everyone\",{\"1\":{\"308\":1}}],[\"email\",{\"1\":{\"308\":7}}],[\"empty\",{\"1\":{\"50\":1,\"52\":1,\"231\":1,\"310\":2}}],[\"eof\",{\"1\":{\"295\":2,\"306\":1}}],[\"etc\",{\"1\":{\"295\":2,\"306\":1,\"311\":1,\"312\":1,\"318\":2}}],[\"error\",{\"0\":{\"269\":1},\"1\":{\"269\":1}}],[\"erasure\",{\"1\":{\"16\":1}}],[\"either\",{\"1\":{\"243\":1}}],[\"each\",{\"1\":{\"242\":2,\"243\":1}}],[\"ease\",{\"1\":{\"236\":1}}],[\"equivalent\",{\"1\":{\"241\":1,\"242\":1}}],[\"equal\",{\"1\":{\"234\":1,\"238\":1,\"242\":2,\"243\":2}}],[\"equalsignorecase\",{\"0\":{\"242\":1},\"1\":{\"241\":1,\"242\":1}}],[\"equals\",{\"0\":{\"241\":1,\"253\":1},\"1\":{\"47\":2,\"241\":2,\"242\":1,\"243\":1,\"253\":1,\"254\":1,\"262\":1,\"277\":1,\"282\":3}}],[\"eden\",{\"1\":{\"202\":1}}],[\"el7\",{\"1\":{\"306\":1}}],[\"else\",{\"1\":{\"191\":3}}],[\"elementdata赋值为empty\",{\"1\":{\"50\":2}}],[\"elementdata赋值为new\",{\"1\":{\"50\":1}}],[\"elementdata赋值为defaultcapacity\",{\"1\":{\"50\":1}}],[\"elementdata\",{\"1\":{\"50\":4,\"52\":3}}],[\"env\",{\"1\":{\"310\":4,\"318\":6,\"323\":1,\"324\":10}}],[\"enable\",{\"1\":{\"294\":1}}],[\"enabled=1\",{\"1\":{\"306\":1}}],[\"enabled\",{\"1\":{\"191\":1}}],[\"enhancer\",{\"1\":{\"221\":6}}],[\"end\",{\"1\":{\"191\":1}}],[\"engine\",{\"1\":{\"187\":1}}],[\"entry<k\",{\"1\":{\"74\":1}}],[\"entryset\",{\"1\":{\"73\":1,\"74\":1}}],[\"expose\",{\"1\":{\"318\":1}}],[\"expiration\",{\"1\":{\"308\":1}}],[\"expression\",{\"1\":{\"244\":1}}],[\"explicit\",{\"1\":{\"232\":1}}],[\"exactly\",{\"1\":{\"243\":1}}],[\"extensions\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"extends\",{\"1\":{\"9\":1,\"14\":4,\"73\":4}}],[\"extclassloader\",{\"1\":{\"191\":4}}],[\"exception\",{\"0\":{\"269\":1},\"1\":{\"191\":3,\"240\":1}}],[\"execution\",{\"1\":{\"187\":1}}],[\"executor\",{\"0\":{\"127\":1,\"134\":1},\"1\":{\"127\":2,\"134\":1}}],[\"e\",{\"1\":{\"47\":4,\"191\":11}}],[\"effictive\",{\"1\":{\"14\":1}}],[\"e>\",{\"1\":{\"14\":2,\"47\":1}}],[\">部署的脚本\",{\"1\":{\"318\":1}}],[\">推送镜像\",{\"1\":{\"318\":1}}],[\">地址相同\",{\"1\":{\"242\":1}}],[\">surrogate<\",{\"1\":{\"240\":1}}],[\">unicode\",{\"1\":{\"238\":1}}],[\">runtimeexception\",{\"1\":{\"191\":2}}],[\">classnotfoundexception\",{\"1\":{\"191\":1}}],[\">exception\",{\"1\":{\"191\":1}}],[\">=\",{\"1\":{\"191\":1,\"240\":1,\"244\":1}}],[\">>>\",{\"1\":{\"75\":1}}],[\">>\",{\"1\":{\"52\":1,\"191\":1,\"318\":1}}],[\">\",{\"1\":{\"14\":1,\"15\":5,\"21\":1,\"47\":4,\"52\":1,\"191\":6,\"244\":1,\"306\":1,\"314\":1,\"318\":1}}],[\"<sample\",{\"1\":{\"308\":1}}],[\"<pre>\",{\"1\":{\"243\":2,\"244\":1}}],[\"<p>if\",{\"1\":{\"240\":1}}],[\"<p>\",{\"1\":{\"234\":1,\"236\":1,\"242\":1,\"243\":1}}],[\"<blockquote>\",{\"1\":{\"243\":2}}],[\"<i>k<\",{\"1\":{\"243\":2}}],[\"<li>\",{\"1\":{\"242\":3}}],[\"<ul>\",{\"1\":{\"242\":1}}],[\"<a\",{\"1\":{\"238\":1,\"240\":1}}],[\"<<eof\",{\"1\":{\"306\":1}}],[\"<<\",{\"1\":{\"74\":2,\"295\":1}}],[\"<=\",{\"1\":{\"52\":2}}],[\"<\",{\"1\":{\"14\":5,\"21\":1,\"52\":2,\"240\":1,\"242\":1,\"243\":3,\"244\":2}}],[\"<t>\",{\"1\":{\"21\":1,\"221\":1}}],[\"<t\",{\"1\":{\"9\":1}}],[\"只需要选择\",{\"1\":{\"300\":1}}],[\"只需要付出少量存活对象的复制成本就可以完成收集\",{\"1\":{\"208\":1}}],[\"只复制当前对象\",{\"1\":{\"263\":1}}],[\"只会存在一个\",{\"1\":{\"257\":1}}],[\"只使用一个线程去回收\",{\"1\":{\"209\":1}}],[\"只有实现了\",{\"1\":{\"277\":1}}],[\"只有少量存活\",{\"1\":{\"208\":1}}],[\"只有当\",{\"1\":{\"110\":1}}],[\"只有当容量大于\",{\"1\":{\"74\":1}}],[\"只要给定类的名称\",{\"1\":{\"275\":1}}],[\"只要散列足够大\",{\"1\":{\"262\":1}}],[\"只要移动堆顶指针\",{\"1\":{\"208\":1}}],[\"只要一个不可变的对象被正确地构建出来\",{\"1\":{\"102\":1}}],[\"只负责\",{\"1\":{\"187\":1}}],[\"只是在更新数据的时候去判断之前有没有别的线程更新了这个数据\",{\"1\":{\"142\":1}}],[\"只不过虚拟机栈是服务\",{\"1\":{\"197\":1,\"199\":1}}],[\"只不过在操作的时候添加了锁\",{\"1\":{\"64\":1}}],[\"只不过在判断时加锁进而防止并发问题\",{\"1\":{\"63\":1}}],[\"只不过加入了自己特性的一些东西\",{\"1\":{\"61\":1}}],[\"只能管理员\",{\"1\":{\"308\":1}}],[\"只能修饰变量\",{\"1\":{\"272\":1}}],[\"只能初始化一次\",{\"1\":{\"229\":1}}],[\"只能保证单次的读\",{\"1\":{\"167\":1}}],[\"只能用在同步方法或者同步控制块中使用\",{\"1\":{\"138\":1}}],[\"只能靠硬件来完成\",{\"1\":{\"110\":1}}],[\"只能引用integer的值\",{\"1\":{\"20\":1}}],[\"只能接收string或object类型的泛型\",{\"1\":{\"14\":1}}],[\"只保留一些对外接口使之与外部发生联系\",{\"1\":{\"2\":1}}],[\"djava\",{\"1\":{\"318\":1}}],[\"dc=com\",{\"1\":{\"308\":2}}],[\"dc=mydomain\",{\"1\":{\"308\":2}}],[\"db\",{\"1\":{\"308\":2,\"310\":1}}],[\"d7sx4\",{\"1\":{\"305\":1}}],[\"d\",{\"1\":{\"296\":1,\"306\":1,\"311\":1}}],[\"darwin\",{\"1\":{\"303\":1}}],[\"data\",{\"1\":{\"292\":1,\"308\":3,\"310\":1,\"318\":19}}],[\"daemon\",{\"0\":{\"128\":1},\"1\":{\"295\":2}}],[\"driver\",{\"1\":{\"275\":1}}],[\"driver接口\",{\"1\":{\"43\":1}}],[\"dist\",{\"1\":{\"313\":1}}],[\"disable\",{\"1\":{\"290\":1}}],[\"dictionary\",{\"1\":{\"257\":1}}],[\"differ\",{\"1\":{\"243\":1}}],[\"difference\",{\"1\":{\"243\":2}}],[\"different\",{\"1\":{\"243\":4}}],[\"dump\",{\"1\":{\"211\":1}}],[\"dp\",{\"1\":{\"191\":4}}],[\"download\",{\"1\":{\"313\":1}}],[\"dockerfile\",{\"1\":{\"318\":1}}],[\"docker\",{\"0\":{\"293\":1},\"1\":{\"288\":1,\"293\":4,\"294\":1,\"295\":3,\"296\":2,\"318\":8}}],[\"documented用于标明是否生成javadoc文档\",{\"1\":{\"24\":1}}],[\"documented\",{\"1\":{\"24\":1,\"26\":1}}],[\"does\",{\"1\":{\"233\":1,\"235\":1,\"236\":1}}],[\"doprivileged\",{\"1\":{\"191\":3}}],[\"doublevalue\",{\"1\":{\"9\":4}}],[\"double\",{\"1\":{\"9\":4,\"249\":2}}],[\"dev\",{\"1\":{\"318\":6,\"323\":1,\"324\":2}}],[\"device\",{\"1\":{\"292\":1}}],[\"dest\",{\"1\":{\"318\":1}}],[\"dept\",{\"1\":{\"318\":6,\"323\":1,\"324\":12}}],[\"deploy\",{\"1\":{\"318\":2}}],[\"deployment\",{\"1\":{\"316\":2,\"318\":7,\"324\":2}}],[\"deprecated注解的代码则编译器将发出警告\",{\"1\":{\"25\":1}}],[\"deprecated\",{\"1\":{\"25\":1}}],[\"deprecated和\",{\"1\":{\"24\":1,\"25\":1}}],[\"determined\",{\"1\":{\"243\":1}}],[\"decoded\",{\"1\":{\"234\":1}}],[\"decoding\",{\"1\":{\"234\":2}}],[\"delegating\",{\"1\":{\"191\":2}}],[\"delegate\",{\"1\":{\"191\":1}}],[\"delegateload\",{\"1\":{\"191\":3}}],[\"definition\",{\"1\":{\"243\":1}}],[\"define\",{\"1\":{\"191\":1}}],[\"defaultvalue\",{\"1\":{\"73\":2}}],[\"default\",{\"1\":{\"52\":1,\"74\":2,\"229\":1,\"234\":2,\"316\":3,\"318\":3,\"323\":1,\"324\":2}}],[\"defaultcapacity\",{\"1\":{\"52\":1}}],[\"debug\",{\"1\":{\"191\":12}}],[\"demo1\",{\"1\":{\"14\":1}}],[\"声明object的泛型对象\",{\"1\":{\"14\":1}}],[\"声明string的泛型对象\",{\"1\":{\"14\":1}}],[\"声明integer的泛型对象\",{\"1\":{\"14\":1}}],[\"声明接口对象\",{\"1\":{\"12\":1}}],[\"声明为\",{\"1\":{\"6\":2}}],[\"定义\",{\"1\":{\"275\":1}}],[\"定义的目录和\",{\"1\":{\"190\":2}}],[\"定义泛型变量\",{\"1\":{\"14\":2}}],[\"定义泛型接口的子类\",{\"1\":{\"12\":1}}],[\"定义属性\",{\"1\":{\"12\":1}}],[\"定义抽象方法\",{\"1\":{\"12\":1}}],[\"定义两个泛型类型的对象\",{\"1\":{\"11\":1}}],[\"在当前安装目录下\",{\"1\":{\"309\":1}}],[\"在进行迭代其遍历时会缓存当前的\",{\"1\":{\"280\":1}}],[\"在\",{\"1\":{\"268\":1}}],[\"在构造函数内对一个\",{\"1\":{\"264\":1}}],[\"在构造函数内对一个final修饰的对象的成员域的写入\",{\"1\":{\"159\":1}}],[\"在编译阶段会存入常量池中\",{\"1\":{\"264\":1}}],[\"在集合中会使用到对象的\",{\"1\":{\"254\":1}}],[\"在1\",{\"1\":{\"227\":1}}],[\"在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑\",{\"1\":{\"220\":1}}],[\"在新生代中\",{\"1\":{\"208\":1}}],[\"在对象存活率较高时就要执行较多的复制操作\",{\"1\":{\"208\":1}}],[\"在标记完成后统一回收掉所有被标记的对象\",{\"1\":{\"208\":1}}],[\"在运行过程中内存申请\",{\"1\":{\"201\":1}}],[\"在虚拟机启动时候创建\",{\"1\":{\"197\":1,\"202\":1}}],[\"在解析阶段\",{\"1\":{\"195\":1}}],[\"在准备阶段\",{\"1\":{\"194\":1}}],[\"在执行字节码时\",{\"1\":{\"185\":1}}],[\"在执行程序时为了提高性能\",{\"1\":{\"92\":1}}],[\"在每个\",{\"1\":{\"174\":4}}],[\"在不改变正确语义的前提下\",{\"1\":{\"174\":1}}],[\"在不创建新的类型的情况下\",{\"1\":{\"8\":1}}],[\"在程序运行时\",{\"1\":{\"171\":1}}],[\"在程序前面的操作先行发生于后面的操作\",{\"1\":{\"97\":1,\"264\":1}}],[\"在son中的test\",{\"1\":{\"151\":1}}],[\"在许多场景中\",{\"1\":{\"143\":1}}],[\"在线程中调用另一个线程的\",{\"1\":{\"137\":1}}],[\"在一个线程中\",{\"1\":{\"157\":1}}],[\"在一个线程内\",{\"1\":{\"97\":1,\"264\":1}}],[\"在一定时间之后会被系统自动唤醒\",{\"1\":{\"122\":1}}],[\"在调用的时候不需要做额外的保障措施\",{\"1\":{\"104\":1}}],[\"在java语言中\",{\"1\":{\"207\":1}}],[\"在java里面\",{\"1\":{\"100\":1}}],[\"在jdk1\",{\"1\":{\"227\":1}}],[\"在jdk\",{\"1\":{\"26\":2}}],[\"在cpu寄存器中执行\",{\"1\":{\"91\":1}}],[\"在删除的过程中会校验缓存的modcount是否和当前的一致\",{\"1\":{\"53\":1}}],[\"在模块化设计中这个机制尤其重要\",{\"1\":{\"43\":1}}],[\"在使用时候\",{\"1\":{\"26\":1}}],[\"在接口上定义泛型\",{\"1\":{\"12\":1}}],[\"取得信息\",{\"1\":{\"11\":2}}],[\"取得字符串的长度\",{\"1\":{\"11\":1}}],[\"姓名\",{\"1\":{\"11\":1}}],[\"汤姆\",{\"1\":{\"11\":1,\"12\":1}}],[\"此方法简单\",{\"1\":{\"207\":1}}],[\"此时的语义检查主要是防止这种没有编译而生成的\",{\"1\":{\"193\":1}}],[\"此时的结果是不可预知的\",{\"1\":{\"160\":1}}],[\"此时调用\",{\"1\":{\"133\":1}}],[\"此时内存中可能还是原来的旧值\",{\"1\":{\"99\":1}}],[\"此时线程2执行\",{\"1\":{\"90\":1}}],[\"此外由于t\",{\"1\":{\"21\":1}}],[\"此变量的类型由外部决定\",{\"1\":{\"11\":2}}],[\"此处泛型只能是数字类型\",{\"1\":{\"14\":1}}],[\"此处指定了两个泛型类型\",{\"1\":{\"11\":1}}],[\"此处可以随便写标识符号\",{\"1\":{\"11\":1}}],[\"kind\",{\"1\":{\"316\":3,\"318\":3,\"324\":3}}],[\"kubectl\",{\"0\":{\"306\":1},\"1\":{\"306\":2,\"318\":4}}],[\"kubernetes\",{\"0\":{\"297\":1,\"316\":1,\"320\":1},\"1\":{\"288\":3,\"306\":4,\"321\":1,\"323\":1}}],[\"k8s\",{\"1\":{\"302\":3,\"308\":1}}],[\"kv\",{\"1\":{\"257\":2}}],[\"k++\",{\"1\":{\"243\":1}}],[\"keyset\",{\"1\":{\"73\":1}}],[\"key\",{\"0\":{\"282\":2},\"1\":{\"11\":5,\"73\":27,\"75\":3,\"257\":1,\"259\":1,\"276\":1,\"308\":2,\"310\":2,\"311\":1}}],[\"k\",{\"1\":{\"11\":3,\"73\":9,\"243\":7}}],[\"多次创建一个类的实例时\",{\"1\":{\"275\":1}}],[\"多线程环境下就可能将一个未初始化的对象引用暴露出来\",{\"1\":{\"165\":1}}],[\"多线程和并发\",{\"0\":{\"87\":1}}],[\"多个线程访问同一个方法的局部变量时\",{\"1\":{\"114\":1}}],[\"多少元素转化为树\",{\"1\":{\"74\":1}}],[\"多态的特性\",{\"1\":{\"248\":1}}],[\"多态性\",{\"1\":{\"17\":1}}],[\"多态分为编译时多态和运行时多态\",{\"1\":{\"4\":1}}],[\"多参数泛型\",{\"1\":{\"11\":1}}],[\"npm\",{\"1\":{\"318\":2}}],[\"nginx\",{\"0\":{\"316\":1},\"1\":{\"310\":2,\"316\":13,\"323\":2,\"324\":1}}],[\"n\",{\"0\":{\"283\":1},\"1\":{\"241\":3}}],[\"nio\",{\"0\":{\"274\":1},\"1\":{\"234\":1,\"274\":3}}],[\"near\",{\"1\":{\"244\":1}}],[\"negative\",{\"1\":{\"240\":1,\"243\":1,\"244\":1}}],[\"next\",{\"1\":{\"240\":1}}],[\"needed\",{\"1\":{\"232\":1}}],[\"newly\",{\"1\":{\"231\":1,\"232\":2,\"233\":1,\"235\":1,\"236\":1}}],[\"newproxyinstance\",{\"1\":{\"218\":1}}],[\"newvalue\",{\"1\":{\"73\":4}}],[\"newcapacity\",{\"1\":{\"52\":6}}],[\"newinstance\",{\"1\":{\"21\":1,\"261\":1}}],[\"newtclass\",{\"1\":{\"21\":1}}],[\"new\",{\"0\":{\"118\":1},\"1\":{\"11\":2,\"12\":1,\"14\":4,\"15\":6,\"21\":2,\"52\":2,\"191\":8,\"218\":3,\"221\":2,\"233\":1,\"234\":2,\"235\":1,\"236\":1,\"240\":1,\"259\":8,\"261\":1}}],[\"na\",{\"1\":{\"308\":1}}],[\"namespace\",{\"1\":{\"316\":2,\"318\":2,\"323\":1,\"324\":5}}],[\"name=kubernetes\",{\"1\":{\"306\":1}}],[\"name\",{\"1\":{\"191\":25,\"296\":1,\"316\":5,\"318\":5,\"323\":1,\"324\":16}}],[\"native\",{\"1\":{\"26\":2,\"197\":1,\"199\":1}}],[\"now\",{\"1\":{\"319\":1}}],[\"nodejs\",{\"1\":{\"315\":1,\"318\":2}}],[\"nodes\",{\"1\":{\"306\":1}}],[\"node\",{\"0\":{\"300\":1},\"1\":{\"302\":1,\"315\":1}}],[\"node<k\",{\"1\":{\"74\":1}}],[\"no\",{\"1\":{\"174\":1,\"243\":1,\"313\":2}}],[\"note\",{\"1\":{\"231\":1,\"244\":1}}],[\"notepad<string\",{\"1\":{\"11\":2}}],[\"notepad<k\",{\"1\":{\"11\":1}}],[\"not\",{\"1\":{\"191\":1,\"233\":1,\"234\":2,\"235\":1,\"236\":1,\"240\":1,\"241\":1,\"242\":1,\"326\":1}}],[\"notifyall\",{\"0\":{\"138\":1},\"1\":{\"121\":1,\"122\":1,\"138\":2,\"277\":1}}],[\"notify\",{\"0\":{\"138\":1},\"1\":{\"121\":1,\"122\":1,\"138\":2,\"277\":1}}],[\"number\",{\"1\":{\"238\":1}}],[\"number>\",{\"1\":{\"9\":1,\"14\":1}}],[\"null\",{\"1\":{\"11\":1,\"12\":1,\"75\":1,\"191\":13,\"218\":1,\"221\":1,\"239\":2,\"241\":1,\"242\":2,\"249\":1,\"257\":3}}],[\"v3\",{\"1\":{\"305\":1}}],[\"v2\",{\"1\":{\"241\":2,\"243\":2,\"303\":6}}],[\"v1beta1\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"v1\",{\"1\":{\"241\":2,\"243\":2,\"307\":2,\"316\":2,\"318\":2,\"324\":2}}],[\"vi\",{\"1\":{\"312\":1}}],[\"vim\",{\"1\":{\"308\":1}}],[\"via\",{\"1\":{\"236\":1}}],[\"virtual\",{\"1\":{\"185\":1}}],[\"vmid\",{\"1\":{\"214\":3}}],[\"version\",{\"1\":{\"323\":1,\"324\":1}}],[\"verify\",{\"0\":{\"193\":1},\"1\":{\"308\":1}}],[\"vector\",{\"0\":{\"61\":1},\"1\":{\"48\":4,\"61\":1,\"105\":1}}],[\"vs\",{\"0\":{\"125\":1,\"142\":1,\"143\":1,\"144\":3,\"145\":1,\"146\":1,\"147\":1}}],[\"volatile是无法保证这三个操作是具有原子性的\",{\"1\":{\"168\":1}}],[\"volatile不能保证完全的原子性\",{\"1\":{\"167\":1}}],[\"volatile关键字能有效的解决这个问题\",{\"1\":{\"166\":1}}],[\"volatile的作用详解\",{\"0\":{\"164\":1}}],[\"volatile\",{\"0\":{\"94\":1,\"163\":1,\"170\":1,\"171\":1,\"172\":1,\"173\":3,\"174\":1},\"1\":{\"93\":1,\"97\":2,\"171\":1,\"174\":13,\"264\":2}}],[\"void\",{\"1\":{\"11\":5,\"12\":2,\"14\":5,\"218\":3,\"221\":2}}],[\"valid\",{\"1\":{\"234\":1,\"243\":1}}],[\"values\",{\"1\":{\"73\":1,\"243\":1}}],[\"value为integer\",{\"1\":{\"11\":1}}],[\"value\",{\"0\":{\"233\":1},\"1\":{\"11\":5,\"52\":2,\"73\":17,\"229\":3,\"231\":3,\"232\":2,\"233\":6,\"235\":1,\"236\":1,\"238\":1,\"239\":1,\"240\":9,\"241\":4,\"242\":3,\"243\":11,\"244\":4,\"276\":1}}],[\"var的类型由t指定\",{\"1\":{\"11\":1}}],[\"var\",{\"1\":{\"11\":5,\"12\":7,\"14\":12,\"311\":1}}],[\"v\",{\"1\":{\"11\":3,\"73\":7,\"110\":3}}],[\"v>>\",{\"1\":{\"74\":1}}],[\"v>\",{\"1\":{\"11\":1,\"73\":3,\"74\":1}}],[\"返回值是什么\",{\"0\":{\"266\":1}}],[\"返回值的类型由外部决定\",{\"1\":{\"11\":1}}],[\"返回的是对象根据内存地址算出的一个值\",{\"1\":{\"254\":1}}],[\"返回字符组\",{\"1\":{\"235\":1}}],[\"返回类型无要求\",{\"1\":{\"252\":1}}],[\"返回类型都相同\",{\"1\":{\"252\":1}}],[\"返回类型可以相同也可以不同\",{\"1\":{\"7\":1}}],[\"返回类型与被重写方法的返回类型可以不相同\",{\"1\":{\"6\":1}}],[\"cmd\",{\"1\":{\"318\":1}}],[\"cms+serial\",{\"1\":{\"209\":1}}],[\"cms\",{\"1\":{\"209\":3}}],[\"cms收集器\",{\"1\":{\"209\":1}}],[\"cn=notarysigner\",{\"1\":{\"310\":1}}],[\"cn=\",{\"1\":{\"310\":1}}],[\"c=us\",{\"1\":{\"310\":1}}],[\"c=\",{\"1\":{\"310\":1}}],[\"creation\",{\"1\":{\"308\":1}}],[\"created\",{\"1\":{\"231\":1,\"232\":2,\"233\":1,\"235\":1,\"236\":1}}],[\"create\",{\"1\":{\"221\":1}}],[\"crt\",{\"1\":{\"308\":2,\"310\":1}}],[\"customize\",{\"1\":{\"308\":1}}],[\"currently\",{\"1\":{\"233\":1,\"235\":1,\"236\":1}}],[\"cfg\",{\"1\":{\"308\":1}}],[\"cd\",{\"1\":{\"308\":1,\"318\":8}}],[\"certificate\",{\"1\":{\"313\":1}}],[\"cert\",{\"1\":{\"308\":5,\"310\":1}}],[\"centos\",{\"1\":{\"293\":1}}],[\"ce\",{\"1\":{\"293\":3}}],[\"c2\",{\"1\":{\"242\":1,\"243\":3}}],[\"c1\",{\"1\":{\"242\":1,\"243\":3}}],[\"charat\",{\"0\":{\"240\":1},\"1\":{\"240\":1,\"243\":2}}],[\"characters\",{\"1\":{\"232\":1,\"233\":1,\"234\":1,\"235\":1,\"236\":1,\"238\":1,\"241\":1,\"242\":3,\"243\":2}}],[\"character\",{\"1\":{\"229\":1,\"231\":1,\"233\":3,\"238\":1,\"240\":1,\"242\":4,\"243\":5,\"244\":1,\"249\":1}}],[\"charsetdecoder\",{\"1\":{\"234\":1}}],[\"charset\",{\"1\":{\"234\":4}}],[\"char\",{\"0\":{\"233\":1},\"1\":{\"229\":1,\"233\":1,\"240\":7,\"241\":2,\"242\":2,\"243\":4,\"244\":2,\"249\":1}}],[\"childrenhello\",{\"1\":{\"218\":1}}],[\"children\",{\"1\":{\"218\":4}}],[\"check\",{\"1\":{\"313\":1}}],[\"checkexception\",{\"1\":{\"269\":1}}],[\"checkpackagedefinition\",{\"1\":{\"191\":2}}],[\"checkstateforclassloading\",{\"1\":{\"191\":1}}],[\"cglib是针对类来实现代理的\",{\"1\":{\"226\":1}}],[\"cglib动态代理是通过字节码底层继承要代理类来实现\",{\"1\":{\"224\":1}}],[\"cglib动态代理\",{\"1\":{\"223\":1}}],[\"cglib通过继承方式实现代理\",{\"1\":{\"220\":1}}],[\"cglib\",{\"0\":{\"215\":1,\"220\":1},\"1\":{\"220\":1}}],[\"cpu不必唤醒所有线程\",{\"1\":{\"145\":1}}],[\"cpu唤醒阻塞线程的开销比非公平锁大\",{\"1\":{\"145\":1}}],[\"cpu寄存器\",{\"1\":{\"91\":1}}],[\"cpu缓存引起\",{\"0\":{\"90\":1}}],[\"cpu\",{\"1\":{\"88\":5,\"91\":2,\"119\":1,\"121\":1,\"171\":3,\"200\":1,\"201\":1,\"271\":1}}],[\"cache\",{\"1\":{\"191\":2,\"229\":1}}],[\"cachedthreadpool\",{\"1\":{\"127\":1}}],[\"callable\",{\"1\":{\"124\":2}}],[\"case\",{\"1\":{\"242\":5,\"243\":2}}],[\"cas\",{\"1\":{\"110\":2,\"111\":1,\"112\":2}}],[\"capacity\",{\"1\":{\"52\":1,\"74\":3}}],[\"catch\",{\"0\":{\"268\":1},\"1\":{\"191\":10}}],[\"catalina\",{\"1\":{\"190\":1}}],[\"cat\",{\"1\":{\"3\":4,\"306\":1,\"311\":1}}],[\"cli2\",{\"1\":{\"303\":3}}],[\"cli\",{\"0\":{\"303\":1},\"1\":{\"316\":1}}],[\"clonenotsupportedexception\",{\"1\":{\"277\":1}}],[\"clone\",{\"1\":{\"261\":1,\"277\":2}}],[\"cloneable\",{\"1\":{\"257\":2,\"277\":3}}],[\"cl\",{\"1\":{\"191\":4}}],[\"clear\",{\"1\":{\"47\":1,\"73\":1}}],[\"clazz\",{\"1\":{\"21\":2,\"191\":31,\"221\":2}}],[\"classnotfoundexception\",{\"1\":{\"191\":15}}],[\"class<t>\",{\"1\":{\"221\":1}}],[\"class<\",{\"1\":{\"191\":4}}],[\"classloader1\",{\"1\":{\"191\":1}}],[\"classloader\",{\"1\":{\"187\":1,\"191\":3}}],[\"class文件结构\",{\"1\":{\"186\":1}}],[\"class\",{\"1\":{\"11\":4,\"12\":2,\"14\":4,\"21\":1,\"186\":2,\"187\":3,\"191\":13,\"193\":1,\"196\":1,\"218\":6,\"219\":1,\"221\":4,\"234\":1,\"250\":3,\"275\":7}}],[\"c\",{\"1\":{\"47\":4,\"97\":2,\"111\":1,\"112\":1,\"264\":2}}],[\"cookiecutter\",{\"0\":{\"322\":1},\"1\":{\"322\":1,\"323\":2,\"324\":36}}],[\"cookie\",{\"1\":{\"313\":2}}],[\"cookies\",{\"1\":{\"313\":1}}],[\"corresponding\",{\"1\":{\"242\":1}}],[\"copied\",{\"1\":{\"233\":1,\"235\":1,\"236\":1}}],[\"copyof\",{\"1\":{\"233\":1,\"235\":1,\"236\":1}}],[\"copyonwritearrayset\",{\"0\":{\"71\":1}}],[\"copyonwritearraylist\",{\"0\":{\"70\":1}}],[\"copy\",{\"1\":{\"53\":1,\"232\":2}}],[\"count\",{\"1\":{\"214\":1}}],[\"common\",{\"1\":{\"310\":12}}],[\"commonclassloader\",{\"1\":{\"190\":1}}],[\"com>\",{\"1\":{\"308\":1}}],[\"com\",{\"1\":{\"275\":1,\"293\":1,\"295\":1,\"303\":3,\"306\":1,\"307\":1,\"308\":4,\"313\":2,\"318\":1}}],[\"comparison\",{\"1\":{\"243\":1}}],[\"compared\",{\"1\":{\"242\":1,\"243\":2}}],[\"compareto\",{\"0\":{\"243\":1},\"1\":{\"241\":1,\"243\":4}}],[\"compares\",{\"1\":{\"241\":1,\"242\":1,\"243\":1}}],[\"compareandset\",{\"1\":{\"111\":1}}],[\"compare\",{\"1\":{\"110\":1,\"241\":1,\"242\":1}}],[\"computeifpresent\",{\"1\":{\"73\":1}}],[\"computeifabsent\",{\"1\":{\"73\":1}}],[\"code\",{\"1\":{\"52\":1,\"116\":1,\"220\":1,\"229\":1,\"231\":1,\"232\":3,\"233\":1,\"234\":2,\"235\":1,\"236\":3,\"238\":1,\"239\":5,\"240\":12,\"241\":7,\"242\":11,\"243\":13,\"244\":6}}],[\"conf\",{\"1\":{\"310\":3}}],[\"configure\",{\"1\":{\"314\":1}}],[\"configuration\",{\"1\":{\"310\":10}}],[\"config\",{\"1\":{\"293\":1,\"310\":15}}],[\"contract\",{\"1\":{\"318\":4}}],[\"control\",{\"1\":{\"234\":1,\"299\":1}}],[\"contents\",{\"1\":{\"233\":1,\"235\":1,\"236\":1}}],[\"containerport\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"containers\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"contained\",{\"1\":{\"233\":1,\"235\":1,\"236\":1}}],[\"containsvalue\",{\"1\":{\"73\":1}}],[\"containskey\",{\"1\":{\"73\":1}}],[\"containsall\",{\"1\":{\"47\":1}}],[\"contains\",{\"1\":{\"47\":1,\"235\":1,\"236\":1}}],[\"considered\",{\"1\":{\"242\":2}}],[\"considerations\",{\"1\":{\"242\":1}}],[\"constructs\",{\"1\":{\"234\":1}}],[\"constructor\",{\"1\":{\"231\":1,\"232\":1,\"234\":1,\"236\":1,\"275\":1}}],[\"conscious\",{\"1\":{\"52\":1}}],[\"condition\",{\"1\":{\"140\":2}}],[\"concurrentmodificationexception\",{\"1\":{\"280\":1}}],[\"concurrent\",{\"1\":{\"140\":1,\"209\":2}}],[\"concurrentlinkeddeque\",{\"0\":{\"86\":1}}],[\"concurrentlinkedqueue\",{\"0\":{\"85\":1}}],[\"concurrentskiplistmap\",{\"0\":{\"80\":1}}],[\"concurrentskiplistset\",{\"0\":{\"72\":1}}],[\"concurrenthashmap\",{\"0\":{\"79\":1,\"284\":1}}],[\"collections\",{\"0\":{\"258\":1},\"1\":{\"258\":1}}],[\"collection<\",{\"1\":{\"47\":4}}],[\"collection\",{\"0\":{\"47\":1,\"258\":1},\"1\":{\"47\":1,\"49\":2,\"258\":1}}],[\"tz=asia\",{\"1\":{\"318\":1}}],[\"tgz\",{\"1\":{\"307\":2}}],[\"two\",{\"1\":{\"242\":4,\"243\":4}}],[\"tee\",{\"1\":{\"295\":1}}],[\"tests\",{\"1\":{\"244\":1}}],[\"test\",{\"1\":{\"151\":1,\"316\":5}}],[\"terminated\",{\"0\":{\"123\":1}}],[\"template\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"temp\",{\"1\":{\"14\":2}}],[\"timezone\",{\"1\":{\"318\":1}}],[\"timed\",{\"0\":{\"122\":1}}],[\"timeout\",{\"1\":{\"121\":2,\"122\":2,\"308\":1}}],[\"tar\",{\"1\":{\"303\":2,\"307\":1,\"313\":2}}],[\"targetport\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"target用于标明注解使用的范围\",{\"1\":{\"24\":1}}],[\"target\",{\"1\":{\"24\":1,\"26\":1,\"318\":1}}],[\"ta\",{\"1\":{\"244\":2}}],[\"tab\",{\"1\":{\"75\":1}}],[\"table\",{\"1\":{\"74\":1,\"75\":3}}],[\"transient\",{\"1\":{\"272\":3}}],[\"transmittable\",{\"0\":{\"183\":1}}],[\"trace\",{\"1\":{\"191\":6}}],[\"tryloadingfromjavaseloader\",{\"1\":{\"191\":3}}],[\"try\",{\"0\":{\"268\":2},\"1\":{\"191\":8}}],[\"treemap\",{\"0\":{\"76\":1}}],[\"treeifybin\",{\"1\":{\"75\":1}}],[\"treeify\",{\"1\":{\"74\":3}}],[\"treeset\",{\"0\":{\"69\":1}}],[\"true\",{\"1\":{\"47\":1,\"133\":1,\"191\":2,\"239\":2,\"241\":4,\"242\":5,\"243\":1,\"244\":2,\"250\":1,\"275\":1}}],[\"touch\",{\"1\":{\"324\":1}}],[\"touppercase\",{\"1\":{\"242\":1}}],[\"tool\",{\"1\":{\"314\":1}}],[\"token有效时间\",{\"1\":{\"308\":1}}],[\"token\",{\"0\":{\"304\":1},\"1\":{\"305\":1,\"308\":1}}],[\"to++\",{\"1\":{\"244\":1}}],[\"toffset\",{\"0\":{\"244\":1},\"1\":{\"244\":9}}],[\"tolowercase\",{\"1\":{\"242\":1}}],[\"to\",{\"1\":{\"191\":4,\"202\":1,\"229\":1,\"234\":2,\"236\":3,\"238\":1,\"240\":1,\"241\":3,\"242\":4,\"243\":3,\"244\":2,\"310\":2}}],[\"tomcat\",{\"0\":{\"190\":1},\"1\":{\"190\":3}}],[\"toarray\",{\"1\":{\"47\":2}}],[\"tostring\",{\"1\":{\"14\":4,\"191\":1,\"236\":1}}],[\"than\",{\"1\":{\"240\":1,\"243\":4,\"244\":1}}],[\"that\",{\"1\":{\"231\":2,\"232\":1,\"233\":1,\"235\":1,\"236\":1,\"241\":1,\"243\":3}}],[\"there\",{\"1\":{\"243\":1}}],[\"their\",{\"1\":{\"243\":1}}],[\"then\",{\"1\":{\"243\":3}}],[\"they\",{\"1\":{\"242\":1,\"243\":3}}],[\"the\",{\"1\":{\"191\":1,\"209\":1,\"229\":3,\"232\":4,\"233\":8,\"234\":13,\"235\":6,\"236\":7,\"238\":6,\"240\":15,\"241\":6,\"242\":13,\"243\":34,\"244\":13}}],[\"threaddump\",{\"1\":{\"212\":1}}],[\"threadlocal\",{\"0\":{\"182\":1},\"1\":{\"115\":1}}],[\"thread\",{\"0\":{\"115\":1,\"125\":1,\"183\":1},\"1\":{\"97\":2,\"115\":1,\"121\":1,\"122\":4,\"124\":2,\"125\":2,\"129\":1,\"130\":1,\"138\":1,\"139\":1,\"264\":2}}],[\"threshold\",{\"1\":{\"74\":4}}],[\"throwable\",{\"1\":{\"191\":1,\"218\":1,\"221\":1}}],[\"throw\",{\"1\":{\"52\":2,\"191\":8,\"240\":1}}],[\"throws\",{\"1\":{\"21\":1,\"191\":3,\"218\":1,\"221\":1}}],[\"this\",{\"1\":{\"11\":5,\"12\":3,\"14\":6,\"50\":4,\"191\":2,\"218\":1,\"221\":1,\"231\":2,\"232\":3,\"233\":1,\"234\":2,\"235\":1,\"236\":2,\"238\":2,\"240\":2,\"241\":5,\"242\":3,\"243\":11,\"244\":5}}],[\"type\",{\"1\":{\"16\":1,\"45\":1,\"275\":1}}],[\"t>\",{\"1\":{\"14\":2}}],[\"t是type的简称\",{\"1\":{\"11\":1}}],[\"t\",{\"1\":{\"9\":2,\"11\":9,\"12\":5,\"14\":8,\"21\":4,\"47\":1,\"191\":1,\"221\":2,\"305\":1,\"318\":4}}],[\"每一个程序还占用某些系统资源如\",{\"1\":{\"271\":1}}],[\"每次垃圾收集时都发现有大批对象死去\",{\"1\":{\"208\":1}}],[\"每次都是对其中的一块进行内存回收\",{\"1\":{\"208\":1}}],[\"每次只使用其中的一块\",{\"1\":{\"208\":1}}],[\"每个对象有一个引用计数属性\",{\"1\":{\"207\":1}}],[\"每个线程都有属于自己的程序计数器\",{\"1\":{\"200\":1}}],[\"每个线程是抢夺\",{\"1\":{\"200\":1}}],[\"每个方法从调用直至执行完成的过程\",{\"1\":{\"197\":1,\"198\":1}}],[\"每个方法在执行的同时都会创建一个线帧用于存储局部变量表\",{\"1\":{\"197\":1,\"198\":1}}],[\"每个\",{\"1\":{\"190\":1}}],[\"每个重载的方法\",{\"1\":{\"7\":1}}],[\"每种类型都需要重载一个add方法\",{\"1\":{\"9\":1}}],[\"f\",{\"1\":{\"211\":1,\"318\":4}}],[\"follows\",{\"1\":{\"243\":1}}],[\"following\",{\"1\":{\"242\":1}}],[\"for\",{\"1\":{\"229\":3,\"240\":1,\"243\":1}}],[\"format=b\",{\"1\":{\"211\":1}}],[\"forname\",{\"1\":{\"191\":4,\"275\":2}}],[\"found\",{\"1\":{\"191\":1,\"326\":1}}],[\"fail\",{\"0\":{\"280\":1},\"1\":{\"310\":1}}],[\"fast\",{\"0\":{\"280\":1}}],[\"faster\",{\"1\":{\"236\":1}}],[\"fastthread\",{\"1\":{\"212\":1}}],[\"false\",{\"1\":{\"191\":3,\"239\":1,\"241\":3,\"242\":1,\"244\":4,\"249\":1,\"266\":1,\"308\":1}}],[\"factor\",{\"1\":{\"74\":1}}],[\"from\",{\"1\":{\"191\":5,\"202\":1,\"229\":1,\"236\":1,\"240\":1,\"308\":1,\"318\":1}}],[\"fence\",{\"1\":{\"92\":1}}],[\"firewalld\",{\"1\":{\"290\":2}}],[\"first\",{\"1\":{\"58\":1,\"240\":2}}],[\"field\",{\"1\":{\"275\":1}}],[\"file\",{\"1\":{\"310\":13}}],[\"file=dumpfile\",{\"1\":{\"211\":1}}],[\"filter\",{\"1\":{\"47\":2,\"191\":1,\"308\":1}}],[\"findloadedclass\",{\"1\":{\"191\":1}}],[\"findloadedclass0\",{\"1\":{\"191\":1}}],[\"findclassinternal\",{\"1\":{\"191\":4}}],[\"findclass\",{\"1\":{\"191\":4}}],[\"finally\",{\"0\":{\"268\":2},\"1\":{\"268\":2}}],[\"final的实现原理\",{\"0\":{\"162\":1}}],[\"final域读\",{\"1\":{\"161\":1}}],[\"final域写\",{\"1\":{\"161\":1}}],[\"final域写针对编译器和处理器重排序增加了这样的约束\",{\"1\":{\"159\":1}}],[\"final域为引用类型\",{\"0\":{\"158\":1}}],[\"final域为基本类型\",{\"0\":{\"155\":1}}],[\"final域重排序规则\",{\"0\":{\"154\":1}}],[\"final方法是可以被重载的\",{\"1\":{\"151\":1}}],[\"final类中的所有方法都隐式为final\",{\"1\":{\"150\":1}}],[\"final基础使用\",{\"0\":{\"149\":1}}],[\"finalize\",{\"1\":{\"97\":1,\"264\":1,\"277\":1}}],[\"final\",{\"0\":{\"96\":1,\"148\":1,\"264\":1},\"1\":{\"6\":3,\"93\":1,\"229\":3,\"255\":1,\"264\":6}}],[\"fixedthreadpool\",{\"1\":{\"127\":2}}],[\"function\",{\"1\":{\"234\":1}}],[\"function<\",{\"1\":{\"73\":1}}],[\"fun\",{\"1\":{\"14\":3}}],[\"float\",{\"1\":{\"9\":3,\"74\":1,\"249\":2}}],[\"=10这句时\",{\"1\":{\"90\":1}}],[\"==\",{\"0\":{\"253\":1,\"266\":1},\"1\":{\"52\":1,\"75\":1,\"191\":2,\"239\":1,\"241\":2,\"242\":3,\"253\":1}}],[\"=\",{\"1\":{\"9\":4,\"11\":6,\"12\":3,\"14\":5,\"15\":6,\"21\":1,\"52\":2,\"74\":6,\"75\":1,\"90\":1,\"160\":1,\"191\":31,\"218\":3,\"221\":3,\"229\":1,\"231\":1,\"232\":2,\"233\":1,\"235\":1,\"236\":1,\"241\":7,\"242\":1,\"243\":9,\"244\":6,\"259\":4,\"267\":2,\"308\":30,\"310\":2}}],[\"+g1younggensize=512m\",{\"1\":{\"209\":1}}],[\"+unlockexperimentalvmoptions\",{\"1\":{\"209\":1}}],[\"+useg1gc\",{\"1\":{\"209\":1}}],[\"+useconcmarksweepgc选项\",{\"1\":{\"209\":1}}],[\"+useparnewgc选项来开启\",{\"1\":{\"209\":2}}],[\"+新生代\",{\"1\":{\"202\":1}}],[\"+老年区\",{\"1\":{\"202\":1}}],[\"+=\",{\"1\":{\"91\":1,\"267\":1}}],[\"+\",{\"1\":{\"9\":28,\"11\":2,\"12\":1,\"14\":1,\"52\":2,\"91\":1,\"191\":14,\"202\":2,\"209\":1,\"218\":1,\"221\":1}}],[\"omgt\",{\"1\":{\"318\":12,\"323\":1}}],[\"otn\",{\"1\":{\"313\":1}}],[\"otherwise\",{\"1\":{\"239\":1,\"241\":1,\"242\":1,\"244\":2}}],[\"other\",{\"1\":{\"232\":1,\"243\":1}}],[\"o=vmware\",{\"1\":{\"310\":1}}],[\"o=\",{\"1\":{\"310\":1}}],[\"oom\",{\"0\":{\"270\":1},\"1\":{\"270\":1}}],[\"operator\",{\"1\":{\"242\":1,\"243\":1}}],[\"option\",{\"1\":{\"214\":4}}],[\"options\",{\"1\":{\"214\":1}}],[\"org\",{\"1\":{\"313\":1}}],[\"oraclelicense=accept\",{\"1\":{\"313\":1}}],[\"oracle\",{\"1\":{\"313\":2}}],[\"ordering\",{\"1\":{\"243\":1}}],[\"or\",{\"1\":{\"240\":1,\"243\":3,\"244\":1}}],[\"original\",{\"0\":{\"232\":1},\"1\":{\"232\":5}}],[\"obtaining\",{\"1\":{\"236\":1}}],[\"obj\",{\"1\":{\"21\":2,\"221\":2,\"250\":4}}],[\"objectclass=person\",{\"1\":{\"308\":1}}],[\"object\",{\"0\":{\"241\":2,\"277\":1},\"1\":{\"14\":1,\"21\":2,\"47\":2,\"50\":1,\"73\":7,\"121\":3,\"122\":5,\"138\":1,\"139\":1,\"218\":5,\"221\":3,\"231\":1,\"232\":1,\"238\":1,\"241\":6,\"242\":1,\"243\":4,\"244\":2}}],[\"of\",{\"1\":{\"231\":1,\"232\":4,\"233\":4,\"234\":5,\"235\":3,\"236\":3,\"238\":4,\"240\":4,\"241\":1,\"242\":2,\"243\":5,\"244\":5}}],[\"online\",{\"1\":{\"307\":2}}],[\"only\",{\"1\":{\"239\":1,\"241\":1}}],[\"one\",{\"1\":{\"242\":1,\"243\":1}}],[\"on\",{\"1\":{\"191\":1,\"240\":1,\"243\":1,\"308\":3}}],[\"ou=harbor\",{\"1\":{\"310\":1}}],[\"ou=people\",{\"1\":{\"308\":2}}],[\"our\",{\"1\":{\"191\":1}}],[\"outofmemoryerror\",{\"1\":{\"52\":2,\"197\":1,\"199\":1}}],[\"out\",{\"1\":{\"9\":4,\"11\":3,\"12\":1,\"14\":1,\"218\":3,\"221\":3}}],[\"oader\",{\"1\":{\"190\":1}}],[\"old的并行版本\",{\"1\":{\"209\":1}}],[\"old是serial\",{\"1\":{\"209\":1}}],[\"old是parallel\",{\"1\":{\"209\":1}}],[\"old策略进行gc\",{\"1\":{\"209\":1}}],[\"old都是单线程进行gc\",{\"1\":{\"209\":1}}],[\"old\",{\"1\":{\"209\":7}}],[\"oldvalue\",{\"1\":{\"73\":2}}],[\"oldcapacity\",{\"1\":{\"52\":5}}],[\"o\",{\"1\":{\"47\":2,\"88\":2,\"132\":1,\"218\":5,\"256\":1,\"311\":1}}],[\"ok\",{\"1\":{\"15\":3}}],[\"over\",{\"1\":{\"234\":1}}],[\"overflow\",{\"1\":{\"52\":3}}],[\"overloading\",{\"1\":{\"7\":1}}],[\"override\",{\"1\":{\"6\":1,\"24\":1,\"25\":2,\"191\":2,\"218\":2,\"221\":1}}],[\"sf\",{\"1\":{\"318\":1}}],[\"scope\",{\"1\":{\"308\":1}}],[\"scavenge策略主要是关注一个可控的吞吐量\",{\"1\":{\"209\":1}}],[\"scavenge\",{\"1\":{\"209\":2}}],[\"scavenge收集器的老年代版本\",{\"1\":{\"209\":1}}],[\"scavenge收集器类似parnew收集器\",{\"1\":{\"209\":1}}],[\"smtp\",{\"1\":{\"308\":1}}],[\"smaller\",{\"1\":{\"243\":1}}],[\"smallest\",{\"1\":{\"243\":1}}],[\"ssl\",{\"1\":{\"308\":3}}],[\"ssl需要设置on\",{\"1\":{\"308\":1}}],[\"share\",{\"1\":{\"318\":1}}],[\"shanghai\",{\"1\":{\"318\":1}}],[\"sh\",{\"1\":{\"309\":1,\"310\":1}}],[\"short\",{\"1\":{\"249\":2}}],[\"shorter\",{\"1\":{\"243\":1}}],[\"should\",{\"1\":{\"234\":1}}],[\"shutdownnow\",{\"1\":{\"134\":1}}],[\"shutdown\",{\"1\":{\"134\":1}}],[\"saved\",{\"1\":{\"310\":1}}],[\"sample\",{\"1\":{\"308\":1}}],[\"same\",{\"1\":{\"232\":1,\"241\":1,\"242\":5,\"244\":1}}],[\"sayhell\",{\"1\":{\"218\":3,\"221\":2}}],[\"sof\",{\"0\":{\"270\":1},\"1\":{\"270\":1}}],[\"softreference\",{\"1\":{\"259\":2}}],[\"some\",{\"1\":{\"243\":1}}],[\"so\",{\"1\":{\"231\":1,\"232\":1,\"233\":1,\"240\":1}}],[\"son进行向上转型得到father\",{\"1\":{\"151\":1}}],[\"s\",{\"1\":{\"218\":3,\"221\":2,\"234\":1,\"259\":1}}],[\"s|ms\",{\"1\":{\"214\":1}}],[\"s系统的服务端上\",{\"1\":{\"209\":1}}],[\"sweep\",{\"1\":{\"209\":2}}],[\"swap\",{\"1\":{\"110\":1}}],[\"since\",{\"1\":{\"231\":1,\"232\":1,\"234\":1,\"236\":1,\"239\":1}}],[\"singlethreadexecutor\",{\"1\":{\"127\":1}}],[\"signalall\",{\"0\":{\"140\":1},\"1\":{\"140\":1}}],[\"signal\",{\"0\":{\"140\":1},\"1\":{\"140\":1}}],[\"size\",{\"1\":{\"47\":1,\"49\":1,\"52\":3,\"73\":1,\"74\":1}}],[\"sleep\",{\"0\":{\"129\":1,\"139\":1},\"1\":{\"122\":3,\"129\":2,\"133\":1,\"139\":2,\"168\":1,\"318\":1}}],[\"sysconfig\",{\"1\":{\"312\":1}}],[\"systemctl\",{\"1\":{\"290\":2,\"293\":1,\"294\":1,\"295\":2,\"311\":1}}],[\"system\",{\"1\":{\"9\":4,\"11\":3,\"12\":1,\"14\":1,\"218\":3,\"221\":3}}],[\"synchronized关键字和lock的实现类都是悲观锁\",{\"1\":{\"142\":1}}],[\"synchronized和lock保证每个时刻是有一个线程执行同步代码\",{\"1\":{\"100\":1}}],[\"synchronized和lock能保证同一时刻只有一个线程获取锁然后执行同步代码\",{\"1\":{\"99\":1}}],[\"synchronized\",{\"0\":{\"95\":1,\"175\":1},\"1\":{\"93\":1,\"132\":1,\"135\":1,\"191\":1,\"235\":2}}],[\"spring\",{\"0\":{\"325\":1}}],[\"springboot\",{\"0\":{\"317\":1}}],[\"spring会强制使用cglib来实现动态代理\",{\"1\":{\"225\":1}}],[\"spec\",{\"1\":{\"316\":4,\"318\":4,\"324\":4}}],[\"specified\",{\"1\":{\"234\":1,\"240\":3,\"241\":1,\"244\":2}}],[\"spotify\",{\"1\":{\"212\":1}}],[\"spliterator\",{\"1\":{\"47\":1}}],[\"spirng默认采用jdk动态代理实现机制\",{\"1\":{\"225\":1}}],[\"spi整体机制图\",{\"1\":{\"43\":1}}],[\"spi整体机制图如下\",{\"1\":{\"43\":1}}],[\"spi\",{\"0\":{\"42\":1,\"43\":1,\"44\":1,\"45\":1},\"1\":{\"43\":1}}],[\"sudo\",{\"1\":{\"295\":4,\"296\":2,\"311\":2}}],[\"such\",{\"1\":{\"243\":1}}],[\"surrogate\",{\"1\":{\"240\":1}}],[\"survivorratio=6\",{\"1\":{\"209\":1}}],[\"subj\",{\"1\":{\"310\":2}}],[\"subsequent\",{\"1\":{\"233\":1,\"235\":1,\"236\":1}}],[\"substring\",{\"1\":{\"191\":1,\"244\":3}}],[\"subtype\",{\"1\":{\"45\":1}}],[\"suppresswarnings\",{\"1\":{\"24\":1,\"25\":2}}],[\"superclass\",{\"1\":{\"191\":1}}],[\"super\",{\"1\":{\"14\":4,\"47\":1,\"73\":3,\"191\":1}}],[\"sql\",{\"1\":{\"43\":1}}],[\"selector\",{\"1\":{\"316\":2,\"318\":2,\"324\":2}}],[\"self\",{\"1\":{\"308\":1}}],[\"search\",{\"1\":{\"308\":1}}],[\"searchdn\",{\"1\":{\"308\":1}}],[\"searching\",{\"1\":{\"191\":1}}],[\"securebackup\",{\"1\":{\"313\":1}}],[\"security\",{\"1\":{\"191\":3,\"318\":1}}],[\"securitymanager\",{\"1\":{\"191\":6}}],[\"secrets\",{\"1\":{\"311\":1}}],[\"secret\",{\"1\":{\"310\":1}}],[\"secretkey\",{\"1\":{\"308\":1,\"310\":1}}],[\"see\",{\"1\":{\"241\":2,\"242\":1}}],[\"sequence\",{\"1\":{\"231\":1,\"232\":1,\"233\":1,\"235\":1,\"236\":1,\"238\":1,\"240\":1,\"241\":1,\"243\":2,\"244\":1}}],[\"server\",{\"1\":{\"308\":4,\"318\":6}}],[\"serviceport\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"servicename\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"serviceloader\",{\"1\":{\"43\":1}}],[\"services\",{\"1\":{\"43\":2}}],[\"service\",{\"1\":{\"43\":1,\"290\":2,\"312\":1,\"316\":1,\"318\":3,\"324\":3}}],[\"serializable\",{\"1\":{\"257\":2}}],[\"serialversionuid\",{\"1\":{\"229\":2}}],[\"serial和serial\",{\"1\":{\"209\":1}}],[\"serial\",{\"1\":{\"209\":5}}],[\"serial收集器\",{\"1\":{\"209\":1}}],[\"se\",{\"1\":{\"190\":1,\"191\":3}}],[\"set\",{\"0\":{\"276\":1},\"1\":{\"276\":1}}],[\"setaccessible\",{\"1\":{\"275\":1}}],[\"setcallback\",{\"1\":{\"221\":1}}],[\"setsuperclass\",{\"1\":{\"221\":1}}],[\"setdaemon\",{\"1\":{\"128\":1}}],[\"set<map\",{\"1\":{\"74\":1}}],[\"set的父类\",{\"1\":{\"47\":1}}],[\"setvalue\",{\"1\":{\"11\":2}}],[\"setvar\",{\"1\":{\"11\":2,\"12\":2,\"14\":4}}],[\"setkey\",{\"1\":{\"11\":2}}],[\"steps\",{\"1\":{\"315\":1}}],[\"st=california\",{\"1\":{\"310\":1}}],[\"st=\",{\"1\":{\"310\":1}}],[\"stopped\",{\"1\":{\"296\":1}}],[\"stop\",{\"1\":{\"290\":1}}],[\"storeload\",{\"1\":{\"174\":2}}],[\"storestore\",{\"1\":{\"174\":2,\"264\":1}}],[\"storage\",{\"0\":{\"115\":1},\"1\":{\"229\":1,\"307\":1}}],[\"status\",{\"1\":{\"316\":2,\"318\":2,\"324\":2}}],[\"static\",{\"0\":{\"265\":1},\"1\":{\"6\":1,\"9\":4,\"11\":2,\"12\":1,\"14\":3,\"21\":1,\"52\":1,\"218\":1,\"221\":1,\"229\":1}}],[\"stable\",{\"1\":{\"311\":2}}],[\"staic\",{\"1\":{\"265\":1}}],[\"starting\",{\"1\":{\"244\":1}}],[\"starts\",{\"1\":{\"244\":1}}],[\"startswith\",{\"0\":{\"244\":1},\"1\":{\"244\":2}}],[\"start\",{\"1\":{\"97\":1,\"264\":1,\"293\":1,\"318\":1}}],[\"stackoverflowerror\",{\"1\":{\"197\":1,\"199\":1}}],[\"stack\",{\"0\":{\"67\":1},\"1\":{\"48\":1}}],[\"str\",{\"1\":{\"259\":1}}],[\"stream\",{\"1\":{\"47\":1}}],[\"stringindexoutofboundsexception\",{\"1\":{\"240\":1}}],[\"stringbuilder\",{\"0\":{\"236\":1,\"255\":1},\"1\":{\"236\":4,\"255\":2}}],[\"stringbufer\",{\"1\":{\"235\":1}}],[\"stringbuffer\",{\"0\":{\"235\":1,\"255\":1},\"1\":{\"235\":5,\"255\":2}}],[\"strings\",{\"1\":{\"231\":1,\"232\":1,\"242\":2,\"243\":6}}],[\"string源码\",{\"0\":{\"228\":1}}],[\"string类的父类只有object类\",{\"1\":{\"14\":1}}],[\"string>\",{\"1\":{\"14\":1}}],[\"string\",{\"0\":{\"231\":1,\"232\":2,\"233\":1,\"234\":1,\"235\":1,\"236\":1,\"242\":1,\"243\":1,\"244\":1,\"255\":1},\"1\":{\"11\":2,\"12\":1,\"14\":4,\"191\":5,\"218\":3,\"221\":2,\"229\":1,\"231\":2,\"232\":6,\"233\":4,\"234\":3,\"235\":6,\"236\":8,\"238\":2,\"240\":2,\"241\":10,\"242\":6,\"243\":19,\"244\":4,\"255\":2,\"259\":5}}],[\"b15\",{\"1\":{\"313\":1}}],[\"b=\",{\"1\":{\"267\":1}}],[\"blockquote>\",{\"1\":{\"243\":2}}],[\"blocking\",{\"0\":{\"120\":1}}],[\"both\",{\"1\":{\"243\":2}}],[\"bootstrapclassloader\",{\"1\":{\"191\":1}}],[\"boolean\",{\"1\":{\"191\":3,\"239\":1,\"241\":1,\"242\":1,\"244\":1,\"249\":5}}],[\"build\",{\"1\":{\"315\":1,\"318\":5,\"319\":1}}],[\"builder\",{\"0\":{\"236\":1},\"1\":{\"236\":8}}],[\"buffer\",{\"0\":{\"235\":1},\"1\":{\"235\":8}}],[\"begin\",{\"1\":{\"244\":1}}],[\"beginning\",{\"1\":{\"244\":1}}],[\"behavior\",{\"1\":{\"234\":1}}],[\"be\",{\"1\":{\"234\":3,\"243\":2,\"244\":1}}],[\"before\",{\"0\":{\"97\":1,\"173\":2},\"1\":{\"93\":1,\"100\":1,\"264\":1}}],[\"bin\",{\"1\":{\"313\":1,\"318\":5}}],[\"binaries\",{\"1\":{\"313\":1}}],[\"binarynametopath\",{\"1\":{\"191\":1}}],[\"bifunction<\",{\"1\":{\"73\":1}}],[\"bytes\",{\"0\":{\"234\":1},\"1\":{\"234\":7}}],[\"byte\",{\"0\":{\"234\":1},\"1\":{\"234\":2,\"249\":3,\"267\":2}}],[\"by\",{\"1\":{\"191\":1,\"234\":1,\"238\":1,\"240\":1,\"242\":1,\"243\":3,\"244\":1}}],[\"bash\",{\"1\":{\"318\":1}}],[\"baseurl=https\",{\"1\":{\"306\":1}}],[\"basedn\",{\"1\":{\"308\":1}}],[\"based\",{\"1\":{\"243\":1}}],[\"base和son都有方法test\",{\"1\":{\"151\":1}}],[\"base\",{\"1\":{\"45\":1}}],[\"backend\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"barrier\",{\"1\":{\"171\":2}}],[\"barriers\",{\"1\":{\"92\":1}}],[\"b\",{\"1\":{\"9\":16,\"97\":2,\"110\":2,\"112\":1,\"264\":2,\"267\":1}}],[\"ip\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"identity\",{\"1\":{\"308\":1}}],[\"i>\",{\"1\":{\"243\":2}}],[\"ignoring\",{\"1\":{\"242\":5}}],[\"ignore\",{\"1\":{\"191\":3}}],[\"io\",{\"0\":{\"184\":1,\"273\":1,\"274\":1},\"1\":{\"212\":4,\"274\":1,\"311\":3,\"316\":1,\"318\":1,\"324\":1}}],[\"i++\",{\"1\":{\"241\":1}}],[\"i++其实是一个复合操作\",{\"1\":{\"168\":1}}],[\"i++为什么不能保证原子性\",{\"0\":{\"168\":1}}],[\"import\",{\"1\":{\"265\":1,\"311\":1}}],[\"implements\",{\"1\":{\"12\":1,\"218\":2,\"221\":1}}],[\"immutable\",{\"1\":{\"102\":1,\"231\":1,\"232\":1}}],[\"imagepullpolicy\",{\"1\":{\"318\":1}}],[\"image\",{\"1\":{\"92\":1,\"117\":1,\"144\":1,\"174\":2,\"316\":1,\"318\":1,\"323\":2,\"324\":3}}],[\"illegalmonitorstateexeception\",{\"1\":{\"138\":1}}],[\"illegalaccessexception\",{\"1\":{\"21\":1}}],[\"ilp\",{\"1\":{\"92\":1}}],[\"if\",{\"1\":{\"52\":4,\"191\":39,\"239\":3,\"240\":2,\"241\":7,\"242\":3,\"243\":10,\"244\":5}}],[\"i2\",{\"1\":{\"14\":3}}],[\"i1\",{\"1\":{\"14\":4}}],[\"i\",{\"1\":{\"12\":3,\"88\":2,\"90\":2,\"91\":3,\"132\":1,\"191\":3,\"241\":3}}],[\"ingress\",{\"1\":{\"316\":2,\"318\":4,\"324\":4}}],[\"inc\",{\"1\":{\"310\":1}}],[\"indexoutofboundsexception\",{\"1\":{\"240\":1}}],[\"indexing\",{\"1\":{\"240\":1}}],[\"index\",{\"0\":{\"240\":1},\"1\":{\"240\":15,\"243\":5,\"244\":2}}],[\"in\",{\"1\":{\"232\":1,\"233\":1,\"234\":1,\"235\":1,\"236\":1,\"238\":1,\"242\":1,\"243\":4,\"244\":1}}],[\"invokesuper\",{\"1\":{\"221\":1}}],[\"invoke\",{\"1\":{\"218\":2}}],[\"invocationhandler\",{\"1\":{\"218\":1}}],[\"invocationhandler是一个接口\",{\"1\":{\"217\":1}}],[\"installer\",{\"1\":{\"307\":2}}],[\"install\",{\"1\":{\"292\":1,\"293\":1,\"306\":1,\"309\":1,\"310\":1,\"311\":1,\"318\":1,\"322\":1}}],[\"instanceof\",{\"0\":{\"250\":1},\"1\":{\"241\":1,\"250\":1}}],[\"instantiationexception\",{\"1\":{\"21\":1}}],[\"instruction\",{\"1\":{\"92\":1}}],[\"initialadminpassowrd\",{\"1\":{\"311\":1}}],[\"initializes\",{\"1\":{\"231\":1,\"232\":1}}],[\"initialization\",{\"0\":{\"196\":1}}],[\"initial\",{\"1\":{\"74\":1,\"233\":1}}],[\"initialcapacity\",{\"1\":{\"50\":1}}],[\"inf\",{\"1\":{\"43\":2}}],[\"info<\",{\"1\":{\"14\":1}}],[\"info<object>\",{\"1\":{\"14\":2}}],[\"info<integer>\",{\"1\":{\"14\":2}}],[\"info<t\",{\"1\":{\"14\":1}}],[\"info<t>\",{\"1\":{\"12\":2,\"14\":1}}],[\"info<string>\",{\"1\":{\"12\":1,\"14\":2}}],[\"infoimpl<string>\",{\"1\":{\"12\":1}}],[\"infoimpl<t>\",{\"1\":{\"12\":1}}],[\"infoimpl\",{\"1\":{\"12\":1}}],[\"inherited用于标明注解可继承\",{\"1\":{\"24\":1}}],[\"inherited\",{\"1\":{\"24\":1,\"26\":1}}],[\"intb+=a\",{\"1\":{\"267\":1}}],[\"into\",{\"1\":{\"234\":1}}],[\"interoperability\",{\"1\":{\"229\":1}}],[\"intercept\",{\"1\":{\"221\":1}}],[\"interval\",{\"1\":{\"214\":1}}],[\"interruptedexception\",{\"0\":{\"132\":1},\"1\":{\"129\":1,\"132\":1,\"133\":1}}],[\"interrupted\",{\"0\":{\"133\":1},\"1\":{\"97\":1,\"133\":2,\"264\":1}}],[\"interrupt\",{\"1\":{\"97\":1,\"132\":1,\"133\":2,\"134\":1,\"264\":1}}],[\"interface\",{\"1\":{\"12\":1,\"43\":1,\"218\":1}}],[\"intel\",{\"1\":{\"92\":1}}],[\"integer\",{\"1\":{\"52\":2,\"243\":2,\"249\":1,\"251\":1}}],[\"integer>\",{\"1\":{\"11\":2}}],[\"int\",{\"0\":{\"240\":1,\"244\":1},\"1\":{\"9\":3,\"47\":1,\"52\":7,\"73\":1,\"74\":4,\"191\":1,\"229\":1,\"238\":1,\"240\":1,\"241\":2,\"243\":5,\"244\":4,\"249\":2}}],[\"item\",{\"1\":{\"315\":1}}],[\"it\",{\"1\":{\"11\":1,\"191\":1,\"231\":1,\"232\":1,\"233\":1,\"242\":1}}],[\"istraceenabled\",{\"1\":{\"191\":8}}],[\"isdebugenabled\",{\"1\":{\"191\":10}}],[\"isempty\",{\"0\":{\"239\":1},\"1\":{\"47\":1,\"73\":1,\"239\":1}}],[\"is\",{\"1\":{\"3\":2,\"191\":2,\"229\":1,\"231\":1,\"232\":3,\"234\":3,\"236\":3,\"238\":1,\"239\":2,\"240\":5,\"241\":3,\"242\":2,\"243\":13,\"244\":4}}],[\"泛型常用特点\",{\"0\":{\"260\":1}}],[\"泛型数组\",{\"0\":{\"15\":1}}],[\"泛型类\",{\"0\":{\"11\":1}}],[\"泛型的桥接方法\",{\"0\":{\"19\":1}}],[\"泛型的擦除原则\",{\"0\":{\"17\":1}}],[\"泛型的上下限\",{\"0\":{\"14\":1}}],[\"泛型的基本使用\",{\"0\":{\"10\":1}}],[\"泛型的引入主要是为了提高代码的复用性和可读性\",{\"1\":{\"9\":1}}],[\"泛型的本质是为了参数化类型\",{\"1\":{\"8\":1}}],[\"泛型方法调用\",{\"1\":{\"13\":1}}],[\"泛型方法定义\",{\"1\":{\"13\":2}}],[\"泛型方法\",{\"0\":{\"13\":1},\"1\":{\"8\":1}}],[\"泛型接口\",{\"0\":{\"12\":1},\"1\":{\"8\":1}}],[\"泛型机制\",{\"0\":{\"8\":1}}],[\"无其他作用\",{\"1\":{\"168\":1}}],[\"无法解决对象相互循环引用的问题\",{\"1\":{\"207\":1}}],[\"无法被访问到\",{\"1\":{\"151\":1}}],[\"无法以返回值类型作为重载函数的区分标准\",{\"1\":{\"7\":1}}],[\"无锁\",{\"0\":{\"144\":1}}],[\"无需等待其它线程显式地唤醒\",{\"1\":{\"122\":1}}],[\"无限期等待\",{\"0\":{\"121\":1}}],[\"无限制类型擦除\",{\"1\":{\"18\":2}}],[\"无限制通配符\",{\"1\":{\"14\":1}}],[\"无须同步也能保证线程之间不出现数据争用的问题\",{\"1\":{\"115\":1}}],[\"无同步方案\",{\"0\":{\"113\":1}}],[\"无论共享数据是否真的会出现竞争\",{\"1\":{\"108\":1}}],[\"无论被重写的方法是否抛出异常\",{\"1\":{\"6\":1}}],[\"无参的构造方法什么都为进行初始化\",{\"1\":{\"56\":1}}],[\"无参\",{\"1\":{\"50\":2}}],[\"参数的\",{\"1\":{\"121\":2,\"122\":2}}],[\"参数个数或类型不一样\",{\"1\":{\"7\":1}}],[\"参数列表不一致\",{\"1\":{\"252\":1}}],[\"参数列表\",{\"1\":{\"252\":1}}],[\"参数列表与被重写方法的参数列表必须完全相同\",{\"1\":{\"6\":1}}],[\"参数列表和返回类型的方法\",{\"1\":{\"6\":1}}],[\"是单元素集合且无序不可重复\",{\"1\":{\"276\":1}}],[\"是单元素集合且有序可重复\",{\"1\":{\"276\":1}}],[\"是系统运行程序的基本单位\",{\"1\":{\"271\":1}}],[\"是弱引用\",{\"1\":{\"259\":1}}],[\"是软引用\",{\"1\":{\"259\":1}}],[\"是集合的工具包\",{\"1\":{\"258\":1}}],[\"是集合的上级接口包\",{\"1\":{\"258\":1}}],[\"是吧构成问题的事务分解成对象\",{\"1\":{\"248\":1}}],[\"是分析解决问题的步骤\",{\"1\":{\"248\":1}}],[\"是线程安全的\",{\"1\":{\"235\":1}}],[\"是并发gc\",{\"1\":{\"209\":1}}],[\"是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的\",{\"1\":{\"208\":1}}],[\"是硬盘和\",{\"1\":{\"201\":1}}],[\"是被所有线程共享的\",{\"1\":{\"197\":1,\"202\":1}}],[\"是否开启自注册\",{\"1\":{\"308\":1}}],[\"是否能够转换为右面的\",{\"1\":{\"250\":1}}],[\"是否是\",{\"1\":{\"250\":1}}],[\"是否为空\",{\"0\":{\"239\":1}}],[\"是否线程共享\",{\"1\":{\"197\":1}}],[\"是否加载过\",{\"1\":{\"191\":1}}],[\"是否存在数据\",{\"1\":{\"75\":1}}],[\"是否存在个\",{\"1\":{\"73\":1}}],[\"是否存在这个\",{\"1\":{\"73\":1}}],[\"是如何打破\",{\"1\":{\"190\":1}}],[\"是通过在实际的计算机上仿真模拟各种计算机功能来实现的\",{\"1\":{\"185\":1}}],[\"是一种用于计算设备的规范\",{\"1\":{\"185\":1}}],[\"是一个基于asm的字节码生成库\",{\"1\":{\"220\":1}}],[\"是一个\",{\"1\":{\"171\":1}}],[\"是不可执行的\",{\"1\":{\"151\":1}}],[\"是指该锁一次只能被一个线程所持有\",{\"1\":{\"147\":1}}],[\"是指在同一个线程在外层方法获取锁的时候\",{\"1\":{\"146\":1}}],[\"是指子类定义了一个与其父类中具有相同名称\",{\"1\":{\"6\":1}}],[\"是当前容量+1\",{\"1\":{\"52\":1}}],[\"是\",{\"1\":{\"47\":1,\"49\":1,\"52\":1,\"139\":2,\"185\":1,\"197\":3,\"202\":1,\"247\":1}}],[\"是jdk内置的一种\",{\"1\":{\"43\":1}}],[\"是在一个类里面\",{\"1\":{\"7\":1}}],[\"重启\",{\"1\":{\"312\":1}}],[\"重量级锁是将除了拥有锁的线程以外的线程都阻塞\",{\"1\":{\"144\":1}}],[\"重量级锁\",{\"0\":{\"144\":1}}],[\"重排序规则表\",{\"1\":{\"174\":1}}],[\"重排序\",{\"1\":{\"161\":1}}],[\"重排序分三种类型\",{\"1\":{\"92\":1}}],[\"重排序引起\",{\"0\":{\"92\":1}}],[\"重载和重写\",{\"0\":{\"252\":1}}],[\"重载规则\",{\"1\":{\"7\":1}}],[\"重载\",{\"0\":{\"7\":1},\"1\":{\"7\":1,\"252\":1}}],[\"重写的方法不能抛出新的强制性异常\",{\"1\":{\"6\":1}}],[\"重写的方法能够抛出任何非强制异常\",{\"1\":{\"6\":1}}],[\"重写规则\",{\"1\":{\"6\":1}}],[\"重写和重载\",{\"0\":{\"5\":1}}],[\"重写\",{\"0\":{\"6\":1},\"1\":{\"4\":1,\"6\":1,\"252\":1}}],[\"方法名称一致\",{\"1\":{\"252\":1}}],[\"方法名字相同\",{\"1\":{\"7\":1}}],[\"方法区中常量引用的对象\",{\"1\":{\"207\":1}}],[\"方法区中类静态属性实体引用的对象\",{\"1\":{\"207\":1}}],[\"方法区中还会存放运行时常最池信息\",{\"1\":{\"196\":1}}],[\"方法区\",{\"0\":{\"201\":1},\"1\":{\"197\":1}}],[\"方法出口等信息\",{\"1\":{\"197\":1,\"198\":1}}],[\"方法执行的内存模型\",{\"1\":{\"197\":1,\"198\":1}}],[\"方法执行一个无限循环\",{\"1\":{\"133\":1}}],[\"方法服务的\",{\"1\":{\"197\":1,\"199\":1}}],[\"方法不过是属于son的新成员罢了\",{\"1\":{\"151\":1}}],[\"方法是隐式的final\",{\"1\":{\"151\":1}}],[\"方法唤醒等待的线程\",{\"1\":{\"140\":1}}],[\"方法使线程等待\",{\"1\":{\"140\":1}}],[\"方法使线程进入限期等待或者无限期等待时\",{\"1\":{\"122\":1}}],[\"方法使线程进入限期等待状态时\",{\"1\":{\"122\":1}}],[\"方法来判断线程是否处于中断状态\",{\"1\":{\"133\":1}}],[\"方法会等待线程都执行完毕之后再关闭\",{\"1\":{\"134\":1}}],[\"方法会返回\",{\"1\":{\"133\":1}}],[\"方法会设置线程的中断标记\",{\"1\":{\"133\":1}}],[\"方法会休眠当前正在执行的线程\",{\"1\":{\"129\":1}}],[\"方法就无法使线程提前结束\",{\"1\":{\"133\":1}}],[\"方法将一个线程设置为守护线程\",{\"1\":{\"128\":1}}],[\"方法的\",{\"1\":{\"197\":1,\"199\":1}}],[\"方法的开始\",{\"1\":{\"97\":1,\"264\":1}}],[\"方法的调用先行发生于被中断线程的代码检测到中断事件的发生\",{\"1\":{\"97\":1,\"264\":1}}],[\"方法检测到是否有中断发生\",{\"1\":{\"97\":1,\"264\":1}}],[\"方法返回\",{\"1\":{\"97\":1,\"264\":1}}],[\"方法参数\",{\"1\":{\"24\":1}}],[\"方法调用先行发生于此线程的每一个动作\",{\"1\":{\"97\":1,\"264\":1}}],[\"方法调用\",{\"1\":{\"13\":1}}],[\"方法能够在同一个类中或者在一个子类中被重载\",{\"1\":{\"7\":1}}],[\"方法\",{\"1\":{\"6\":1,\"47\":1,\"121\":3,\"122\":5,\"134\":2,\"137\":1,\"168\":1,\"275\":1,\"277\":1,\"282\":1}}],[\"子类把父类中的方法进行重写\",{\"1\":{\"252\":1}}],[\"子类型\",{\"1\":{\"45\":1}}],[\"子类和父类不在同一个包中\",{\"1\":{\"6\":1}}],[\"子类和父类在同一个包中\",{\"1\":{\"6\":1}}],[\"子类对象必须能够替换掉所有父类对象\",{\"1\":{\"3\":1}}],[\"的内容\",{\"1\":{\"318\":2}}],[\"的位置直接执行\",{\"1\":{\"315\":1}}],[\"的可以添加环境\",{\"1\":{\"315\":1}}],[\"的异同\",{\"0\":{\"284\":1}}],[\"的长度为什么是\",{\"0\":{\"283\":1}}],[\"的安全检查来提升反射速度\",{\"1\":{\"275\":1}}],[\"的用法\",{\"0\":{\"265\":1}}],[\"的四种引用\",{\"0\":{\"259\":1}}],[\"的对象\",{\"1\":{\"250\":1}}],[\"的对象一定是线程安全的\",{\"1\":{\"102\":1}}],[\"的空间\",{\"1\":{\"208\":1}}],[\"的高效稳定运行\",{\"1\":{\"201\":1}}],[\"的高性能\",{\"1\":{\"88\":1}}],[\"的中间桥梁\",{\"1\":{\"201\":1}}],[\"的中断操作\",{\"0\":{\"134\":1}}],[\"的默认加载器就是\",{\"1\":{\"191\":1}}],[\"的类\",{\"1\":{\"191\":1}}],[\"的机制\",{\"1\":{\"190\":1}}],[\"的编译\",{\"0\":{\"186\":1}}],[\"的编译器重排序规则会禁止特定类型的编译器重排序\",{\"1\":{\"92\":1}}],[\"的主要内容如下图\",{\"1\":{\"185\":1}}],[\"的缩写\",{\"1\":{\"185\":1}}],[\"的实现原理\",{\"0\":{\"170\":1}}],[\"的静态方法\",{\"1\":{\"139\":1}}],[\"的区别\",{\"0\":{\"139\":1,\"256\":1,\"257\":1,\"274\":1}}],[\"的一部分\",{\"1\":{\"138\":1}}],[\"的操作\",{\"1\":{\"133\":1}}],[\"的调用声明了当前线程已经完成了生命周期中最重要的部分\",{\"1\":{\"130\":1}}],[\"的处理方式\",{\"1\":{\"115\":1}}],[\"的处理器重排序规则会要求\",{\"1\":{\"92\":1}}],[\"的正确性\",{\"1\":{\"112\":1}}],[\"的值更新为\",{\"1\":{\"110\":1}}],[\"的值等于\",{\"1\":{\"110\":1}}],[\"的值为\",{\"1\":{\"73\":2}}],[\"的存在\",{\"1\":{\"91\":1}}],[\"的哈希值\",{\"1\":{\"75\":1}}],[\"的时候才可能树化\",{\"1\":{\"74\":1}}],[\"的时候\",{\"1\":{\"74\":1}}],[\"的属性\",{\"1\":{\"74\":1}}],[\"的属性和方法\",{\"1\":{\"3\":1}}],[\"的元素\",{\"1\":{\"73\":1}}],[\"的\",{\"0\":{\"283\":1},\"1\":{\"73\":1,\"74\":2,\"127\":1,\"134\":1,\"259\":1,\"275\":1}}],[\"的不重复集合\",{\"1\":{\"73\":1}}],[\"的子类\",{\"1\":{\"55\":1}}],[\"的最大值为\",{\"1\":{\"74\":1}}],[\"的最大值\",{\"1\":{\"52\":1}}],[\"的所有功能且添加了部分自己独有的一些功能\",{\"1\":{\"49\":1}}],[\"的meta\",{\"1\":{\"43\":1}}],[\"的策略\",{\"1\":{\"16\":1}}],[\"的消费者\",{\"1\":{\"14\":1}}],[\"的生产者\",{\"1\":{\"14\":1}}],[\"的输入参数上使用通配符\",{\"1\":{\"14\":1}}],[\"的非\",{\"1\":{\"6\":1}}],[\"的方法\",{\"1\":{\"6\":1,\"139\":1}}],[\"的方法不能被重写\",{\"1\":{\"6\":2}}],[\"父类的成员方法只能被它的子类重写\",{\"1\":{\"6\":1}}],[\"父类引用指向子类对象称为\",{\"1\":{\"3\":1}}],[\"pip\",{\"1\":{\"322\":1}}],[\"pid\",{\"1\":{\"211\":1,\"214\":1}}],[\"pkg\",{\"1\":{\"311\":2}}],[\"pem\",{\"1\":{\"310\":1}}],[\"persistent\",{\"1\":{\"292\":1}}],[\"permission\",{\"1\":{\"191\":1}}],[\"per\",{\"1\":{\"115\":1}}],[\"pwd\",{\"1\":{\"308\":1}}],[\"phantomreference\",{\"1\":{\"259\":2}}],[\"phrof\",{\"1\":{\"211\":1}}],[\"pc\",{\"1\":{\"244\":3}}],[\"platform\",{\"1\":{\"234\":1}}],[\"paths\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"path\",{\"1\":{\"308\":1,\"316\":1,\"318\":1,\"324\":1}}],[\"pattern\",{\"1\":{\"216\":1}}],[\"password\",{\"1\":{\"308\":4}}],[\"passing\",{\"1\":{\"191\":1}}],[\"pa\",{\"1\":{\"244\":2}}],[\"param\",{\"1\":{\"232\":1,\"233\":1,\"234\":1,\"235\":1,\"236\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":2}}],[\"parallelgcthreads选项指定gc的线程数\",{\"1\":{\"209\":1}}],[\"parallel\",{\"1\":{\"209\":8}}],[\"parallel收集器更关注系统的吞吐量\",{\"1\":{\"209\":1}}],[\"parallel收集器\",{\"1\":{\"209\":1}}],[\"parallelism\",{\"1\":{\"92\":1}}],[\"parallelstream\",{\"1\":{\"47\":1}}],[\"parnew是serial的并行版本\",{\"1\":{\"209\":1}}],[\"parnew\",{\"1\":{\"209\":2}}],[\"parnew收集器其实就是serial收集器的多线程版本\",{\"1\":{\"209\":1}}],[\"parnew收集器\",{\"1\":{\"209\":1}}],[\"parent\",{\"1\":{\"191\":8,\"218\":7,\"318\":3}}],[\"parkuntil\",{\"1\":{\"122\":1}}],[\"parknanos\",{\"1\":{\"122\":1}}],[\"park\",{\"1\":{\"121\":1}}],[\"ports\",{\"1\":{\"316\":2,\"318\":2,\"324\":2}}],[\"port\",{\"1\":{\"308\":1,\"316\":1,\"318\":1,\"323\":1,\"324\":6}}],[\"po++\",{\"1\":{\"244\":1}}],[\"po\",{\"1\":{\"244\":1}}],[\"post\",{\"1\":{\"315\":1}}],[\"position\",{\"1\":{\"243\":3}}],[\"positions\",{\"1\":{\"243\":1}}],[\"positive\",{\"1\":{\"243\":1}}],[\"possible\",{\"1\":{\"191\":1}}],[\"point<string>\",{\"1\":{\"11\":2}}],[\"point<t>\",{\"1\":{\"11\":1}}],[\"png\",{\"1\":{\"92\":1,\"117\":1,\"144\":1,\"174\":2}}],[\"push\",{\"1\":{\"318\":4}}],[\"pub\",{\"1\":{\"313\":1}}],[\"public\",{\"0\":{\"231\":1,\"232\":1,\"233\":1,\"234\":1,\"235\":1,\"236\":1},\"1\":{\"6\":2,\"11\":10,\"12\":6,\"14\":11,\"191\":2,\"218\":8,\"221\":7,\"231\":1,\"232\":1,\"233\":1,\"234\":1,\"235\":1,\"236\":1,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1,\"318\":19}}],[\"pull\",{\"1\":{\"296\":1}}],[\"pure\",{\"1\":{\"116\":1}}],[\"putifabsent\",{\"1\":{\"73\":1}}],[\"putall\",{\"1\":{\"73\":1}}],[\"put\",{\"1\":{\"73\":1,\"75\":1}}],[\"p\",{\"1\":{\"11\":3,\"295\":1,\"296\":2,\"318\":1}}],[\"prf\",{\"1\":{\"259\":1}}],[\"pre>\",{\"1\":{\"244\":1}}],[\"pre><\",{\"1\":{\"243\":2}}],[\"prefix\",{\"0\":{\"244\":1},\"1\":{\"244\":8}}],[\"preferred\",{\"1\":{\"236\":1}}],[\"precedes\",{\"1\":{\"243\":3}}],[\"prepare\",{\"0\":{\"194\":1},\"1\":{\"310\":2}}],[\"preblockspin来更改\",{\"1\":{\"143\":1}}],[\"predicate<\",{\"1\":{\"47\":1}}],[\"project\",{\"1\":{\"308\":1,\"318\":4,\"323\":1,\"324\":1}}],[\"protocol\",{\"1\":{\"308\":1}}],[\"protected\",{\"1\":{\"6\":2}}],[\"produces\",{\"1\":{\"242\":2}}],[\"provided\",{\"1\":{\"236\":1}}],[\"provider\",{\"1\":{\"43\":1}}],[\"process\",{\"1\":{\"234\":1}}],[\"processing\",{\"1\":{\"31\":1}}],[\"proxy类重新生成一个新的类\",{\"1\":{\"219\":1}}],[\"proxytest\",{\"1\":{\"218\":1}}],[\"proxyhandler\",{\"1\":{\"218\":4}}],[\"proxy和invocationhandler\",{\"1\":{\"217\":1}}],[\"proxy\",{\"1\":{\"216\":1,\"218\":2,\"221\":2}}],[\"privilegedjavasegetresource\",{\"1\":{\"191\":1}}],[\"privilegedaction<url>\",{\"1\":{\"191\":1}}],[\"privilegedaction<class<\",{\"1\":{\"191\":1}}],[\"privilegedgetclassloader\",{\"1\":{\"191\":1}}],[\"privilegedfindclassbyname\",{\"1\":{\"191\":1}}],[\"private\",{\"1\":{\"3\":1,\"6\":1,\"9\":4,\"11\":3,\"12\":1,\"14\":2,\"52\":2,\"151\":1,\"218\":1,\"221\":1,\"229\":3,\"310\":1}}],[\"print\",{\"1\":{\"11\":2,\"14\":1}}],[\"println\",{\"1\":{\"9\":4,\"11\":1,\"12\":1,\"218\":3,\"221\":3}}],[\"及更高版本可以不同\",{\"1\":{\"6\":1}}],[\"及更早版本返回类型要一样\",{\"1\":{\"6\":1}}],[\"即使用时通过中介使用\",{\"1\":{\"216\":1}}],[\"即使整个系统不可用\",{\"1\":{\"2\":1}}],[\"即时编译后的代码等数据\",{\"1\":{\"197\":1,\"201\":1}}],[\"即是否有着合法的操作数\",{\"1\":{\"193\":1}}],[\"即禁止final域写重排序到构造方法之外\",{\"1\":{\"161\":1}}],[\"即能看下arrays\",{\"1\":{\"160\":1}}],[\"即这个类是不能有子类的\",{\"1\":{\"150\":1}}],[\"即链表元素个数大于\",{\"1\":{\"74\":1}}],[\"即父类\",{\"1\":{\"17\":1}}],[\"即删除<>及其包围的部分\",{\"1\":{\"17\":1}}],[\"即java在语法上支持泛型\",{\"1\":{\"16\":1}}],[\"即\",{\"1\":{\"11\":1,\"26\":2}}],[\"即外壳不变\",{\"1\":{\"6\":1}}],[\"覆盖\",{\"1\":{\"4\":1}}],[\"1或localhost\",{\"1\":{\"308\":1}}],[\"192\",{\"1\":{\"323\":1}}],[\"190\",{\"1\":{\"305\":1,\"316\":2,\"318\":11}}],[\"19\",{\"0\":{\"265\":1}}],[\"18\",{\"0\":{\"264\":1}}],[\"172\",{\"1\":{\"305\":1,\"316\":2,\"318\":11}}],[\"17\",{\"0\":{\"263\":1}}],[\"15\",{\"0\":{\"261\":1}}],[\"14\",{\"0\":{\"260\":1}}],[\"13\",{\"0\":{\"259\":1}}],[\"11\",{\"0\":{\"257\":1}}],[\"1234\",{\"1\":{\"308\":2}}],[\"12\",{\"0\":{\"258\":1},\"1\":{\"316\":1}}],[\"127\",{\"1\":{\"251\":1,\"267\":2}}],[\"128\",{\"1\":{\"251\":1}}],[\"1>>>1\",{\"1\":{\"244\":1}}],[\"1需要三条\",{\"1\":{\"91\":1}}],[\"168\",{\"1\":{\"323\":1}}],[\"16\",{\"0\":{\"262\":1},\"1\":{\"74\":1,\"75\":1}}],[\"10\",{\"0\":{\"256\":1},\"1\":{\"15\":6,\"52\":1,\"62\":1,\"202\":3,\"318\":1}}],[\"1\",{\"0\":{\"229\":1,\"247\":1,\"266\":1,\"290\":1,\"294\":1,\"298\":1,\"322\":1},\"1\":{\"3\":1,\"14\":1,\"16\":1,\"25\":1,\"26\":2,\"52\":4,\"74\":3,\"91\":1,\"92\":1,\"127\":1,\"160\":1,\"191\":3,\"193\":1,\"202\":3,\"209\":1,\"217\":1,\"229\":1,\"234\":1,\"236\":1,\"239\":1,\"240\":2,\"249\":2,\"256\":1,\"259\":3,\"306\":1,\"307\":1,\"308\":1,\"309\":1,\"316\":1,\"323\":2}}],[\"非可重入锁\",{\"0\":{\"146\":1}}],[\"非公平锁的优点是可以减少唤起线程的开销\",{\"1\":{\"145\":1}}],[\"非公平锁是多个线程加锁时直接尝试获取锁\",{\"1\":{\"145\":1}}],[\"非公平锁\",{\"0\":{\"145\":1}}],[\"非阻塞同步\",{\"0\":{\"109\":1}}],[\"非法创建\",{\"1\":{\"15\":2}}],[\"非\",{\"1\":{\"3\":1}}],[\"和搭建部分常用服务\",{\"1\":{\"288\":1}}],[\"和垃圾收集器有关系\",{\"1\":{\"277\":1}}],[\"和上个方法对比\",{\"1\":{\"236\":1}}],[\"和其他\",{\"1\":{\"190\":1}}],[\"和所有的\",{\"1\":{\"190\":1}}],[\"和新值\",{\"1\":{\"110\":1}}],[\"和创建以此实现数据的删除\",{\"1\":{\"53\":1}}],[\"和\",{\"0\":{\"139\":1,\"253\":1,\"256\":1,\"257\":1,\"267\":1,\"269\":1,\"274\":1,\"278\":1,\"281\":1,\"284\":1},\"1\":{\"3\":1,\"6\":2,\"47\":2,\"48\":1,\"58\":2,\"92\":1,\"93\":1,\"105\":2,\"111\":1,\"119\":1,\"122\":1,\"124\":1,\"208\":1,\"282\":1}}],[\"例如报错或者自动重试\",{\"1\":{\"142\":1}}],[\"例如不依赖存储在堆上的数据和公用的系统资源\",{\"1\":{\"116\":1}}],[\"例如扩容规则\",{\"1\":{\"61\":1}}],[\"例如使用反射注入实例\",{\"1\":{\"24\":1}}],[\"例如动态生成代码\",{\"1\":{\"24\":1}}],[\"例如\",{\"1\":{\"3\":1,\"6\":1,\"74\":1,\"262\":1}}],[\"auth\",{\"1\":{\"308\":3}}],[\"adminserver\",{\"1\":{\"310\":1}}],[\"admin\",{\"1\":{\"308\":4}}],[\"admiral\",{\"1\":{\"308\":1}}],[\"addall\",{\"1\":{\"47\":1}}],[\"add\",{\"1\":{\"9\":4,\"47\":1,\"293\":1,\"318\":1}}],[\"amd64\",{\"1\":{\"303\":2}}],[\"always\",{\"1\":{\"318\":1}}],[\"alpine\",{\"1\":{\"318\":1}}],[\"alto\",{\"1\":{\"310\":1}}],[\"aliyuncs\",{\"1\":{\"295\":1}}],[\"aliyun\",{\"1\":{\"293\":1,\"306\":1}}],[\"allocates\",{\"1\":{\"233\":1,\"235\":1,\"236\":1}}],[\"a+b\",{\"1\":{\"267\":1}}],[\"a+=b\",{\"0\":{\"267\":1}}],[\"a=a+b\",{\"0\":{\"267\":1}}],[\"abc\",{\"1\":{\"308\":1}}],[\"abstractmap\",{\"1\":{\"257\":1}}],[\"aba\",{\"1\":{\"112\":2}}],[\"against\",{\"1\":{\"241\":1,\"242\":1}}],[\"a>\",{\"1\":{\"238\":1,\"240\":1}}],[\"affect\",{\"1\":{\"233\":1,\"235\":1,\"236\":1}}],[\"as\",{\"1\":{\"232\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1}}],[\"ask\",{\"1\":{\"191\":1}}],[\"apache\",{\"1\":{\"313\":2}}],[\"apply\",{\"1\":{\"318\":4}}],[\"applying\",{\"1\":{\"242\":2}}],[\"apps\",{\"1\":{\"316\":1,\"318\":1,\"324\":1}}],[\"app\",{\"1\":{\"310\":1,\"316\":6,\"318\":6,\"323\":5,\"324\":25}}],[\"appclassloader\",{\"1\":{\"191\":5}}],[\"apiversion\",{\"1\":{\"316\":3,\"318\":3,\"324\":3}}],[\"api\",{\"1\":{\"105\":1,\"274\":1}}],[\"at\",{\"1\":{\"191\":1,\"240\":5,\"242\":1,\"243\":5,\"244\":2}}],[\"atomicstampedreference\",{\"1\":{\"112\":1}}],[\"atomicinteger\",{\"1\":{\"111\":1}}],[\"ace\",{\"1\":{\"191\":8}}],[\"accesscontrolexception\",{\"1\":{\"191\":2}}],[\"accesscontroller\",{\"1\":{\"191\":3}}],[\"await\",{\"0\":{\"140\":1},\"1\":{\"140\":2}}],[\"anapsix\",{\"1\":{\"318\":1}}],[\"analyzer\",{\"1\":{\"212\":1}}],[\"another\",{\"1\":{\"242\":1}}],[\"anotherstring\",{\"0\":{\"242\":1,\"243\":1},\"1\":{\"241\":3,\"242\":6,\"243\":6}}],[\"anobject\",{\"1\":{\"241\":5}}],[\"an\",{\"1\":{\"231\":1,\"232\":1,\"240\":1,\"242\":1}}],[\"and\",{\"1\":{\"110\":1,\"234\":1,\"236\":1,\"239\":1,\"240\":1,\"241\":2,\"242\":3,\"243\":1,\"310\":1}}],[\"annotation\",{\"1\":{\"31\":1}}],[\"animal\",{\"1\":{\"3\":5}}],[\"archive\",{\"1\":{\"313\":1}}],[\"argument\",{\"1\":{\"232\":2,\"233\":1,\"235\":1,\"236\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":6,\"244\":1}}],[\"args\",{\"1\":{\"11\":2,\"14\":2,\"218\":3,\"221\":3}}],[\"are\",{\"1\":{\"231\":1,\"232\":1,\"233\":1,\"234\":1,\"235\":1,\"236\":1,\"242\":5,\"243\":3}}],[\"arrays\",{\"1\":{\"233\":1,\"235\":1,\"236\":1}}],[\"arrayblockingqueue\",{\"0\":{\"82\":1}}],[\"arraycopy进行数组的\",{\"1\":{\"53\":1}}],[\"array\",{\"1\":{\"52\":3,\"233\":3,\"234\":2,\"240\":1}}],[\"arraylist\",{\"0\":{\"49\":1,\"256\":1,\"278\":1,\"279\":1},\"1\":{\"15\":1,\"48\":2,\"49\":1,\"50\":1,\"61\":1,\"105\":1,\"256\":1}}],[\"arraylist<\",{\"1\":{\"15\":3}}],[\"arraylist<string>\",{\"1\":{\"15\":2}}],[\"arsg\",{\"1\":{\"12\":1}}],[\"a\",{\"1\":{\"3\":2,\"9\":16,\"97\":2,\"110\":2,\"112\":2,\"191\":1,\"231\":1,\"232\":3,\"233\":1,\"234\":2,\"235\":2,\"236\":4,\"240\":1,\"241\":2,\"243\":5,\"244\":1,\"264\":2,\"267\":1,\"312\":1}}],[\"继承自\",{\"1\":{\"257\":2}}],[\"继承整个\",{\"1\":{\"125\":1}}],[\"继承了\",{\"1\":{\"48\":1}}],[\"继承应该遵循里氏替换原则\",{\"1\":{\"3\":1}}],[\"继承实现了\",{\"1\":{\"3\":1}}],[\"继承\",{\"0\":{\"3\":1,\"125\":1},\"1\":{\"4\":1,\"124\":1,\"248\":1}}],[\"但若是封装对象这可以改变引用地址内的内容\",{\"1\":{\"264\":1}}],[\"但实际\",{\"1\":{\"257\":1}}],[\"但因为采用的是继承\",{\"1\":{\"226\":1}}],[\"但后续步骤不是直接对可回收对象进行清理\",{\"1\":{\"208\":1}}],[\"但如果此时锁刚好可用\",{\"1\":{\"145\":1}}],[\"但它要占用处理器时间\",{\"1\":{\"143\":1}}],[\"但是实现方式不同\",{\"1\":{\"274\":1}}],[\"但是线程是一个比进程更小的执行单位\",{\"1\":{\"271\":1}}],[\"但是删除的效率较高\",{\"1\":{\"256\":1}}],[\"但是性能上来说\",{\"1\":{\"248\":1}}],[\"但是封装类型\",{\"1\":{\"241\":1}}],[\"但是jdk动态代理和cglib动态代理的适用场景还是不一样的哈\",{\"1\":{\"227\":1}}],[\"但是并没有教科书上的10倍差距\",{\"1\":{\"227\":1}}],[\"但是如果有程序员通过非编译的手段生成了类文件\",{\"1\":{\"193\":1}}],[\"但是如果调用的是\",{\"1\":{\"134\":1}}],[\"但是由于操作系统可以对指令进行重排序\",{\"1\":{\"165\":1}}],[\"但是有一些处理器会重排序\",{\"1\":{\"157\":1}}],[\"但是father\",{\"1\":{\"151\":1}}],[\"但是这并不是一种覆盖\",{\"1\":{\"151\":1}}],[\"但是这些独立的模块却有可能是可用的\",{\"1\":{\"2\":1}}],[\"但是调用\",{\"1\":{\"133\":1}}],[\"但是不能中断\",{\"1\":{\"132\":1}}],[\"但是可以实现多个接口\",{\"1\":{\"125\":1}}],[\"但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用\",{\"1\":{\"105\":1}}],[\"但是对于一些特定顺序的连续调用\",{\"1\":{\"104\":1}}],[\"但是只能移动1\",{\"1\":{\"74\":1}}],[\"但是object类型不能存储int值\",{\"1\":{\"20\":1}}],[\"但是在编译阶段会进行所谓的\",{\"1\":{\"16\":1}}],[\"但是会有警告\",{\"1\":{\"15\":2}}],[\"但是\",{\"0\":{\"262\":1},\"1\":{\"6\":1}}],[\"但是能够被再次声明\",{\"1\":{\"6\":1}}],[\"但是必须是父类返回值的派生类\",{\"1\":{\"6\":1}}],[\"但可以通过对象对外提供的接口来访问该对象\",{\"1\":{\"2\":1}}],[\"降低了构建大型系统的风险\",{\"1\":{\"2\":1}}],[\"减轻维护的负担\",{\"1\":{\"2\":1}}],[\"减少耦合\",{\"1\":{\"2\":1}}],[\"理解和修改\",{\"1\":{\"2\":1}}],[\"使\",{\"1\":{\"185\":1}}],[\"使一个线程睡眠\",{\"1\":{\"122\":1}}],[\"使得线程等待某个条件满足\",{\"1\":{\"138\":1}}],[\"使得缓存能够得到更加合理地利用\",{\"1\":{\"88\":1}}],[\"使得代码更加灵活\",{\"1\":{\"9\":1}}],[\"使用命令即可登录rancher\",{\"1\":{\"305\":1}}],[\"使用阿里的容器镜像服务进行加速\",{\"1\":{\"295\":1}}],[\"使用阿里加速\",{\"0\":{\"295\":1}}],[\"使用反射性能较低\",{\"1\":{\"275\":1}}],[\"使用字符组进行缓存数据\",{\"1\":{\"229\":1}}],[\"使用注意\",{\"0\":{\"225\":1}}],[\"使用多线程和\",{\"1\":{\"209\":1}}],[\"使用的规则就是\",{\"1\":{\"14\":1}}],[\"使用原则\",{\"1\":{\"14\":1}}],[\"使用\",{\"0\":{\"305\":1},\"1\":{\"2\":1,\"14\":1,\"26\":1,\"128\":1,\"138\":1,\"209\":2,\"229\":1,\"272\":1}}],[\"使其构成一个不可分割的独立实体\",{\"1\":{\"2\":1}}],[\"优先级大于\",{\"1\":{\"74\":1}}],[\"优化工具\",{\"0\":{\"214\":1},\"1\":{\"214\":1}}],[\"优化\",{\"0\":{\"210\":1},\"1\":{\"2\":1,\"213\":1}}],[\"优点\",{\"1\":{\"2\":1,\"48\":1,\"208\":1,\"275\":1}}],[\"测试结果大致是这样的\",{\"1\":{\"227\":1}}],[\"测试类\",{\"1\":{\"218\":1,\"221\":1}}],[\"测试\",{\"0\":{\"316\":1},\"1\":{\"2\":1,\"306\":1}}],[\"尽可能地隐藏内部的细节\",{\"1\":{\"2\":1}}],[\"封装类型\",{\"1\":{\"249\":7}}],[\"封装类\",{\"1\":{\"249\":1}}],[\"封装了部分方法\",{\"1\":{\"48\":1}}],[\"封装\",{\"0\":{\"2\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
