import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as n,b as s}from"./app-BLeBrAfL.js";const c={},t=s(`<p>容器化在现在使用非常普遍，对于个人环境搭建和使用是非常方便的，而且对于生产上的部署也日益完善，相信在使用过程中所遇到的问题，能都够在网上获得相应的答案。本人虽然也学习并使用了很长的时间，但是却从未进行完整的整理，没有进行对自己Docker 的相关知识的总结和梳理，本篇文章是本人结合网上文章和个人理解进行总结得到的。</p><h2 id="docker环境搭建" tabindex="-1"><a class="header-anchor" href="#docker环境搭建"><span>Docker环境搭建</span></a></h2><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">sudo</span> yum <span class="token function">install</span> <span class="token parameter variable">-y</span> yum-utils
<span class="token function">sudo</span> yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
<span class="token function">sudo</span> yum update <span class="token parameter variable">-y</span>
<span class="token function">sudo</span> yum <span class="token function">install</span> docker-ce docker-ce-cli containerd.io
<span class="token function">sudo</span> systemctl start <span class="token function">docker</span>
<span class="token function">sudo</span> systenctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="docker命令使用" tabindex="-1"><a class="header-anchor" href="#docker命令使用"><span>Docker命令使用</span></a></h2><h4 id="启动容器" tabindex="-1"><a class="header-anchor" href="#启动容器"><span>启动容器</span></a></h4><h4 id="停止容器" tabindex="-1"><a class="header-anchor" href="#停止容器"><span>停止容器</span></a></h4><h4 id="删除容器" tabindex="-1"><a class="header-anchor" href="#删除容器"><span>删除容器</span></a></h4><h4 id="查看容器" tabindex="-1"><a class="header-anchor" href="#查看容器"><span>查看容器</span></a></h4><h4 id="构建镜像" tabindex="-1"><a class="header-anchor" href="#构建镜像"><span>构建镜像</span></a></h4><h4 id="离线下载镜像" tabindex="-1"><a class="header-anchor" href="#离线下载镜像"><span>离线下载镜像</span></a></h4><h4 id="删除镜像" tabindex="-1"><a class="header-anchor" href="#删除镜像"><span>删除镜像</span></a></h4><h4 id="镜像打标签" tabindex="-1"><a class="header-anchor" href="#镜像打标签"><span>镜像打标签</span></a></h4><h4 id="镜像优化" tabindex="-1"><a class="header-anchor" href="#镜像优化"><span>镜像优化</span></a></h4><h2 id="docker-原理" tabindex="-1"><a class="header-anchor" href="#docker-原理"><span>Docker 原理</span></a></h2><p>容器化本质还是使用了 <code>Linux</code>的一些功能进行实现的，通过<code>namespace</code> 实现内核资源的隔离，通过<code>cgroup</code>来实现物力资源的隔离，实现容器化的资源限制和统计，通过<code>UnionFS</code>来实现文件资源你的隔离。</p><p>以下的整个解析将结合一个<code>nginx</code> 容器进行描述，启动命令如下：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">--name</span> nginx nginx
<span class="token comment"># docker ps 查看该容器的一些数据</span>
<span class="token comment"># CONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS       PORTS                               NAMES</span>
<span class="token comment"># c0f373db9d49   nginx     &quot;/docker-entrypoint.…&quot;   4 hours ago   Up 4 hours   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   nginx</span>
<span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> c0f373db9d49 <span class="token comment"># 查看容器在主机上的 pid  49798</span>
<span class="token comment">#root       49798  0.0  0.1 720556 15496 ?        Sl   11:49   0:00 ......</span>
<span class="token comment">#root       53611  0.0  0.0  12136  1144 pts/2    S+   15:48   0:00 ......</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="cgroups-控制组" tabindex="-1"><a class="header-anchor" href="#cgroups-控制组"><span>cgroups 控制组</span></a></h3><h4 id="cgroup-介绍" tabindex="-1"><a class="header-anchor" href="#cgroup-介绍"><span>cgroup 介绍</span></a></h4><p><a href="42848229fcb6046c7ae55c13545a69db">sparkdev: cgroups</a></p><p><code>cgroup</code>是对不同进程组进行资源控制和统计的技术，可以为每个<code>group</code> 的 CPU、内存、磁盘 IO、网络流量进行限制和统计，主要的应用在资源隔离和管理、资源监控和限制。Linux 中可以通过<code>/sys/fs/cgroup/</code> 进行查看<code>cgroup</code>的配置。<code>/sys/fs/cgroup/</code>不同的文件代表不同的配置，解释如下:</p><table><thead><tr><th>文件名称</th><th>解释</th></tr></thead><tbody><tr><td>blkio</td><td>对块设备的 IO 进行限制。</td></tr><tr><td>cpu</td><td>限制 CPU 时间片的分配，与 cpuacct 挂载在同一目录。</td></tr><tr><td>cpuacct</td><td>生成 cgroup 中的任务占用 CPU 资源的报告，与 cpu 挂载在同一目录。</td></tr><tr><td>cpuset</td><td>给 cgroup 中的任务分配独立的 CPU(多处理器系统) 和内存节点。</td></tr><tr><td>devices</td><td>允许或禁止 cgroup 中的任务访问设备。</td></tr><tr><td>freezer</td><td>暂停/恢复 cgroup 中的任务。</td></tr><tr><td>hugetlb</td><td>限制使用的内存页数量。</td></tr><tr><td>memory</td><td>对 cgroup 中的任务的可用内存进行限制，并自动生成资源占用报告。</td></tr><tr><td>net_cls</td><td>使用等级识别符（classid）标记网络数据包，这让 Linux 流量控制器（tc 指令）可以识别来自特定 cgroup 任务的数据包，并进行网络限制。</td></tr><tr><td>net_prio</td><td>允许基于 cgroup 设置网络流量(netowork traffic)的优先级。</td></tr><tr><td>perf_event</td><td>允许使用 perf 工具来监控 cgroup。</td></tr><tr><td>pids</td><td>限制任务的数量。</td></tr></tbody></table><h4 id="docker-如何使用的-cgroup" tabindex="-1"><a class="header-anchor" href="#docker-如何使用的-cgroup"><span>docker 如何使用的 cgroup</span></a></h4><p>通过查看<code>/sys/fs/cgroup/</code> 发现存在<code>docker/c0f373db9d49879e669f79989c81a6b5ec904e660732b4f0e4bebbb311850475</code> 的目录，在容器停止是该目录不存在，当容器启动时自动创建对应的数据，以此可以认为当容器启动时是通过初始化 cgroup 的部分文件实现来使用 cgroup 进行资源隔离的。以下通过部分文件验证其内容就是容器对应的状态的数据：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> stats
<span class="token comment">#CONTAINER ID   NAME      CPU %     MEM USAGE / LIMIT     MEM %     NET I/O     BLOCK I/O   PIDS</span>
<span class="token comment">#c0f373db9d49   nginx     0.00%     3.988MiB / 7.586GiB   0.05%     836B / 0B   0B / 0B     5</span>
<span class="token comment"># 可以看到当前的内存使用是 3.988M</span>
<span class="token function">cat</span> /sys/fs/cgroup/memory/docker/c0f373db9d49879e669f79989c81a6b5ec904e660732b4f0e4bebbb311850475/memory.usage_in_bytes
<span class="token function">cat</span> /sys/fs/cgroup/memory/docker/c0f373db9d49879e669f79989c81a6b5ec904e660732b4f0e4bebbb311850475/memory.stat
<span class="token comment"># (第一个值 - 第二个值)/1024/1024 = 4182016/1024/1024 = 3.98828125 约为 3.988M</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过以上内容可以看出在启动容器的时候，会创建部分文件来使用 cgroup ，从而达到资源控制和统计的作用。</p><h3 id="namespace-命名空间" tabindex="-1"><a class="header-anchor" href="#namespace-命名空间"><span>namespace 命名空间</span></a></h3><p>namespace 是 Linux 内核用来隔离内核资源的方式。通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。</p><p>namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响</p><h3 id="unionfs-联合文件系统" tabindex="-1"><a class="header-anchor" href="#unionfs-联合文件系统"><span>unionFS 联合文件系统</span></a></h3><h2 id="docker-存储" tabindex="-1"><a class="header-anchor" href="#docker-存储"><span>Docker 存储</span></a></h2><h2 id="docker-持久化" tabindex="-1"><a class="header-anchor" href="#docker-持久化"><span>Docker 持久化</span></a></h2><h2 id="docker-网络" tabindex="-1"><a class="header-anchor" href="#docker-网络"><span>Docker 网络</span></a></h2>`,33),o=[t];function r(d,i){return a(),n("div",null,o)}const u=e(c,[["render",r],["__file","Docker.html.vue"]]),h=JSON.parse('{"path":"/%E8%BF%90%E7%BB%B4/docker/Docker.html","title":"Docker","lang":"zh-CN","frontmatter":{"title":"Docker","order":2,"description":"容器化在现在使用非常普遍，对于个人环境搭建和使用是非常方便的，而且对于生产上的部署也日益完善，相信在使用过程中所遇到的问题，能都够在网上获得相应的答案。本人虽然也学习并使用了很长的时间，但是却从未进行完整的整理，没有进行对自己Docker 的相关知识的总结和梳理，本篇文章是本人结合网上文章和个人理解进行总结得到的。 Docker环境搭建 Docker命...","head":[["meta",{"property":"og:url","content":"https://961099916.github.io/%E8%BF%90%E7%BB%B4/docker/Docker.html"}],["meta",{"property":"og:site_name","content":"九夏的博客"}],["meta",{"property":"og:title","content":"Docker"}],["meta",{"property":"og:description","content":"容器化在现在使用非常普遍，对于个人环境搭建和使用是非常方便的，而且对于生产上的部署也日益完善，相信在使用过程中所遇到的问题，能都够在网上获得相应的答案。本人虽然也学习并使用了很长的时间，但是却从未进行完整的整理，没有进行对自己Docker 的相关知识的总结和梳理，本篇文章是本人结合网上文章和个人理解进行总结得到的。 Docker环境搭建 Docker命..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-21T16:16:31.000Z"}],["meta",{"property":"article:author","content":"九夏"}],["meta",{"property":"article:modified_time","content":"2024-06-21T16:16:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Docker\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-21T16:16:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"九夏\\",\\"url\\":\\"https://blog.jiuxialb.top/\\"}]}"]]},"headers":[{"level":2,"title":"Docker环境搭建","slug":"docker环境搭建","link":"#docker环境搭建","children":[]},{"level":2,"title":"Docker命令使用","slug":"docker命令使用","link":"#docker命令使用","children":[]},{"level":2,"title":"Docker 原理","slug":"docker-原理","link":"#docker-原理","children":[{"level":3,"title":"cgroups 控制组","slug":"cgroups-控制组","link":"#cgroups-控制组","children":[]},{"level":3,"title":"namespace 命名空间","slug":"namespace-命名空间","link":"#namespace-命名空间","children":[]},{"level":3,"title":"unionFS 联合文件系统","slug":"unionfs-联合文件系统","link":"#unionfs-联合文件系统","children":[]}]},{"level":2,"title":"Docker 存储","slug":"docker-存储","link":"#docker-存储","children":[]},{"level":2,"title":"Docker 持久化","slug":"docker-持久化","link":"#docker-持久化","children":[]},{"level":2,"title":"Docker 网络","slug":"docker-网络","link":"#docker-网络","children":[]}],"git":{"createdTime":1716018035000,"updatedTime":1718986591000,"contributors":[{"name":"zhangjiahao","email":"961099916@qq.com","commits":1}]},"readingTime":{"minutes":3.93,"words":1179},"filePathRelative":"运维/docker/Docker.md","localizedDate":"2024年5月18日","excerpt":"<p>容器化在现在使用非常普遍，对于个人环境搭建和使用是非常方便的，而且对于生产上的部署也日益完善，相信在使用过程中所遇到的问题，能都够在网上获得相应的答案。本人虽然也学习并使用了很长的时间，但是却从未进行完整的整理，没有进行对自己Docker 的相关知识的总结和梳理，本篇文章是本人结合网上文章和个人理解进行总结得到的。</p>\\n<h2>Docker环境搭建</h2>\\n<div class=\\"language-bash\\" data-ext=\\"sh\\" data-title=\\"sh\\"><pre class=\\"language-bash\\"><code><span class=\\"token function\\">sudo</span> yum <span class=\\"token function\\">install</span> <span class=\\"token parameter variable\\">-y</span> yum-utils\\n<span class=\\"token function\\">sudo</span> yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\\n<span class=\\"token function\\">sudo</span> yum update <span class=\\"token parameter variable\\">-y</span>\\n<span class=\\"token function\\">sudo</span> yum <span class=\\"token function\\">install</span> docker-ce docker-ce-cli containerd.io\\n<span class=\\"token function\\">sudo</span> systemctl start <span class=\\"token function\\">docker</span>\\n<span class=\\"token function\\">sudo</span> systenctl <span class=\\"token builtin class-name\\">enable</span> <span class=\\"token function\\">docker</span>\\n</code></pre></div>","autoDesc":true}');export{u as comp,h as data};
