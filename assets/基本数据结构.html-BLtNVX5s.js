import{_ as l,o as i,c as e,e as a}from"./app-Cu8baIzD.js";const n={},t=a('<p>常见的数据结构，包含有数组、链表、栈、队列、树、散列表、堆、图。</p><hr><h2 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h2><ul><li>存储空间是连续。可以通过下表进行快速访问</li></ul><hr><ul><li>优点： <ul><li>按照索引查询速度较快</li><li>按照索引遍历速度较快</li></ul></li><li>缺点： <ul><li>数组固定大小，扩容较麻烦</li><li>数组只能存在一种数据结构</li><li>增删改查速度较慢</li></ul></li></ul><hr><ul><li>使用场景： <ul><li>数据量较大，频繁的遍历的。</li></ul></li></ul><hr><h2 id="链表" tabindex="-1"><a class="header-anchor" href="#链表"><span>链表</span></a></h2><ul><li>存储空间不连续，通过指针进行访问下一个%%%%存储空间</li></ul><hr><ul><li>优点： <ul><li>可以随意添加数据，添加数据较简单</li><li>增删改查速度较快，只需要修改指针地址即可</li></ul></li><li>缺点： <ul><li>含有大量的指针域，占用较多的空间。</li><li>遍历或者查找的速度较慢，需要通过指针进行遍历。</li></ul></li></ul><hr><ul><li>使用场景： <ul><li>数据量小，大量进行增删改查。</li></ul></li></ul><hr><h2 id="栈" tabindex="-1"><a class="header-anchor" href="#栈"><span>栈</span></a></h2><ul><li>是一种特殊的线性表，只能操作其中个的一段，可以入栈和出栈。特点为先入后出（LIFO）。</li></ul><hr><h2 id="队列" tabindex="-1"><a class="header-anchor" href="#队列"><span>队列</span></a></h2><ul><li>队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出（FIFO）。</li></ul><hr><ul><li>使用场景： <ul><li>因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。</li></ul></li></ul><hr><h2 id="树" tabindex="-1"><a class="header-anchor" href="#树"><span>树</span></a></h2><ul><li>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</li></ul><hr><ul><li>具有特点： <ul><li>每一个节点都有零个或者多个子节点。</li><li>没有父节点的节点成为根节点。</li><li>每一个非根节点都有一个父节点。</li><li>除了根节点以外，每个子节点都可以分为多个不相交的子树。</li></ul></li></ul><hr><h3 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树"><span>二叉树</span></a></h3><ul><li>每个父节点只有两个子节点的树为二叉树。</li></ul><h3 id="平衡二叉树" tabindex="-1"><a class="header-anchor" href="#平衡二叉树"><span>平衡二叉树</span></a></h3><ul><li>当按照某个规则（左子节点小于父节点，右子节点大于父节点构建），如果一些有序的数据存储可能会导致退化为链表，大致查询的速度就变得特别慢，所以提出了平衡二叉树，在插入数据的时候会进行平衡，具有一下特性：</li><li>一棵空树或它的左右两个子树的高度差的绝对值不超过1</li><li>右两个子树都是一棵平衡二叉树</li></ul><hr><h3 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树"><span>红黑树</span></a></h3><ul><li>也是一种平衡二叉树，但是要去并没有那么严格，但也具有一下性质： <ul><li>每个节点非红即黑</li><li>根节点是黑的;</li><li>每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</li><li>如果一个节点是红的，那么它的两儿子都是黑的;</li><li>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</li></ul></li></ul><hr><h3 id="b-树" tabindex="-1"><a class="header-anchor" href="#b-树"><span>B 树</span></a></h3><ul><li>是一种多路搜索树（并不是二叉的），具有一下性质： <ul><li>定义任意非叶子结点最多只有M个儿子；且M&gt;2；</li><li>根结点的儿子数为[2, M]；</li><li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li><li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</li><li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li><li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li><li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li><li>所有叶子结点位于同一层；</li></ul></li></ul><hr><h3 id="b-树-1" tabindex="-1"><a class="header-anchor" href="#b-树-1"><span>B+树</span></a></h3><ul><li>相对于 B 树，B+树所有的叶子结点在同一层，但是每个节点间通过链表相互连接，所以可以进行范围行的查询。</li></ul><hr><h2 id="散列表" tabindex="-1"><a class="header-anchor" href="#散列表"><span>散列表</span></a></h2><ul><li>散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。如果同一个关键码有多个 value，则会通过链表进行相互连接</li></ul><hr><h2 id="堆" tabindex="-1"><a class="header-anchor" href="#堆"><span>堆</span></a></h2><ul><li>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有一下性质： <ul><li>堆中某个节点的值总是不大于或不小于其父节点的值</li><li>堆总是一棵完全二叉树</li></ul></li></ul><hr><h2 id="图" tabindex="-1"><a class="header-anchor" href="#图"><span>图</span></a></h2><ul><li>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。</li></ul><hr><h3 id="有向图" tabindex="-1"><a class="header-anchor" href="#有向图"><span>有向图</span></a></h3><ul><li>每个节点之间的线路是有方向，在单向的地方不可逆向导通</li></ul><hr><h3 id="无向图" tabindex="-1"><a class="header-anchor" href="#无向图"><span>无向图</span></a></h3><ul><li>每个节点之间是无方向，不存在方向，可以相互导通</li></ul><hr>',58),r=[t];function h(u,s){return i(),e("div",null,r)}const d=l(n,[["render",h],["__file","基本数据结构.html.vue"]]),o=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html","title":"基本数据结构","lang":"zh-CN","frontmatter":{"title":"基本数据结构","order":2,"description":"常见的数据结构，包含有数组、链表、栈、队列、树、散列表、堆、图。 数组 存储空间是连续。可以通过下表进行快速访问 优点： 按照索引查询速度较快 按照索引遍历速度较快 缺点： 数组固定大小，扩容较麻烦 数组只能存在一种数据结构 增删改查速度较慢 使用场景： 数据量较大，频繁的遍历的。 链表 存储空间不连续，通过指针进行访问下一个%%%%存储空间 优点： ...","head":[["meta",{"property":"og:url","content":"https://blog.jiuxialb.top/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"九夏的博客"}],["meta",{"property":"og:title","content":"基本数据结构"}],["meta",{"property":"og:description","content":"常见的数据结构，包含有数组、链表、栈、队列、树、散列表、堆、图。 数组 存储空间是连续。可以通过下表进行快速访问 优点： 按照索引查询速度较快 按照索引遍历速度较快 缺点： 数组固定大小，扩容较麻烦 数组只能存在一种数据结构 增删改查速度较慢 使用场景： 数据量较大，频繁的遍历的。 链表 存储空间不连续，通过指针进行访问下一个%%%%存储空间 优点： ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-21T16:16:31.000Z"}],["meta",{"property":"article:author","content":"九夏"}],["meta",{"property":"article:modified_time","content":"2024-06-21T16:16:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"基本数据结构\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-21T16:16:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"九夏\\",\\"url\\":\\"https://blog.jiuxialb.top/\\"}]}"]]},"headers":[{"level":2,"title":"数组","slug":"数组","link":"#数组","children":[]},{"level":2,"title":"链表","slug":"链表","link":"#链表","children":[]},{"level":2,"title":"栈","slug":"栈","link":"#栈","children":[]},{"level":2,"title":"队列","slug":"队列","link":"#队列","children":[]},{"level":2,"title":"树","slug":"树","link":"#树","children":[{"level":3,"title":"二叉树","slug":"二叉树","link":"#二叉树","children":[]},{"level":3,"title":"平衡二叉树","slug":"平衡二叉树","link":"#平衡二叉树","children":[]},{"level":3,"title":"红黑树","slug":"红黑树","link":"#红黑树","children":[]},{"level":3,"title":"B 树","slug":"b-树","link":"#b-树","children":[]},{"level":3,"title":"B+树","slug":"b-树-1","link":"#b-树-1","children":[]}]},{"level":2,"title":"散列表","slug":"散列表","link":"#散列表","children":[]},{"level":2,"title":"堆","slug":"堆","link":"#堆","children":[]},{"level":2,"title":"图","slug":"图","link":"#图","children":[{"level":3,"title":"有向图","slug":"有向图","link":"#有向图","children":[]},{"level":3,"title":"无向图","slug":"无向图","link":"#无向图","children":[]}]}],"git":{"createdTime":1716018035000,"updatedTime":1718986591000,"contributors":[{"name":"zhangjiahao","email":"961099916@qq.com","commits":1}]},"readingTime":{"minutes":4.39,"words":1318},"filePathRelative":"算法/数据结构/基本数据结构.md","localizedDate":"2024年5月18日","excerpt":"<p>常见的数据结构，包含有数组、链表、栈、队列、树、散列表、堆、图。</p>\\n<hr>\\n<h2>数组</h2>\\n<ul>\\n<li>存储空间是连续。可以通过下表进行快速访问</li>\\n</ul>\\n<hr>\\n<ul>\\n<li>优点：\\n<ul>\\n<li>按照索引查询速度较快</li>\\n<li>按照索引遍历速度较快</li>\\n</ul>\\n</li>\\n<li>缺点：\\n<ul>\\n<li>数组固定大小，扩容较麻烦</li>\\n<li>数组只能存在一种数据结构</li>\\n<li>增删改查速度较慢</li>\\n</ul>\\n</li>\\n</ul>\\n<hr>\\n<ul>\\n<li>使用场景：\\n<ul>\\n<li>数据量较大，频繁的遍历的。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{d as comp,o as data};
