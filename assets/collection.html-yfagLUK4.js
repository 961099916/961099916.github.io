import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as n,a as t}from"./app-DGkTQtrp.js";const s={},l=t(`<p>Java 集合框架是每一个入门开发者必会的内容，而且在较长的时间内容，不管是使用还是面试频度否非常的高，所以本人认为完全的、深入的学习是十分有必要的。本人结合源码和网络上的相关文章进行了总结。</p><h2 id="collection" tabindex="-1"><a class="header-anchor" href="#collection"><span>Collection</span></a></h2><p>Collection 是 <code>List</code> 和 <code>Set</code>的父类，它抽象了单列数据集合的基本方法。它包含了以下的方法：</p><ol><li>int size():获取单列数据集合中存储数据的数量</li><li>isEmpty():当前单列数据集合是否为空</li><li>contains(Object o): 当前单列数据合计是否存在该数据对象，当前对象需要实现 <code>equals</code> 和 <code>hashCode</code> 方法，防止不同的对象校验的 hashCode 一致</li><li>toArray(): 单列数据集合转数组</li><li>toArray(T[]) :单列数据结合转数组，数组类型为参数类型</li><li>add(E e): 单列数据集合添加数据</li><li>remove(E e): 删除单列数据集合中的该数据</li><li>containsAll(Collection&lt;?&gt; c): 校验当前数据集合是否在该单列数据中，若都存在则返回 true</li><li>addAll(Collection&lt;?&gt; c): 向当前单列数据集合中添加该数据结合</li><li>removeAll(Collection&lt;?&gt; c): 当前单列数据集合中移出指定的数据集合</li><li>removeIf(Predicate&lt;? super E&gt; filter): 移出通过 filter 筛选的数据集合</li><li>retainAll(Collection&lt;?&gt; c): 从该集合中删除未包含在指定集合中的所有元素</li><li>clear(): 从此集合中移除所有元素(可选操作)。该方法返回后，集合将为空。</li><li>equals(Object o):</li><li>hashCode():</li><li>spliterator():</li><li>stream():</li><li>parallelStream():</li></ol><h3 id="实现类比较" tabindex="-1"><a class="header-anchor" href="#实现类比较"><span>实现类比较</span></a></h3><table><thead><tr><th style="text-align:center;">实现类名称</th><th style="text-align:center;">实现原理</th><th style="text-align:center;">优点</th><th style="text-align:center;">缺点</th></tr></thead><tbody><tr><td style="text-align:center;">ArrayList</td><td style="text-align:center;">数组</td><td style="text-align:center;">索引查询快</td><td style="text-align:center;">变更效率低</td></tr><tr><td style="text-align:center;">LinkedList</td><td style="text-align:center;">链表</td><td style="text-align:center;">变更效率高</td><td style="text-align:center;">索引查询慢</td></tr><tr><td style="text-align:center;">Vector</td><td style="text-align:center;">ArrayList 一致</td><td style="text-align:center;">加锁，防止并发问题</td><td style="text-align:center;">由于加锁问题，导致操作效率较低</td></tr><tr><td style="text-align:center;">Stack</td><td style="text-align:center;">继承了 Vector</td><td style="text-align:center;">相比于 Vector 功能更加强大，封装了部分方法</td><td style="text-align:center;">和 Vector 一致</td></tr></tbody></table><h3 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist"><span>ArrayList</span></a></h3><p><code>ArrayList</code> 是 <code>Collection</code> 实现子类，它实现了 <code>Collection</code> 的所有功能且添加了部分自己独有的一些功能，让其使用更加方便和简单。内部的实现原理是通过数组进行缓存元素数据，通过 size 属性缓存数据的长度。</p><h4 id="构造方法" tabindex="-1"><a class="header-anchor" href="#构造方法"><span>构造方法</span></a></h4><p><code>ArrayList</code> 有三个构造方法，无参、初始容量、初始元素。</p><ul><li>无参：会给属性 <code>this.elementData</code>赋值为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 。</li><li>初始容量：若设置容量大于 0，会给属性 <code>this.elementData</code>赋值为<code>new Object[initialCapacity]</code>；若设置容量等于 0 ，会给属性 <code>this.elementData</code>赋值为<code>EMPTY_ELEMENTDATA</code>；若设置容量小于 0，则抛出异常。</li><li>初始元素：若初始元素数量等于 0， 则会给属性 <code>this.elementData</code>赋值为<code>EMPTY_ELEMENTDATA</code>；若初始元素数量大于 0，则会把元素赋值给<code>this.elementData</code>。</li></ul><h4 id="判断" tabindex="-1"><a class="header-anchor" href="#判断"><span>判断</span></a></h4><p>判断集合中是否存在该元素是通过遍历集合的属性<code>elementData</code>的数据，通过<code>equals</code>判断数据是否相等，所以需要该数据对象实现对应的方法。</p><h4 id="新增" tabindex="-1"><a class="header-anchor" href="#新增"><span>新增</span></a></h4><p>添加元素时先让<code>modCount</code> 加一（后续移出时会使用）。如果当前插入的位置等于元素数量即当前集合数据已满，则需要进行扩容，扩容代码如下:</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">newCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// overflow-conscious code</span>
        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> minCapacity<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token operator">?</span> newCapacity
            <span class="token operator">:</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&gt;</span> <span class="token constant">MAX_ARRAY_SIZE</span><span class="token punctuation">)</span>
            <span class="token operator">?</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span>
            <span class="token operator">:</span> <span class="token constant">MAX_ARRAY_SIZE</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>minCapacity: 是当前容量+1</li><li>newCapacity: 是 oldCapacity + （0.5*oldCapacity）</li></ul><blockquote><p>第一次扩容时，若是无参的构造方法，则会进行默认为容量是 10；含有参数的构造方法，第一次则按照 1.5 倍扩容（初始化容量为 0 时，则第一次扩容容量会变更为 1）</p></blockquote><blockquote><p>后续扩容，则需要判断扩容 1.5 倍之后是否超出 <code>int</code> 的最大值，若是会超过则取 Integer.MAX_VALUE</p></blockquote><h4 id="删除" tabindex="-1"><a class="header-anchor" href="#删除"><span>删除</span></a></h4><blockquote><p>单个删除时:查询元素在集合的下标索引，然后通过<code>System.arraycopy</code>进行数组的 copy 和创建以此实现数据的删除</p></blockquote><blockquote><p>批量删除时: 会缓存<code>modCount</code> 在删除的过程中会校验缓存的<code>modCount</code>是否和当前的一致，若是不一致则会抛出<code>ConcurrentModificationException</code>异常，提示在并发修改</p></blockquote><h4 id="扩展方法" tabindex="-1"><a class="header-anchor" href="#扩展方法"><span>扩展方法</span></a></h4><h3 id="linkedlist" tabindex="-1"><a class="header-anchor" href="#linkedlist"><span>LinkedList</span></a></h3><p><code>LinkedList</code> 也是实现<code>Collection</code> 的子类，它内部的数据接口是采用链表的方式进行存储，数据长度也是通过属性进行获取的。</p><h4 id="构造方法-1" tabindex="-1"><a class="header-anchor" href="#构造方法-1"><span>构造方法</span></a></h4><p>该类的构造方法并未进行特殊的处理，无参的构造方法什么都为进行初始化，通过集合进行初始化的，则直接调用的<code>addAll</code>。</p><h4 id="判断-1" tabindex="-1"><a class="header-anchor" href="#判断-1"><span>判断</span></a></h4><p>这里判断对象是否存在也是进行数据遍历，进行比较数据对象是否存在。</p><h4 id="新增-1" tabindex="-1"><a class="header-anchor" href="#新增-1"><span>新增</span></a></h4><p>刚创建时，属性<code>first</code> 和 <code>last</code> 都是空的，第一次添加是会给 <code>first</code> 和 <code>last</code> 赋值，后续创建则直接在先缓存 <code>last</code> 然后 <code>last</code>等于新元素，缓存的<code>last</code>关联新元素，从而先新元素的添加。</p><h4 id="删除-1" tabindex="-1"><a class="header-anchor" href="#删除-1"><span>删除</span></a></h4><p>删除则是查询到对应的节点后，直接让前一个节点关联后一节点，从而实现该节点的删除。</p><h4 id="扩展方法-1" tabindex="-1"><a class="header-anchor" href="#扩展方法-1"><span>扩展方法</span></a></h4><h3 id="vector" tabindex="-1"><a class="header-anchor" href="#vector"><span>Vector</span></a></h3><p><code>Vector</code> 类似于 <code>ArrayList</code> 都是基于数组的存储结构，只不过加入了自己特性的一些东西，例如扩容规则、线程安全。</p><h4 id="构造方法-2" tabindex="-1"><a class="header-anchor" href="#构造方法-2"><span>构造方法</span></a></h4><p>构造方法可以传入初始容量和扩容自增的数量。默认的初始容量是 10，自增的属性值设置为 0。</p><h4 id="判断-2" tabindex="-1"><a class="header-anchor" href="#判断-2"><span>判断</span></a></h4><p>基本和<code>ArrayList</code> 一致，只不过在判断时加锁进而防止并发问题。</p><h4 id="新增-2" tabindex="-1"><a class="header-anchor" href="#新增-2"><span>新增</span></a></h4><p>新增操作和<code>ArrayList</code>一致，只不过在操作的时候添加了锁，进行防止并发操作</p><h4 id="删除-2" tabindex="-1"><a class="header-anchor" href="#删除-2"><span>删除</span></a></h4><h4 id="扩展方法-2" tabindex="-1"><a class="header-anchor" href="#扩展方法-2"><span>扩展方法</span></a></h4><h3 id="stack" tabindex="-1"><a class="header-anchor" href="#stack"><span>Stack</span></a></h3><h3 id="hashset" tabindex="-1"><a class="header-anchor" href="#hashset"><span>HashSet</span></a></h3><h3 id="treeset" tabindex="-1"><a class="header-anchor" href="#treeset"><span>TreeSet</span></a></h3><h3 id="copyonwritearraylist" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist"><span>CopyOnWriteArrayList</span></a></h3><h3 id="copyonwritearrayset" tabindex="-1"><a class="header-anchor" href="#copyonwritearrayset"><span>CopyOnWriteArraySet</span></a></h3><h3 id="concurrentskiplistset" tabindex="-1"><a class="header-anchor" href="#concurrentskiplistset"><span>ConcurrentSkipListSet</span></a></h3><h2 id="map" tabindex="-1"><a class="header-anchor" href="#map"><span>Map</span></a></h2><p>Map 抽象了键值对数据集合的通用方法，它包含以下方法：</p><ol><li>int size()：查看元素数目</li><li>isEmpty()：元素个数是否是0</li><li>containsKey(Object key)：是否存在这个 key</li><li>containsValue(Object value)： 是否存在个 value</li><li>get(Object key)： 通过 key 获取对象的 value</li><li>put(K key, V value)： 添加 key-value 元素</li><li>remove(Object key)： 移出 key 对应的 value</li><li>putAll(Map&lt;? extends K, ? extends V&gt; m)：添加集合中的所有元素</li><li>clear()： 清空元素</li><li>keySet()： 获取元素的 key 的不重复集合</li><li>values()：获得元素中的所有 value</li><li>entrySet()：获取所有的 key-value 对象</li><li>getOrDefault(Object key, V defaultValue)：获取 key 对应的 value，若不存在在返回 defaultValue</li><li>putIfAbsent(K key, V value): 若是不存在 key 对应的 value 则进行添加</li><li>remove(Object key, Object value)：删除 key 对应的值且等于 value 的</li><li>replace(K key, V oldValue, V newValue)： 若存在 key 的值为 oldValue 的元素，则重新赋值 key 的值为 newValue</li><li>replace(K key, V value)：若存在 key 就添加 key 对应的值为 value</li><li>computeIfAbsent(K key,Function&lt;? super K, ? extends V&gt; mappingFunction)：若不存在 key 对应的值，则通过 mappingFunction 获取，且添加到集合中</li><li>computeIfPresent(K key,BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)：若是存在key 对应的 value 则传入 key，value 到 mappingFUnction 获取新的 newValue，若 newValue 为空则会清除 key，若不为空，则修改集合中key 对应的值，且返回newValue</li></ol><h3 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap"><span>HashMap</span></a></h3><p>HashMap 通过设置一些属性，进行控制某些行为，例如：初始容量、扩容时下次数量、多少元素转化为树，以下是 HashMap 的属性：</p><ul><li>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; 初始容量为 16</li><li>MAXIMUM_CAPACITY = 1 &lt;&lt; 30; int 的最大值为 2 的 31-1，但是只能移动1 所以最大值为 2 的 30 次方</li><li>DEFAULT_LOAD_FACTOR = 0.75f; 默认的负载因子 0.75</li><li>TREEIFY_THRESHOLD = 8; 链表树化的最小元素数量，即链表元素个数大于 8 时，链表进行树化</li><li>UNTREEIFY_THRESHOLD = 6; 树退化成链表的最大元素数量，当树的元素数量小于 6 的时候，树退化为链表</li><li>MIN_TREEIFY_CAPACITY = 64; 集合树化的最小元素个数，当集合元素数目大于 64 的时候才可能树化,优先级大于 TREEIFY_THRESHOLD ，可以存在链表长度大于 8 ，只有当容量大于 64 才会树化</li><li>Node&lt;K,V&gt;[] table; 集合元素数据</li><li>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; 缓存的数据</li><li>int size; 元素数目</li><li>int modCount; 防止迭代器遍历的时候修改</li><li>int threshold; 下一次扩容的容量</li><li>float loadFactor; 负载因子</li></ul><h4 id="hashmap的扩缩容" tabindex="-1"><a class="header-anchor" href="#hashmap的扩缩容"><span>HashMap的扩缩容</span></a></h4><p>当进行新增时，会先去取 key 的哈希值，<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，进行 put 时，会先进行判断 table 是否存在数据，如果没有则调用 <code>resize()</code> 进行初始化或扩容，若 该元素在 table 中不存在哈希冲突则放置到对应的下标上，若存在哈希冲突则需要判断 table 该下标的数据是否是树，若是树则进行添加子节点，若不是树，则链接在链表后，判断若当前链表的数量大于默认树化的数目，则执行 <code>treeifyBin(tab, hash)</code>,进行树化处理</p><ul><li>为什么要这么计算哈希值</li></ul><h3 id="treemap" tabindex="-1"><a class="header-anchor" href="#treemap"><span>TreeMap</span></a></h3><h3 id="weakhashmap" tabindex="-1"><a class="header-anchor" href="#weakhashmap"><span>WeakHashMap</span></a></h3><h3 id="hashtable" tabindex="-1"><a class="header-anchor" href="#hashtable"><span>Hashtable</span></a></h3><h3 id="concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap"><span>ConcurrentHashMap</span></a></h3><h3 id="concurrentskiplistmap" tabindex="-1"><a class="header-anchor" href="#concurrentskiplistmap"><span>ConcurrentSkipListMap</span></a></h3><h2 id="queue" tabindex="-1"><a class="header-anchor" href="#queue"><span>Queue</span></a></h2><h3 id="arrayblockingqueue" tabindex="-1"><a class="header-anchor" href="#arrayblockingqueue"><span>ArrayBlockingQueue</span></a></h3><h3 id="linkedblockingqueue" tabindex="-1"><a class="header-anchor" href="#linkedblockingqueue"><span>LinkedBlockingQueue</span></a></h3><h3 id="linkedblockingdeque" tabindex="-1"><a class="header-anchor" href="#linkedblockingdeque"><span>LinkedBlockingDeque</span></a></h3><h3 id="concurrentlinkedqueue" tabindex="-1"><a class="header-anchor" href="#concurrentlinkedqueue"><span>ConcurrentLinkedQueue</span></a></h3><h3 id="concurrentlinkeddeque" tabindex="-1"><a class="header-anchor" href="#concurrentlinkeddeque"><span>ConcurrentLinkedDeque</span></a></h3>`,70),i=[l];function c(o,p){return a(),n("div",null,i)}const h=e(s,[["render",c],["__file","collection.html.vue"]]),u=JSON.parse('{"path":"/java/collection.html","title":"Java集合","lang":"zh-CN","frontmatter":{"title":"Java集合","date":"2024-02-18T00:00:00.000Z","description":"Java 集合框架是每一个入门开发者必会的内容，而且在较长的时间内容，不管是使用还是面试频度否非常的高，所以本人认为完全的、深入的学习是十分有必要的。本人结合源码和网络上的相关文章进行了总结。 Collection Collection 是 List 和 Set的父类，它抽象了单列数据集合的基本方法。它包含了以下的方法： int size():获取单列...","head":[["meta",{"property":"og:url","content":"https://961099916.github.io/java/collection.html"}],["meta",{"property":"og:site_name","content":"九夏的博客"}],["meta",{"property":"og:title","content":"Java集合"}],["meta",{"property":"og:description","content":"Java 集合框架是每一个入门开发者必会的内容，而且在较长的时间内容，不管是使用还是面试频度否非常的高，所以本人认为完全的、深入的学习是十分有必要的。本人结合源码和网络上的相关文章进行了总结。 Collection Collection 是 List 和 Set的父类，它抽象了单列数据集合的基本方法。它包含了以下的方法： int size():获取单列..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-14T10:26:17.000Z"}],["meta",{"property":"article:author","content":"九夏"}],["meta",{"property":"article:published_time","content":"2024-02-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-14T10:26:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java集合\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-02-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-14T10:26:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"九夏\\",\\"url\\":\\"https://blog.jiuxialb.top/\\"}]}"]]},"headers":[{"level":2,"title":"Collection","slug":"collection","link":"#collection","children":[{"level":3,"title":"实现类比较","slug":"实现类比较","link":"#实现类比较","children":[]},{"level":3,"title":"ArrayList","slug":"arraylist","link":"#arraylist","children":[]},{"level":3,"title":"LinkedList","slug":"linkedlist","link":"#linkedlist","children":[]},{"level":3,"title":"Vector","slug":"vector","link":"#vector","children":[]},{"level":3,"title":"Stack","slug":"stack","link":"#stack","children":[]},{"level":3,"title":"HashSet","slug":"hashset","link":"#hashset","children":[]},{"level":3,"title":"TreeSet","slug":"treeset","link":"#treeset","children":[]},{"level":3,"title":"CopyOnWriteArrayList","slug":"copyonwritearraylist","link":"#copyonwritearraylist","children":[]},{"level":3,"title":"CopyOnWriteArraySet","slug":"copyonwritearrayset","link":"#copyonwritearrayset","children":[]},{"level":3,"title":"ConcurrentSkipListSet","slug":"concurrentskiplistset","link":"#concurrentskiplistset","children":[]}]},{"level":2,"title":"Map","slug":"map","link":"#map","children":[{"level":3,"title":"HashMap","slug":"hashmap","link":"#hashmap","children":[]},{"level":3,"title":"TreeMap","slug":"treemap","link":"#treemap","children":[]},{"level":3,"title":"WeakHashMap","slug":"weakhashmap","link":"#weakhashmap","children":[]},{"level":3,"title":"Hashtable","slug":"hashtable","link":"#hashtable","children":[]},{"level":3,"title":"ConcurrentHashMap","slug":"concurrenthashmap","link":"#concurrenthashmap","children":[]},{"level":3,"title":"ConcurrentSkipListMap","slug":"concurrentskiplistmap","link":"#concurrentskiplistmap","children":[]}]},{"level":2,"title":"Queue","slug":"queue","link":"#queue","children":[{"level":3,"title":"ArrayBlockingQueue","slug":"arrayblockingqueue","link":"#arrayblockingqueue","children":[]},{"level":3,"title":"LinkedBlockingQueue","slug":"linkedblockingqueue","link":"#linkedblockingqueue","children":[]},{"level":3,"title":"LinkedBlockingDeque","slug":"linkedblockingdeque","link":"#linkedblockingdeque","children":[]},{"level":3,"title":"ConcurrentLinkedQueue","slug":"concurrentlinkedqueue","link":"#concurrentlinkedqueue","children":[]},{"level":3,"title":"ConcurrentLinkedDeque","slug":"concurrentlinkeddeque","link":"#concurrentlinkeddeque","children":[]}]}],"git":{"createdTime":1713090377000,"updatedTime":1713090377000,"contributors":[{"name":"zhangjiahao","email":"961099916@qq.com","commits":1}]},"readingTime":{"minutes":7.74,"words":2321},"filePathRelative":"java/collection.md","localizedDate":"2024年2月18日","excerpt":"<p>Java 集合框架是每一个入门开发者必会的内容，而且在较长的时间内容，不管是使用还是面试频度否非常的高，所以本人认为完全的、深入的学习是十分有必要的。本人结合源码和网络上的相关文章进行了总结。</p>\\n<h2>Collection</h2>\\n<p>Collection 是 <code>List</code> 和 <code>Set</code>的父类，它抽象了单列数据集合的基本方法。它包含了以下的方法：</p>\\n<ol>\\n<li>int size():获取单列数据集合中存储数据的数量</li>\\n<li>isEmpty():当前单列数据集合是否为空</li>\\n<li>contains(Object o): 当前单列数据合计是否存在该数据对象，当前对象需要实现 <code>equals</code> 和 <code>hashCode</code> 方法，防止不同的对象校验的 hashCode 一致</li>\\n<li>toArray(): 单列数据集合转数组</li>\\n<li>toArray(T[]) :单列数据结合转数组，数组类型为参数类型</li>\\n<li>add(E e): 单列数据集合添加数据</li>\\n<li>remove(E e): 删除单列数据集合中的该数据</li>\\n<li>containsAll(Collection&lt;?&gt; c): 校验当前数据集合是否在该单列数据中，若都存在则返回 true</li>\\n<li>addAll(Collection&lt;?&gt; c): 向当前单列数据集合中添加该数据结合</li>\\n<li>removeAll(Collection&lt;?&gt; c): 当前单列数据集合中移出指定的数据集合</li>\\n<li>removeIf(Predicate&lt;? super E&gt; filter): 移出通过 filter 筛选的数据集合</li>\\n<li>retainAll(Collection&lt;?&gt; c): 从该集合中删除未包含在指定集合中的所有元素</li>\\n<li>clear(): 从此集合中移除所有元素(可选操作)。该方法返回后，集合将为空。</li>\\n<li>equals(Object o):</li>\\n<li>hashCode():</li>\\n<li>spliterator():</li>\\n<li>stream():</li>\\n<li>parallelStream():</li>\\n</ol>","autoDesc":true}');export{h as comp,u as data};
