---
title: 设计模式
order: 2
---


[快速记忆23种设计模式 - 知乎](https://zhuanlan.zhihu.com/p/128145128)

## 七大原则

### 开闭原则

一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭。

### 单一职责原则

一个类应该只有一个发生变化的原因。

### 里氏替换原则

所有引用基类的地方必须能透明地使用其子类的对象。

### 依赖倒置原则

1、上层模块不应该依赖底层模块，它们都应该依赖于抽象。

2、抽象不应该依赖于细节，细节应该依赖于抽象。

### 接口隔离原则

1、客户端不应该依赖它不需要的接口。

2、类间的依赖关系应该建立在最小的接口上。

### 迪米特法则

只与你的直接朋友交谈，不跟“陌生人”说话。

### 组合/聚合复用原则

尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的。

## 创建型

### 单例模式

#### 饿汉式

全局只会存在该类的唯一一个对象。在加载类的时候就已经开始初始化，而非等到使用的时候才进行初始化，此种方式线程安全，但可能存在资源浪费，即不会使用其对象还是会创建该对象。

> 静态常量的方式枚举的方式


#### 懒汉式

只有在使用的时候才会进行创建该对象，但是由于可能存在多线程调用问题，所以需要注意线程安全问题。

> 1.synchronized锁住创建方法

2.双重校验锁（DCL，即 double-checked locking）

3.静态内部类的方式


### 工厂模式

通过工厂类能够进行生成所需对象，而非手动创建。一般会让工厂构造方法为私有，防止创建工厂的对象。只需调用工厂的某方法就可生成对应的对象。

### 抽象工厂模式

工厂模式的进阶用法，通过抽象工厂进行生成工厂。

### 建造者模式

把对象的组合构造或者某些属性设置进行封装，使之在创建对象的时候直接满足某些场景的数据，而非全由用户手动设置，防止构建出不符合的对象。

### 原型模式

根据某些已经存在的对象而无需再次手动创建此对象和赋值操作。

## 结构型

关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。

### 适配器模式

适配器是作为两个不兼容的接口之间的桥梁。

将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

适配器模式主要改变所考虑对象的接口。

### 桥梁模式

### 装饰器模式

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。

这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

装饰器模式为了增强功能。

### 门面模式

### 合成模式

### 享元模式

### 代理模式

在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。

在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。

为其他对象提供一种代理以控制对这个对象的访问。

代理模式不能改变所代理类的接口。代理模式是为了加以控制。

### 注意事项：

1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。

2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

## 行为型

关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。

### 策略模式

### 模版方法模式

### 观察者模式

### 迭代器模式

### 责任链模式

### 命令模式

### 备忘录模式

### 状态模式

### 访问者模式

### 中介者模式

### 解释器模式
