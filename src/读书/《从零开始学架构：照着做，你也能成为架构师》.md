---
title: 《从零开始学架构：照着做，你也能成为架构师》
date: 2024-02-18
tags:
	- 计算机
---
# 《从零开始学架构：照着做，你也能成为架构师》

## 1. 架构基础

### 架构是什么

- 系统与子系统

	-  系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。它的意
思是“总体”“整体”或“联盟”。

		- 关联
		- 规则
		- 能力

- 模块和组件

	- 划分模块是为了职责分离
	- 划分组件是为了单元复用

- 框架和架构

	- 框架多是一种规范
	- 架构多是一种结构，系统结构

### 架构设计的目的

- 解决复杂度带来的问题

### 复杂度来源

- 高性能

	- 单机复杂度

		- 进程和线程
		- 操作系统

	- 集群复杂度

		- 任务分配
		- 任务分解

- 高可用  指“系统无中断地执行其功能”的能力，代表系统的可用性程度，是进行系统设计
时的准则之一。

	- 计算高可用
	- 存储高可用
	- 高可用状态决策

		- 独裁式
		- 协商式
		- 民主式

- 高扩展

	- 预测变化
	- 应对变化

		- 稳定和变化分层，防止相互影响过深

- 低成本
- 安全

	- 功能安全
	- 架构安全

- 规模

## 2. 架构设计原则

### 合适原则：合适优于业界领先

- 1. 考虑人员多少
- 2. 考虑时间成本，罗马不是一天建成的
- 3. 结合业务设计

### 简单原则：简单优于复杂

- 结构越复杂可用率越低
- 逻辑越复杂，开发越慢，排查越慢

### 演化原则：演化优于一步到位

- 架构需要随业务的变化而变化
- 不断迭代，去其糟粕留其精华

## 3. 架构设计流程

### 识别复杂度

- 列出复杂度问题，根据业务、技术、团队等排出优先级

### 设计备选方案

- 误区

	- 设计出最优秀的方案
	- 只做一个方案

		- 应做 3~5 个方案，且有明显的差异

	- 过于详细

### 评估和选择备选方案

- 360 度环评

	- 质量属性

		- 性能
		- 可用性
		- 成本
		- 项目投入
		- 复杂度
		- 安全性
		- 可扩展性等

	- 若是无法抉择则可添加权重

### 详细方案

- 细化技术细节

	- 选型
	- 参数设置

## 4. 存储高性能

### 关系数据库

- 读写分离

	- 主从模式
	- 存在的问题

		- 1. 从节点同步主节点数据可能存在延迟，导致读不到。

			- 先读从节点，无数据再读主节点，关键数据可直接读取主节点

- 分库分表

	- 使用场景

		- 数据量达到千万以上

			- 即使有索引索引也会很慢
			- 文件很大，备份和恢复时间过长
			- 文件过大，丢失数据量大的风险高

	- 业务分表

		- join 问题
		- 事务问题
		- 成本问题

	- 分表

		- 垂直分表

			- 例如：婚恋网站人物列表只需要有 name,age等属性即可，无需过的属性导致查询速度过慢

		- 水平分表：会引入更多的复杂度

			- 路由

				- 范围路由
				- hash 路由
				- 配置路由

			- join

				- 只能多次 join 解决

			- count

				- 多次 count
				- 记录数表，新增表进行处理

			- order by

				- 多次 order by 进行聚合

- 实现方法

	- 程序代码封装

		- 特点

			- 实现简单，可根据业务进行定制
			- 开发工作量大
			- 故障问题不好处理

		- 开源方案

			- 淘宝的 TDDL

	- 中间件封装

		- 特点

			- 支持多种编程语言
			- 支持完整的数据库协议和 SQL 规范，内容丰富导致 bug 可能会较多
			- 所有的数据库操作都变成对中间件的操作，会影响性能
			- 主从切换无感知，有中间件解决

		- 方案

			- MySQL Proxy
			- MySQL Router
			- Atlas
			- ShardingSphere

	- 实现复杂度

		- 因为分表的 order by 等需要聚合还要识别 SQL 的关键字，所以实现比较困难

### NoSQL

- 关系数据库的缺点

	- 1.行记录无法存储数据结构
	- 2.关系数据库的 schema 扩展不方便
	- 3.关系数据库大数据情况下 I/O较高
	- 4.关系数据库的文档搜索能力较弱

		- 全文搜索的条件可以随意排列组合，如果通过索引满足则会添加大量的索引
		- 模糊匹配的方式无法满足，只能用 like，like 是全表扫描速度较慢

- 分类

	- K-V 存储： Redis
	- 文档数据库： MongoDB
	- 列式数据库：Hbase
	- 全文搜索引擎：Elasticsearch

- K-V存储

	- redis 目前问题

		- 1.不支持完整的 ACID

- 文档数据库

	- 优势

		- 新增字段简单
		- 历史数据不会出错
		- 可以很容易存储复杂的数据结构

- 列式数据库

	- 优势

		- 业务同时读取多列效率较高，因为这些列式存储在一起的，一次磁盘读写就能把一行数据的所有列都读取到内存中
		- 可以一次写多个列

- 全文搜索引擎

	- 原理是倒排序，即内容和文件建立关联关系

### 缓存

- 使用场景

	- 需要复杂的运算之后得到结果，存储系统也无能为力
	- 读多写少，存储系统有心无力

- 缓存穿透：缓存中没有数据导致去查询数据库

	- 存储数据不存在，可通过设置默认值解决
	- 缓存数据生成耗费大量时间，

- 缓存雪崩：缓存失效后导致系统性能的下降

	- 更新锁，只能一个线程去更新
	- 后台更新，缓存本身设置为永久有效，定时任务或消息通知去更新缓存数据

- 缓存热点：热点数据进行缓存

## 5. 计算高性能

### 单服务器高性能

- 关键之一是网络编程模型

	- 服务器如何管理连接
	- 服务器如何处理请求
	- 解决方向

		- I/O 模型
		- 进程模型

- PPC（Process per Connection ）

	- 流程

		- 1.父进程接受连接
		- 2.父进程 fork 子进程
		- 3.子进程处理请求的读写
		- 4.子进程关闭连接

	- 弊端

		- fork 代价过高
		- 父子进程通信复杂
		- 进程数量增大后多操作系统压力过大

- prefork

	- 进行连接时才 fork 会让用户感觉卡段，所以出现了预fork优化流程，但是也会出现“惊群”问题，即只会有一个子进程去连接，但是会唤起所有的子进程去尝试，浪费线程上下文切换
	- 也存在父子线程通信复杂问题；进程数量增大后导致操作系统压力过大

- TPC(Thread per Connection)

	- 流程

		- 1.父进程接受连接
		- 2.父进程创建子线程
		- 3.子线程处理请求的读写
		- 4.子线程关闭连接

	- 虽然解决了线程通信复杂和fork 代价过高问题，但是也引入的新的问题

		- 高并发情况下依然存在性能问题
		- 虽无需进程间通信了，但线程间的互斥和共享又引入了新的复杂度，可能一不小心出现死锁问题
		- 可能出现某个线程异常导致整个进程的结束
		- 还是存在 CPU 线程调度和切换代价问题

- PreThread

	- 流程

		- 1.主线程accept，然后将连接交给某个线程处理
		- 2. 子线程都尝试去accept，最终只有一个子线程accept成功

- Reactor

	- 要解决的问题

		- 为了解决PPC多次创建进程问题，可以通过进行池化，实现资源的节约，但是引入后出现了新的问题

			- 进程如何高效的处理多个连接

				- 一个连接一个进程时可以通过阻塞进行读取，但是一个进程连接多个连接时就不能阻塞到某个进程上，解决这个问题的方法就是将read改为非阻塞的，进行不断的轮询多个连接，但是解决方式并不优雅，轮询也是小号CPU的，如果一个进程的连接数过多，轮询的效率也不高，为了解决这个问题想到了只有连接上有数据的时候进程采取处理，这就是I/O多路复用技术的来源

		- 两个关键实现点

			- 当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无需再轮询所有的连接
			- 当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理

	- 模式的核心

		- reactor

			- 负责监听和分配时间

		- 处理资源线程池

			- 负责处理时间

	- 实现方案

		- 单Reactor 单进程/单线程

			- 1.Reactor对象通过select监控连接事件，收到事件通知后通过dispatch进行分发
			- 2.如果是连接建立的事件，则由Acceptor处理，Acceptor通过accept接受连接，并创建一个Handler来处理连接后续的各种事件
			- 3.如果不是连接建立事件，则Reactor会调用连接对象的Handler（第2步中创建的hadnler）进行响应
			- 4.Handler会完成read-->业务处理-->send的完整业务流程
			- 优点：简单，没有进程间通信，没有进程竞争，全部都在同一个进程中完成
			- 缺点

				- 只有一个进程，无法发挥多核CPU的性能
				- 只能部署多个系统来利用多核CPU，这样会带来运维复杂度
				- handler在处理某个连接的业务时，整个进程无法处理其他连接的事件，很容易导致性能瓶颈

			- 适用场景

				- 业务处理速度非常快的，例如： Redis

		- 单Reactor 多线程

			- 1.主线程中，Reactor对象通过select监听连接事件，收到事件后通过dispatch进行分发

		- 多Reactor 多进程/线程

- Proactor

### 集群高性能

- 负载均衡器的分类

	- DNS负载均衡：不同地区的用户访问同一个域名返回不同的ip

		- 优点

			- 简单、成本低
			- 就近访问，提升访问速度

		- 缺点

			- 更新不及时
			- 扩展性差
			- 分配策略比较简单

	- 硬件负载均衡：F5和A10

		- 优点

			- 功能强大
			- 性能强大
			- 稳定性高
			- 支持安全防护

		- 缺点

			- 价格昂贵
			- 扩展能力差

	- 软件负载均衡

		- 分类

			- nginx：7层负载均衡
			- LVS：是linux内核的4层负载均衡

		- 优点

			- 简单
			- 便宜
			- 灵活

		- 缺点

			- 性能一般
			- 功能没有硬件负载均衡那么强大
			- 一般不具备防火墙和防DDOS攻击等安全功能

- 负载均衡器架构

	- 1. DNS负载均衡实现地理级别的负载均衡
	- 2. F5实现集群级别的负载均衡
	- 3. 软件负载均衡实现机器级别的负载均衡

- 负载均衡器算法

	- 任务平分类：可以决定平均分配到各个服务器上，也可以是按照比例或者权重
	- 负载均衡类：根据服务器的负载来进行分配，这里的负载不一定是CPU负载，而是系统当前压力，可以是CPU负载来衡量，也可以是连接数、I/O使用率、网卡吞吐量等来衡量系统的压力
	- 性能最优类：根据服务器的响应时间来进行任务分配，优先分配给响应最快的服务器
	- Hash类：根据某些信息进行Hash运算，分配到指定服务器上。常见的有源地址Hash、目标地址Hash、session id hash、用户id Hash等

## 6. CAP

### CAP 理论

- 一致性 Consistency

	- 对某个指定客户端来说，读操作保证能够返回最新的写操作结果

- 可用性 Availability

	- 非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）

- 分区容错性Partition Tolerance

	- 当出现网络分区后，系统能够继续“履行职责”

### CAP 应用

- 分布式环境下 P 是必须得，否则当出现网络分区时，C 和 A 就会冲突
- CP

	- 当 N1 节点数据在同步到 N2 节点时，复制通道出现问题，导致未复制到N2，为了保证 C，此时系统访问 N2 的时候会提示不可用（违反了 A）

- AP

	- 当 N1 节点数据在同步到 N2 节点时，复制通道出现问题，导致未复制到N2，为了保证 A，此时系统访问 N2 可以正常使用，但是会导致数据不一致（违反了 C）

### CAP 细节

- CAP 关注的粒度是数据而不是系统；在整个系统中可以某些数据是 CP，某些数据是 AP
- CAP 是忽略网络延迟的
- 正常情况下不存在CP 和 AP 的选择，可以同时满足 CA

	- CA

		- 可通过数据库的同步，虽然有延迟，但是某些实时性不是很高的较适合
		- 可通过 MQ 实现最终数据一致性

- 放弃并不等于什么都不做，需要为分区恢复后做准备

### ACID、BASE

- ACID：数据库完整性理论

	- 原子性（Atomicity）

		- 一个事务中要么全部完成，要么全部失败，不会结束在中间状态

	- 一致性（Consistency）

		- 在事务开始前和结束后，数据库的完整性没有被破坏

	- 隔离性（Islation）

		- 数据库支持多个并发事务同时对数据读取和修改的能力，隔离性可以防止多个事务并
发执行时由于交叉执行而导致数据的不一致。
		- 隔离级别

			- 读未提交（read uncommitted）
			- 读提交(read committed)
			- 可重复度（read repeatable）
			- 串行化（Serializable）

	- 持久性（Durability）

		- 事务处理结束后，对数据的处理是永久的，即使系统故障也不会丢失

- BASE：即使无法做到强一致性，也要做到最终一致性

	- 基本可用（base available）

		- 分布式系统出现故障时，允许系统损失部分可用性，但是保证核心系统的可用性

	- 软状态（Soft state）

		- 允许系统出现中间状态，而该中间状态不影响系统整体的可用性

	- 最终一致性（Eventual Consistency）

		- 系统经过一段时间后所有的副本数据达到一致性

### CAP 和 BASE

- CP

	- CAP 理论是忽略网络延迟的，但是现实中肯定会存在延迟，这和 BASE 的最终一致性不谋而合

- AP

	- 牺牲一致性是指系统出现分区时，当分区问题结束时也要完成数据的一致性。 BASE 理论其实是 AP的延伸

## 7. FMEA

### FMEA 介绍

- FMEA (Failure mode and effects analysis ，故障模式与影响分析）又称为失效模式与后果分
析、失效模式与效应分析、故障模式与后果分析等

### FMEA 方法

- 具体方法

	- 1. 给出系统的初始架构图
	- 2.假设系统中某个部件出现故障
	- 3.分析此故障对系统的影响
	- 4.根据结果分析架构是否需要优化

- 分析表格包含的属性

	- 功能点：是从用户角度思考，而非技术角度
	- 故障模式：要用可量化的指标，例如：数据库响应 3s
	- 故障影响：出现故障时该功能点会受到什么影响，无影响，部分不可用，全部可用等，尽量给出可量化指标
	- 严重程度：尽量给出可量化指标
	- 故障原因：主要原因，可以作为问题预演
	- 故障概率：可从多个方面思考。如硬件、开源系统、自研系统
	- 风险程度
	- 已有措施：如检测告警、容错、自恢复
	- 规避措施
	- 解决措施
	- 后续规划

### FMEA 实战

-

## 8. 存储高可用

### 问题：主要是副本冗余实现高可用

- 数据如何复制
- 各个节点的职责是什么
- 如何应对复制延迟
- 如何应对复制中断

### 主备复制

- 详细设计

	- 1.主机存储数据，通过复制渠道复制给备机
	- 2.正常情况下，所有的请求直接发给主机，备机只做数据的备份不提供任何的读写
	- 3.主机出现故障的情况下，所有的请求不会发送到备机，整个系统处于中断状态，不可读写数据，但数据并没有全部丢失，备机还存在数据备份
	- 4.主机恢复后，读写继续访问主机，主机数据继续复制给备机
	- 5.如果主机不可修复，可通过人工备机升为主机，但是为了保持主备，需要新增机器
	- 6.主机不可恢复情况下，可能存在数据只到主机还未复制到备机的情况，此种数据就需要人工修复，业务也需要考虑改情况
	- 7.复制可能存在延迟，但是备机不提服务，所以不会影响系统，但是若存在大量数据未同步，突然主机不可修复，会损失大量数据，所以不可掉以轻心，需要添加监控，若存在延迟过大需要人工介入

- 优点

	- 客户端无感知，只需要回复后进行重新连接
	- 只需要数据同步，不需要进行机器的状态判断和倒换

- 缺点

	- 备机只提供备份，不提供读写，造成成本浪费
	- 故障后需要人工干预，无法自动恢复

### 主从复制

- 详细设计

	- 1.主机存储数据，通过复制渠道复制给备机
	- 2.写操作发给主机，读操作则根据业务进行发给主机还是从机
	- 3.主机故障的情况下，客户端不可写入数据，读操作可以发给从机是不影响读数据。适用于读操作较多的场景如新闻网站
	- 4.如果主机恢复后，写操作还继续访问主机，主机数据绩溪复制到从机
	- 5.如果主机不可修复，可通过人工从机升为主机，为了保持主从需要添加新主机
	- 6.主机不可恢复情况下，可能存在数据只到主机还未复制到备机的情况，此种数据就需要人工修复，业务也需要考虑改情况
	- 7.主从之间可能存在同步延迟，导致读取主从数据不一致问题，若是需要强一致性，则需要直接读取主机

- 优点

	- 主机出现故障时读操作不会受到影响
	- 从机提供读，发挥了硬件的性能

- 缺点

	- 客户端需要感知主从，不同的命令发送到不同的机器

### 主备倒换和主从倒换

- 主从/主备的共性问题

	- 主机故障不能写操作
	- 如果主机无法恢复则需要人工参与

- 考虑的关键点

	- 状态判断

		- 状态传递渠道：相互连接还是三方仲裁
		- 状态检测的内容：机器能够正常提供服务

	- 倒换决策

		- 倒换时机：什么时候倒换，是主机停机 3s 还是其他参数
		- 倒换策略：主机恢复后还是主机还是恢复后变为从/备机
		- 自动程度：全自动还是半自动（人工确认）

	- 数据冲突

		- 同步中主机出现故障导致主机和从/备机数据不一致问题怎么处理

- 常见架构

	- 互联式：主备/主从相互连接

		- 问题：需要主、备、客户端左右做修改；连接通道出现问题就会出现多主或多从问题，若是多种连接通道就会浪费资源

	- 中介式：引入中介方，MongDB 就是这种模式

		- 优点

			- 实现简单，只需要中介读取主从节点，然后根据状态进行确定各方是否主备情况

		- 缺点

			- 为了保证中介方高可用就会引入新的问题

		- 开源中介 ZooKeeper

	- 模拟式：从节点模拟客户端访问主节点

		- 优点

			- 实现更简单省去连接通道和状态管理

		- 缺点

			- 基于有限状态做决定，可能出现偏差

### 主主复制

- 详细设计

	- 1.两台主机都存储数据，通过复制通道将数据复制到另外一台主机
	- 2.正常情况下，客户端可以将读写操作发送给任意一台主机
	- 3.一台主机故障情况下，客户端只需要把读写操作发送给另一个主机
	- 4.如果故障主机恢复，客户端继续访问两台主机，两台主机之间互相复制对方数据
	- 5.如果故障主机不能恢复则需要人工添加一台新的主机
	- 6.存在某个主机写入数据后还未同步至另一台主机，该主机崩溃导致的书记丢失，需要考虑此风险
	- 7.存在同步延迟，可能写入了A，在B上读取不到刚刚写入的数据

- 优点

	- 两台都是主机，不存在倒换概念
	- 客户端无需分辨不同角色的主机，随便将读写操作发送给哪台主机都行

- 缺点

	- 部分数据不能双向复制，例如库存，A-1 和B-2双向复制会导致数据错误

### 数据集群

- 集中集群：每个节点的数据都是完整的一份

	- 需要考虑的

		- 主机如何将数据复制给备机
		- 备机如何检测主机状态
		- 主机故障后，如何决定新的主机

- 分散集群：每台服务器都会负责存储一部分数据，为了提升硬件利用率，每台服务器又会备份一部分数据

	- 需要考虑的

		- 均衡性
		- 容错性
		- 可伸缩性

- 分布式事务算法

	- 2PC：两阶段提交，分别是commit请求阶段和commit提交阶段

		- 成立的假设

			- 1.分布式系统中，存在一个节点作为协调者，其他节点作为参与者，且节点之间可以进行网络通信
			- 2. 所有节点都采用预写式日志，且日志被写入后即保持在可靠的存储设备上，即使节点损坏，也不会导致日志数据的消失
			- 3.所有节点不会永久性损坏，即使损坏仍然可以恢复

		- 基本说明

			- 1.协调者想所有的参会者发送QUERY TO COMMIT 消息，询问是否可以执行提交事务，并开始等待各参与者的响应
			- 2.参与者执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志，返回Yes消息给协调者；如果参与者执行失败，则返回No消息给协调者

				- 成功

					- 1.协调者向所有的参与者发出COMMIT的请求
					- 2.参与者完成COMMIT操作，并释放在整个事务期间占用的资源
					- 3.参与者向协调者发送ACK消息
					- 4.协调者接收到所有参与者反馈的ACK消息后，完成事务

				- 失败

					- 1.协调者向参与者发出ROLLBACK的请求
					- 2.参与者利用之前写入的Undo信息执行回滚，并释放在整个事务期间占用的资源
					- 3.参与者想向协调者发送ACK信息
					- 4.协调者接收到所有参与者反馈的ACK消息后，完成事务

		- 优点

			- 简单

		- 缺点

			- 同步阻塞，性能存在明显问题，难以支持高并发的应用场景
			- 状态不一致，如果第二段提交的时候参与者未接收到消息就会出现超时回滚的情况，出现状态不一致
			- 单点故障，协调者出现问题参与者就会一直阻塞下去，整个集群就无法提供服务

	- 3PC：三阶段提交，分别是提交判断阶段（协调者询问参与者是否可以提交事务），准备提交阶段（协调者向参与者发送准备提交的信息），提交执行阶段（协调者向参与者发送提交信息），只要到了第三阶段，如果参与者未接收到提交数据，也会变成提交

- 分布式一致性算法

	- Paxos算法
	- Raft算法
	- ZAB算法

### 数据分区

- 数据量，数据量越大分区规则越复杂
- 分区规则
- 复制规则

	- 集中式：数据统一复制到总的备份中心
	- 互备式，节点之间相互备份

		- 优缺点

			- 设计比较复杂
			- 扩展麻烦
			- 成本低，可以直接利用已有的设备

	- 独立式：每个节点有自己的备份节点

		- 设计简单，各分区互不影响
		- 扩展容器，新增分区只需要搭建自己的备份中心即可
		- 成本高

## 9. 计算高可用

### 设计关键点

- 哪些服务器可以执行任务
- 任务如何重新执行

### 主备

- 详细设计

	- 1. 主机执行所有的计算任务
	- 2.当主机故障时，任务分配其不会自动将任务发送给备机，此时系统不可用状态
	- 3.如果主机能够恢复，任务分配器继续将任务发送给主机
	- 4.如果主机不能恢复，则人工将备机升级为主机，需要添加新主机做备机

- 细分

	- 冷备

		- 备机启动状态，但是未启动业务系统，当备机升级为主机时，启动业务系统

	- 温备

		- 业务系统已经启动，但是不对外服务，当备机升级为主机时，让它正式提供服务

### 主从

- 详细设计

	- 1. 一般情况下，主机执行部分任务，备机执行部分任务
	- 2. 当主机出现故障时，任务分配器不会自动的将原来发给主机的任务发给从机，而是继续发送给主机，不管这些任务执行是否成功
	- 3.如果主机能够恢复，任务分配器继续将任务发送给主机
	- 4.如果主机不能恢复，则人工把原来的从机升为主机，然后添加新的主机为从机

- 优点

	- 主从架构的从机也执行任务，发挥了硬件的性能

- 缺点

	- 主从架构需要对任务进行分类，任务分配器会更复杂一些

### 根据节点角色分类

- 解决的问题

	- 主从或主备，人工效率低，容器出错，不能及时处理故障

- 对称集群(负载均衡集群)：所有节点的角色一致

	- 详细设计

		- 1.正常情况下，任务采取某种策略（轮询、权重、资源）等方法，将任务分配到集群中的不同服务器
		- 2.当某台服务器出现故障，任务不再将任务分配给该机器，转而分配给其他的服务器
		- 3.当故障的服务器恢复后，任务将再次分配给该机器

- 非对称集群：分角色master-slave

	- 详细设计

		- 1. 集群会通过某种方式区分服务器的不同角色，例如 Paxos 算法选举或者简单的 id 最小的为 master
		- 2.任务分配器将不同的任务分配给不同的角色

	- 复杂度的体现

		- 1.任务分配的策略更加复杂
		- 2.角色分配更加复杂

## 10. 业务高可用

### 异地多活

- 两个标准

	- 1. 正常情况下用户访问不管哪一地点的业务系统，都能够得到正确的业务服务
	- 2.某地异常的情况下， 用户访问到另一地点的业务系统，也能够得到正确的业务服务

- 两个代价

	- 1.系统的复杂度会发生质的变化
	- 2.成本会上升

- 架构

	- 同城异区：相比设计和实现的降低了复杂度和成本，但是同城天灾时出现都不可用的概率增大
	- 跨城异地：相比同城天灾影响的概率降低，但是由于存在网络延迟等问题，相关成本大大增加
	- 跨国异地：成本最大

		- 使用场景

			- 为不同的地区提供服务
			- 只读类做多活

- 技巧

	- 同城异区：网络延迟较低可以不用考虑设计
	- 跨城异地：主要网络延迟导致的数据不一致问题，架构是需要考虑
	- 跨国异地：为不同的地区提供服务和只读所以对系统的设计并不多
	- 技巧一：保证核心业务的异地多活
	- 技巧二：核心数据最终一致性

		- 减少异地多活的距离，搭建高速网络
		- 尽量减少数据同步，只同步核心数据
		- 保证数据最终一致性，不保证实时一致性

	- 技巧三：采用多种数据同步手段

		- 消息队列方式
		- 二次读取
		- 存储系统同步方式
		- 回源读取方式：优先访问上次请求的主机
		- 重新生成数据方式

	- 技巧四：只保证绝大部分用户的异地多活

- 设计步骤

	- 1.业务分级

		- 访问量大的业务
		- 核心业务
		- 产生大量收入的业务

	- 2.数据分类

		- 数据量
		- 唯一性
		- 实时性
		- 可丢失性
		- 可恢复性

	- 3.数据同步

		- 存储系统同步方式
		- 消息队列方式
		- 重新生成数据方式

	- 4.异常处理

		- 目的

			- 避免少量数据导致整体业务不可用
			- 问题恢复后，对异常数据进行修复
			- 对用户安抚，进行补偿

		- 措施

			- 多通道同步

				- 一般采用两个通道，再多成本较高
				- 通道尽量隔离，如使用同一个网络，若出现网络问题则都不可用
				- 需要数据覆盖，无论走哪一通道最后结果一致

			- 同步和访问结合

				- 接口访问和数据同步不要走同一个网络
				- 数据有路由规则，可以通过数据确定需要访问哪个去补偿
				- 优先本地数据，其次远程调用，可以节省大量的调用

			- 日志记录

				- 服务器上保存日志
				- 本地独立系统保存日志
				- 日志异地保存

			- 用户补偿

### 接口级的故障应对方案

- 降级：减少功能

	- 系统后门降级：通过参数设置变量控制降级

		- 存在安全问题
		- 主机多的情况需要操作多次，效率低

	- 独立降级系统：解决系统后门降级的问题，把所有的降级抽取为一个服务进行管理

- 熔断：外部依赖的系统存在故障时，要熔断防止影响该系统
- 限流：防止用户访问过于频繁，通过限流降低短时间内访问次数

	- 基于请求限流
	- 基于资源限流

- 排队：如双十一秒杀，通过 MQ 排队购买

## 11. 可扩展模式

### 概述

- 避免添加或修改功能时改动内容过多

### 基本思想

- 拆
- 思路

	- 面向流程拆分

		- 例如:TCP/IP的流程就是应用层>传输层>网络层>物理>数据链路层

	- 面向服务拆分

		- 提供 http 服务、ftp 服务

	- 面向功能拆分

		- 例如：http 的 get，ftp 的文件上下载

### 方式

- 面向流程

	- 一般只需要更改一层，很少会存在修改多层

		- 分层架构

- 面向服务

	- 只需要修改对应的服务，无需修改所有的服务

		- SOA架构、微服务架构

- 面向功能

	- 只需要修改对应的功能，不需要修改所有的功能

		- 微内核架构

## 12. 分层架构

### 类型

- B/S和 C/S 架构
- MVC 和 MVP 架构
- 逻辑分层架构

### 详解

- 隔离关注点
- 只能分层依赖，不可跨层，否则容易出现混乱

## 13. SOA 架构

### 历史

- 企业各部门有独立的系统
- 复杂度逐渐升高，需要多个 IT 系统合作完成流程
- 各系统的技术团队不一样，无法统一重构

### 详解

- 三个概念

	- 服务
	- ESB
	- 松耦合

## 14. 微服务

### 微服务和SOA的关系

- 是两个不同的架构设计理念，只是“服务”上有交集
- 微服务粒度更细
- 服务通信更轻量
- SOA 多是兼容系统，微服务则是快速交付
- SOA 适用于庞大的笨重的项目，微服务更适用轻量的互联网项目

### 微服务的陷阱

- 服务划分过细，服务关系过于复杂
- 服务数量过多，团队效率下降
- 调用链太长，性能下降
- 调用链太长，问题难以定位
- 没有自动化支持，无法快速交付
- 没有微服务治理，服务数量多后管理混乱

### 最佳实践

- 服务粒度

	- 开发阶段，三个人管理一个服务
	- 稳定阶段，可以一个人管理多个

- 拆分方法

	- 基于业务拆分
	- 基于可扩展拆分：成熟和改动的不大的分为稳定服务，经常变动和迭代的分为变动服务
	- 基于可靠性拆分：

		- 避免非核心业务影响核心业务
		- 核心服务高可用更方便
		- 降低高可用成本

	- 基于性能拆分

		- 性能要求高的单独拆分方便提高性能

- 基础设施

	- 服务发现

		- 自理式
		- 代理式

	- 配置中心
	- 接口框架
	- API 网关
	- 服务路由
	- 服务容错

		- 请求重试
		- 流控
		- 服务隔离

	- 服务监控
	- 服务跟踪
	- 服务安全
	- 自动化测试
	- 自动化部署

## 15. 微内核架构（插件化架构）

### 设计的关键点

- 插件管理
- 插件连接
- 插件通信

### OSGI架构

### 规则引擎架构

- 优点

	- 可扩展：业务逻辑和业务系统分离
	- 易理解：规则语言接近自然语言
	- 高效性：提供 UI 可以高效操作

- 基本架构

	- 1. 开发人员将业务功能提炼为多个规则，配置到规则引擎中
	- 2. 业务人员根据业务需要，排列组合规则组成流程，保存到业务系统中
	- 3. 规则引擎实现执行业务流程，实现业务功能

- 如何设计的

	- 插件管理

		- 配置的规则就是插件，引擎就是内核，引擎可以执行规则，规则存储在规则库中

	- 插件连接

		- 规则引擎的语言

	- 插件通信

		- 通过数据流或事件流

- 技术

	- Drools

## 16. 消息队列设计实战

## 17. 互联网架构演进

### 产品类：技术创新推进业务发展，例如手机技术

### 服务类：业务发展推送技术的发展

## 18. 互联网架构模版

### 总体结构

-

### 存储层技术

- SQL
- NoSQL
- 小文件
- 大文件

### 开发层技术

- 开发框架
- web服务器
- 容器

### 服务层技术

- 配置中心
- 服务中心
- 消息队列

### 网络层技术

- 负载均衡
- CDN
- 多机房
- 多中心

### 用户层技术

- 用户管理
- 消息推送
- 存储云与图片云

### 业务层技术

### 平台技术

- 运维平台
- 测试平台
- 数据平台
- 管理平台

## 19. 架构重构

### 原因

- 业务已经上线，不能停下来
- 关联方众多，牵一发动全身
- 旧架构的约束

### 目标

- 后台系统重构-解决不合理的耦合
- 游戏接入系统重构-解决全局单点的可用性问题
- 解决大系统带来的开发效率问题

### 阶段

- 1.救火

	- 机器扩容
	- 业务降级
	- 立体化监控

- 2.组件化

	- 缓存组件化
	- 队列组件化
	- 接入服务中心化

- 3.解耦

	- 核心和非核心业务分离
	- 业务中台
	- 公共功能组件化

### 流程

- 1.划分优先级
- 2.问题分类
- 3.先易后难

## 20. 开源系统

